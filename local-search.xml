<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>H电赛</title>
    <link href="/2025/05/04/H%E7%94%B5%E8%B5%9B/"/>
    <url>/2025/05/04/H%E7%94%B5%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>好的，我们来把每个阶段的学习要点和对应的示例代码具体化。</p><p><strong>重要提示:</strong></p><ul><li>以下代码是示例，你需要根据实际情况（摄像头型号、连接方式、物块颜色/字符、环境光照）进行调整，特别是 <strong>颜色阈值 (thresholds)</strong> 和 <strong>模板匹配阈值 (threshold)</strong>。</li><li>请确保你已经安装了最新版的 OpenMV IDE，并且能够连接到你的 OpenMV 摄像头。</li><li>示例代码默认使用 <code>sensor.RGB565</code> 格式，如果内存不足或处理速度慢，可以尝试 <code>sensor.GRAYSCALE</code>（灰度图），但颜色识别需要 RGB 或 LAB。LAB 色彩空间对光照变化更不敏感，推荐用于颜色识别。</li><li>串口通信部分 (<code>uart</code>) 需要与你的机器人主控板的串口配置（引脚、波特率）一致。</li></ul><hr><p><strong>第一阶段：OpenMV 入门与环境熟悉</strong></p><ul><li><p><strong>知识点/函数:</strong></p><ul><li><code>import sensor, image, time, pyb</code>: 导入必要的库。</li><li><code>sensor.reset()</code>: 初始化摄像头传感器。</li><li><code>sensor.set_pixformat()</code>: 设置图像像素格式 (e.g., <code>sensor.RGB565</code>, <code>sensor.GRAYSCALE</code>)。</li><li><code>sensor.set_framesize()</code>: 设置图像分辨率 (e.g., <code>sensor.QVGA</code> - 320x240, <code>sensor.QQVGA</code> - 160x120)。分辨率越低，处理越快。</li><li><code>sensor.skip_frames()</code>: 跳过一些初始帧，等待摄像头稳定。</li><li><code>sensor.snapshot()</code>: 捕获一帧图像，返回一个 <code>image</code> 对象。</li><li><code>image.draw_cross(x, y)</code>: 在图像上画十字。</li><li><code>image.draw_string(x, y, text)</code>: 在图像上写文字。</li><li><code>time.clock()</code>: 时钟对象，用于计时和计算 FPS。</li><li><code>clock.tick()</code>: 更新时钟。</li><li><code>clock.fps()</code>: 返回当前帧率。</li><li><code>pyb.LED(id)</code>: 控制板载 LED (e.g., <code>pyb.LED(1)</code> 是红灯, <code>pyb.LED(2)</code> 是绿灯, <code>pyb.LED(3)</code> 是蓝灯)。</li><li><code>led.on()</code>, <code>led.off()</code>, <code>led.toggle()</code>: 控制 LED 状态。</li></ul></li><li><p><strong>示例代码 1.1: Hello World 与基本设置</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Hello World Example - By: OpenMV</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Welcome to the OpenMV IDE! Click on the green run arrow button below to run the script!</span><br><br><span class="hljs-keyword">import</span> sensor, image, time, pyb<br><br><span class="hljs-comment"># --- 基本设置 ---</span><br>sensor.reset()                      <span class="hljs-comment"># 初始化摄像头</span><br>sensor.set_pixformat(sensor.RGB565) <span class="hljs-comment"># 设置图像格式为 RGB565 (彩色)</span><br>sensor.set_framesize(sensor.QVGA)   <span class="hljs-comment"># 设置分辨率为 320x240</span><br>sensor.skip_frames(time = <span class="hljs-number">2000</span>)     <span class="hljs-comment"># 等待摄像头稳定 (跳过 2 秒的帧)</span><br><span class="hljs-comment"># sensor.set_auto_gain(False) # 如果光线稳定，可以关闭自动增益</span><br><span class="hljs-comment"># sensor.set_auto_whitebal(False) # 如果光线稳定，可以关闭自动白平衡</span><br><br><span class="hljs-comment"># 创建 LED 对象 (通常 1=Red, 2=Green, 3=Blue)</span><br>red_led = pyb.LED(<span class="hljs-number">1</span>)<br>green_led = pyb.LED(<span class="hljs-number">2</span>)<br>blue_led = pyb.LED(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 创建时钟对象</span><br>clock = time.clock()                <span class="hljs-comment"># 用于跟踪 FPS</span><br><br><span class="hljs-comment"># --- 主循环 ---</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    clock.tick()                    <span class="hljs-comment"># 更新 FPS 计数器</span><br>    img = sensor.snapshot()         <span class="hljs-comment"># 拍摄一张图片</span><br><br>    <span class="hljs-comment"># --- 在图像上做些标记 (可选) ---</span><br>    img.draw_string(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;FPS:%.2f&quot;</span> % clock.fps(), color = (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment"># 左上角显示 FPS (绿色)</span><br>    img.draw_cross(img.width()//<span class="hljs-number">2</span>, img.height()//<span class="hljs-number">2</span>, color = (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment"># 在中心画一个红色十字</span><br><br>    <span class="hljs-comment"># --- 控制 LED (示例) ---</span><br>    <span class="hljs-comment"># 让蓝灯闪烁</span><br>    blue_led.toggle()<br><br>    <span class="hljs-comment"># --- 打印信息到串行终端 (可选) ---</span><br>    <span class="hljs-comment"># print(&quot;FPS:&quot;, clock.fps()) # 实时打印 FPS 到 IDE 的串行终端</span><br><br>    <span class="hljs-comment"># 帧缓冲区会自动显示 img 对象的内容</span><br>    <span class="hljs-comment"># 循环会持续进行，除非断开连接或按下停止按钮</span><br></code></pre></td></tr></table></figure><hr><p><strong>第二阶段：颜色识别与定位</strong></p><ul><li><p><strong>知识点/函数:</strong></p><ul><li><strong>颜色阈值 (Thresholds):</strong> 使用 OpenMV IDE 的工具 -&gt; 机器视觉 -&gt; 阈值编辑器 来确定目标颜色的 LAB 值范围 <code>(L_min, L_max, A_min, A_max, B_min, B_max)</code>。</li><li><code>image.find_blobs(thresholds, pixels_threshold=100, area_threshold=100, merge=False)</code>: 查找色块。<ul><li><code>thresholds</code>: 一个包含颜色阈值的列表，例如 <code>[(30, 100, 15, 127, 15, 127)]</code> 表示查找红色（这个值需要实际调试！）。</li><li><code>pixels_threshold</code>: 色块包含的最小像素数。</li><li><code>area_threshold</code>: 色块的最小面积（像素数）。</li><li><code>merge=True</code>: 合并相邻的、颜色相似的色块。</li></ul></li><li><strong>Blob 对象属性:</strong><ul><li><code>blob.rect()</code>: 返回色块的外接矩形 <code>(x, y, w, h)</code>。</li><li><code>blob.cx()</code>: 返回色块的中心 x 坐标。</li><li><code>blob.cy()</code>: 返回色块的中心 y 坐标。</li><li><code>blob.pixels()</code>: 色块中的像素数量。</li><li><code>blob.area()</code>: 色块面积。</li><li><code>blob.density()</code>: 色块密度 ( pixels / (w*h) )。</li></ul></li><li><code>image.draw_rectangle(rect, color)</code>: 画矩形。</li><li><code>image.draw_cross(x, y, color)</code>: 画十字。</li><li><code>from pyb import UART</code>: 导入 UART 库。</li><li><code>uart = UART(3, 115200)</code>: 初始化串口 3，波特率 115200 (引脚 P4/P5 通常是 UART3)。你需要根据你的硬件连接和主控设置来选择串口号和波特率。</li><li><code>uart.write(data)</code>: 通过串口发送数据。建议发送带换行符 <code>\n</code> 的字符串，方便接收端解析。</li></ul></li><li><p><strong>示例代码 2.1: 查找红色物块并发送坐标</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sensor, image, time, pyb<br><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> UART<br><br><span class="hljs-comment"># --- 基本设置 ---</span><br>sensor.reset()<br>sensor.set_pixformat(sensor.RGB565) <span class="hljs-comment"># 或者 sensor.GRAYSCALE 如果用形状</span><br>sensor.set_framesize(sensor.QVGA)   <span class="hljs-comment"># 根据需要调整</span><br>sensor.skip_frames(time = <span class="hljs-number">2000</span>)<br>clock = time.clock()<br><br><span class="hljs-comment"># --- 串口设置 ---</span><br><span class="hljs-comment"># 注意: 串口号 (1 或 3 等) 和引脚取决于你的 OpenMV 型号和接线</span><br><span class="hljs-comment"># 常用的 UART3 在 H7 Plus 上是 P4(TX), P5(RX)</span><br>uart = UART(<span class="hljs-number">3</span>, <span class="hljs-number">115200</span>, timeout_char=<span class="hljs-number">1000</span>) <span class="hljs-comment"># 波特率要和接收端一致</span><br><br><span class="hljs-comment"># --- 颜色阈值 ---</span><br><span class="hljs-comment"># !!! 关键步骤 !!!</span><br><span class="hljs-comment"># 使用 OpenMV IDE 的 &quot;工具&quot; -&gt; &quot;阈值编辑器&quot; 找到适合你的红色物块和光照条件的 LAB 值</span><br><span class="hljs-comment"># 下面是一个示例值，你需要替换成你自己的!</span><br><span class="hljs-comment"># 格式: (L_min, L_max, A_min, A_max, B_min, B_max)</span><br>red_threshold = (<span class="hljs-number">30</span>, <span class="hljs-number">100</span>, <span class="hljs-number">15</span>, <span class="hljs-number">127</span>, <span class="hljs-number">15</span>, <span class="hljs-number">127</span>) <span class="hljs-comment"># 这是一个示例红色范围，请务必替换!</span><br><br><span class="hljs-comment"># --- 主循环 ---</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    clock.tick()<br>    img = sensor.snapshot()<br><br>    <span class="hljs-comment"># 查找色块</span><br>    <span class="hljs-comment"># pixels_threshold 和 area_threshold 需要根据物块实际大小和距离调整</span><br>    blobs = img.find_blobs([red_threshold], pixels_threshold=<span class="hljs-number">200</span>, area_threshold=<span class="hljs-number">200</span>, merge=<span class="hljs-literal">True</span>, margin=<span class="hljs-number">10</span>)<br><br>    found_red_block = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> blobs:<br>        <span class="hljs-comment"># 如果找到多个色块，可以选择最大的那个</span><br>        largest_blob = <span class="hljs-built_in">max</span>(blobs, key=<span class="hljs-keyword">lambda</span> b: b.pixels())<br><br>        <span class="hljs-comment"># --- 在图像上标记 ---</span><br>        img.draw_rectangle(largest_blob.rect(), color=(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment"># 用绿色框标出</span><br>        img.draw_cross(largest_blob.cx(), largest_blob.cy(), color=(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment"># 标记中心</span><br><br>        <span class="hljs-comment"># --- 准备发送数据 ---</span><br>        cx = largest_blob.cx()<br>        cy = largest_blob.cy()<br>        <span class="hljs-comment"># 定义一个简单的协议，例如: &quot;ID,CX,CY\n&quot;</span><br>        <span class="hljs-comment"># ID=0 代表红色块 (你可以自己定义)</span><br>        uart_data = <span class="hljs-string">f&quot;RED,<span class="hljs-subst">&#123;cx&#125;</span>,<span class="hljs-subst">&#123;cy&#125;</span>\n&quot;</span> <span class="hljs-comment"># 使用 f-string 格式化字符串</span><br><br>        <span class="hljs-comment"># --- 通过串口发送 ---</span><br>        uart.write(uart_data)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sent:&quot;</span>, uart_data.strip()) <span class="hljs-comment"># 在 IDE 终端也打印一下，方便调试</span><br>        found_red_block = <span class="hljs-literal">True</span><br><br>    <span class="hljs-comment"># 如果没找到，也可以发送一个特定消息 (可选)</span><br>    <span class="hljs-comment"># if not found_red_block:</span><br>    <span class="hljs-comment">#     uart.write(&quot;NONE\n&quot;)</span><br>    <span class="hljs-comment">#     print(&quot;Sent: NONE&quot;)</span><br><br>    <span class="hljs-comment"># 显示 FPS</span><br>    img.draw_string(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;FPS:%.1f&quot;</span> % clock.fps(), color=(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))<br><br>    <span class="hljs-comment"># 稍微延时一下，避免发送过快</span><br>    time.sleep_ms(<span class="hljs-number">50</span>) <span class="hljs-comment"># 延时 50 毫秒</span><br></code></pre></td></tr></table></figure><hr><p><strong>第三阶段：特定字符/标记识别与定位</strong></p><ul><li><p><strong>策略一：模板匹配</strong></p><ul><li><strong>知识点/函数:</strong><ul><li>需要预先制作模板图像（<code>.pgm</code> 灰度图或 <code>.bmp</code>），只包含清晰的字符，存放在 OpenMV 的 SD 卡或内部 Flash 中。</li><li><code>image.Image(&quot;template_g.pgm&quot;)</code>: 加载模板图像。</li><li><code>img.find_template(template, threshold, roi=search_roi)</code>: 在 <code>img</code> 中查找 <code>template</code>。<ul><li><code>template</code>: 加载的模板图像对象。</li><li><code>threshold</code>: 匹配度阈值 (0.0 到 1.0 之间，例如 0.7)。越高表示要求越像。需要调试！</li><li><code>roi</code> (Region Of Interest): 可选参数，一个 <code>(x, y, w, h)</code> 的元组，指定只在图像的这个区域内搜索，可以提速。</li></ul></li><li>返回匹配到的矩形区域 <code>(x, y, w, h)</code>，如果没找到则返回 <code>None</code>。</li></ul></li><li><strong>示例代码 3.1: 查找字符 ‘G’ (模板匹配)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sensor, image, time, pyb<br><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> UART<br><br><span class="hljs-comment"># --- 基本设置 ---</span><br>sensor.reset()<br>sensor.set_pixformat(sensor.GRAYSCALE) <span class="hljs-comment"># 模板匹配通常在灰度图上效果更好更快</span><br>sensor.set_framesize(sensor.QVGA)<br>sensor.skip_frames(time = <span class="hljs-number">2000</span>)<br>clock = time.clock()<br><br><span class="hljs-comment"># --- 串口设置 ---</span><br>uart = UART(<span class="hljs-number">3</span>, <span class="hljs-number">115200</span>, timeout_char=<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># --- 加载模板 ---</span><br><span class="hljs-comment"># 确保 &#x27;template_g.pgm&#x27; 文件存在于 OpenMV 的文件系统中 (SD卡或内部Flash)</span><br><span class="hljs-comment"># 模板应该是只包含 &#x27;G&#x27; 字符的灰度图像</span><br><span class="hljs-keyword">try</span>:<br>    template_g = image.Image(<span class="hljs-string">&quot;/template_g.pgm&quot;</span>)<br>    <span class="hljs-comment"># 你可以加载多个模板</span><br>    <span class="hljs-comment"># template_u = image.Image(&quot;/template_u.pgm&quot;)</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Template G loaded.&quot;</span>)<br><span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Error loading template: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>    template_g = <span class="hljs-literal">None</span> <span class="hljs-comment"># 或者退出脚本</span><br><br><span class="hljs-comment"># 模板匹配阈值 (需要根据实际情况调试!)</span><br>MATCH_THRESHOLD = <span class="hljs-number">0.70</span><br><br><span class="hljs-comment"># --- 主循环 ---</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    clock.tick()<br>    img = sensor.snapshot()<br><br>    found_char = <span class="hljs-literal">None</span><br>    found_rect = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># --- 查找模板 &#x27;G&#x27; ---</span><br>    <span class="hljs-keyword">if</span> template_g:<br>        <span class="hljs-comment"># 可选: 定义一个 ROI (Region of Interest) 来限制搜索区域，提高速度</span><br>        <span class="hljs-comment"># search_roi = (50, 50, img.width()-100, img.height()-100) # 示例 ROI</span><br>        <span class="hljs-comment"># r = img.find_template(template_g, MATCH_THRESHOLD, roi=search_roi)</span><br>        r = img.find_template(template_g, MATCH_THRESHOLD) <span class="hljs-comment"># 在整张图搜索</span><br><br>        <span class="hljs-keyword">if</span> r: <span class="hljs-comment"># 如果找到了匹配</span><br>            img.draw_rectangle(r, color=(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)) <span class="hljs-comment"># 用白色框标出</span><br>            found_char = <span class="hljs-string">&quot;G&quot;</span><br>            found_rect = r<br><br>    <span class="hljs-comment"># --- (在这里可以添加查找其他模板的代码 &#x27;U&#x27;, &#x27;E&#x27;, &#x27;T&#x27;...) ---</span><br>    <span class="hljs-comment"># if not found_char and template_u:</span><br>    <span class="hljs-comment">#    r = img.find_template(template_u, MATCH_THRESHOLD)</span><br>    <span class="hljs-comment">#    if r:</span><br>    <span class="hljs-comment">#       img.draw_rectangle(r, color=(255, 255, 255))</span><br>    <span class="hljs-comment">#       found_char = &quot;U&quot;</span><br>    <span class="hljs-comment">#       found_rect = r</span><br>    <span class="hljs-comment"># ...</span><br><br>    <span class="hljs-comment"># --- 发送结果 ---</span><br>    <span class="hljs-keyword">if</span> found_char <span class="hljs-keyword">and</span> found_rect:<br>        <span class="hljs-comment"># 计算中心点 (近似)</span><br>        cx = found_rect[<span class="hljs-number">0</span>] + found_rect[<span class="hljs-number">2</span>] // <span class="hljs-number">2</span><br>        cy = found_rect[<span class="hljs-number">1</span>] + found_rect[<span class="hljs-number">3</span>] // <span class="hljs-number">2</span><br>        uart_data = <span class="hljs-string">f&quot;CHAR,<span class="hljs-subst">&#123;found_char&#125;</span>,<span class="hljs-subst">&#123;cx&#125;</span>,<span class="hljs-subst">&#123;cy&#125;</span>\n&quot;</span><br>        uart.write(uart_data)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sent:&quot;</span>, uart_data.strip())<br>    <span class="hljs-comment"># else:</span><br>        <span class="hljs-comment"># uart.write(&quot;NONE\n&quot;) # 可选：没找到时发送</span><br>        <span class="hljs-comment"># print(&quot;Sent: NONE&quot;)</span><br><br>    img.draw_string(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;FPS:%.1f&quot;</span> % clock.fps(), color=(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))<br>    time.sleep_ms(<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>策略三：AprilTag 识别 (推荐)</strong></p><ul><li><strong>知识点/函数:</strong><ul><li>需要为每个字符 (G, U, E, T, …) 生成并打印不同 ID 的 AprilTag (例如，ID 0 代表 G, ID 1 代表 U, …)，贴在物块上。</li><li><code>image.find_apriltags(families=image.TAG36H11)</code>: 查找 AprilTag。<code>TAG36H11</code> 是常用的家族，也可以用 <code>TAG16H5</code>, <code>TAG25H9</code> 等。</li><li><strong>Tag 对象属性:</strong><ul><li><code>tag.id()</code>: 返回 AprilTag 的 ID 号。</li><li><code>tag.cx()</code>, <code>tag.cy()</code>: 返回中心点坐标。</li><li><code>tag.rect()</code>: 返回外框矩形。</li><li><code>tag.rotation()</code>: 返回旋转角度 (弧度)。</li></ul></li></ul></li><li><strong>示例代码 3.3: 查找 AprilTag 并发送 ID 和坐标</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sensor, image, time, pyb<br><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> UART<br><br><span class="hljs-comment"># --- 基本设置 ---</span><br>sensor.reset()<br>sensor.set_pixformat(sensor.RGB565) <span class="hljs-comment"># AprilTag 可以在彩色或灰度图上运行</span><br>sensor.set_framesize(sensor.QQVGA)  <span class="hljs-comment"># AprilTag 检测计算量较大，建议使用较低分辨率开始</span><br>sensor.skip_frames(time = <span class="hljs-number">2000</span>)<br><span class="hljs-comment"># 对于 AprilTag 检测，可以尝试关闭自动增益和白平衡以获得更稳定的图像</span><br><span class="hljs-comment"># sensor.set_auto_gain(False, gain_db_limit=16.0) # 限制最大增益</span><br><span class="hljs-comment"># sensor.set_auto_whitebal(False, rgb_gain_db=(0,0,0)) # 需要手动调整白平衡值</span><br><br>clock = time.clock()<br><br><span class="hljs-comment"># --- 串口设置 ---</span><br>uart = UART(<span class="hljs-number">3</span>, <span class="hljs-number">115200</span>, timeout_char=<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># --- 字符与 AprilTag ID 映射 (根据你的定义) ---</span><br>tag_to_char = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&quot;G&quot;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&quot;U&quot;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&quot;E&quot;</span>,<br>    <span class="hljs-number">3</span>: <span class="hljs-string">&quot;T&quot;</span>,<br>    <span class="hljs-number">4</span>: <span class="hljs-string">&quot;桂&quot;</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-string">&quot;林&quot;</span>,<br>    <span class="hljs-comment"># ... 添加其他映射</span><br>&#125;<br><br><span class="hljs-comment"># --- 主循环 ---</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    clock.tick()<br>    img = sensor.snapshot()<br><br>    <span class="hljs-comment"># AprilTag 检测比较耗时</span><br>    <span class="hljs-comment"># families 可以指定多种，如 image.TAG16H5 | image.TAG36H11</span><br>    <span class="hljs-comment"># fx, fy, cx, cy 是相机的内参，如果需要精确的姿态估计才需要标定设置，</span><br>    <span class="hljs-comment"># 对于仅获取 ID 和中心点，可以省略。</span><br>    tags = img.find_apriltags(families=image.TAG36H11) <span class="hljs-comment"># 尝试常用的 TAG36H11</span><br><br>    found_tag_info = [] <span class="hljs-comment"># 存储找到的所有 Tag 信息</span><br><br>    <span class="hljs-keyword">if</span> tags:<br>        <span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> tags:<br>            <span class="hljs-comment"># --- 在图像上标记 ---</span><br>            img.draw_rectangle(tag.rect(), color = (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment"># 红色框</span><br>            img.draw_cross(tag.cx(), tag.cy(), color = (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment"># 绿色中心</span><br>            <span class="hljs-comment"># 在 Tag 旁边显示 ID</span><br>            img.draw_string(tag.cx() + <span class="hljs-number">5</span>, tag.cy() - <span class="hljs-number">10</span>, <span class="hljs-built_in">str</span>(tag.<span class="hljs-built_in">id</span>()), color=(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))<br><br>            tag_id = tag.<span class="hljs-built_in">id</span>()<br>            char = tag_to_char.get(tag_id, <span class="hljs-string">&quot;UNK&quot;</span>) <span class="hljs-comment"># 获取对应的字符，如果ID未知则返回 &quot;UNK&quot;</span><br>            cx = tag.cx()<br>            cy = tag.cy()<br><br>            <span class="hljs-comment"># 存储信息，稍后发送</span><br>            found_tag_info.append(&#123;<span class="hljs-string">&quot;char&quot;</span>: char, <span class="hljs-string">&quot;id&quot;</span>: tag_id, <span class="hljs-string">&quot;cx&quot;</span>: cx, <span class="hljs-string">&quot;cy&quot;</span>: cy&#125;)<br><br>            <span class="hljs-comment"># --- 发送数据 ---</span><br>            <span class="hljs-comment"># 你可以选择找到一个就发送，或者找到所有再一起发送/处理</span><br>            uart_data = <span class="hljs-string">f&quot;TAG,<span class="hljs-subst">&#123;char&#125;</span>,<span class="hljs-subst">&#123;tag_id&#125;</span>,<span class="hljs-subst">&#123;cx&#125;</span>,<span class="hljs-subst">&#123;cy&#125;</span>\n&quot;</span><br>            uart.write(uart_data)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sent:&quot;</span>, uart_data.strip())<br><br>    <span class="hljs-comment"># (你可以在这里添加逻辑，比如如果一帧内找到多个，如何处理)</span><br><br>    img.draw_string(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;FPS:%.1f&quot;</span> % clock.fps(), color=(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))<br>    time.sleep_ms(<span class="hljs-number">20</span>) <span class="hljs-comment"># AprilTag 检测较慢，延时可以短一些</span><br></code></pre></td></tr></table></figure></li></ul><hr><p><strong>第四阶段：整合、调试与优化</strong></p><ul><li><p><strong>知识点/函数:</strong></p><ul><li><strong>函数封装:</strong> 使用 <code>def</code> 定义函数，提高代码复用性和可读性。</li><li><strong>健壮性:</strong><ul><li>使用 <code>try...except</code> 处理可能的错误 (如串口写入失败、文件加载失败)。</li><li>添加延时 <code>time.sleep_ms()</code> 避免过于频繁地处理或发送。</li><li>考虑过滤：例如，要求连续几帧都检测到同一个物体才确认。</li></ul></li><li><strong>效率:</strong><ul><li>根据任务需要，选择最低的可用分辨率 <code>sensor.set_framesize()</code>。</li><li>如果只关心特定区域，使用 <code>roi</code> 参数 (如 <code>find_blobs</code>, <code>find_template</code>)。</li><li>如果不需要彩色信息，使用 <code>sensor.GRAYSCALE</code>。</li></ul></li><li><strong>通信协议:</strong> 设计清晰的、双方（OpenMV 和主控）都遵循的格式。例如：<ul><li><code>&quot;TYPE,DATA1,DATA2,...\n&quot;</code></li><li><code>&quot;RED,160,120\n&quot;</code> (红色物块在 160, 120)</li><li><code>&quot;TAG,G,0,155,110\n&quot;</code> (ID 为 0 的 G 字符 AprilTag 在 155, 110)</li><li><code>&quot;NONE\n&quot;</code> (当前视野未找到目标)</li><li><code>&quot;DONE\n&quot;</code> (任务完成或某个状态)</li></ul></li><li><strong>调试:</strong><ul><li><code>print()</code> 输出变量值或状态到串行终端。</li><li>使用 <code>img.draw_...()</code> 函数在帧缓冲区可视化中间结果。</li><li>逐步执行或注释掉部分代码来定位问题。</li></ul></li></ul></li><li><p><strong>示例代码 4.1: 结构化的代码与协议</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sensor, image, time, pyb<br><span class="hljs-keyword">from</span> pyb <span class="hljs-keyword">import</span> UART<br><br><span class="hljs-comment"># --- 全局设置 ---</span><br>IMG_WIDTH = <span class="hljs-number">320</span> <span class="hljs-comment"># QVGA</span><br>IMG_HEIGHT = <span class="hljs-number">240</span><br>sensor.reset()<br>sensor.set_pixformat(sensor.RGB565) <span class="hljs-comment"># 或 GRAYSCALE</span><br>sensor.set_framesize(sensor.QVGA)<br>sensor.skip_frames(time=<span class="hljs-number">2000</span>)<br>clock = time.clock()<br>uart = UART(<span class="hljs-number">3</span>, <span class="hljs-number">115200</span>, timeout_char=<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># --- 颜色阈值 (示例) ---</span><br>red_threshold = (<span class="hljs-number">30</span>, <span class="hljs-number">100</span>, <span class="hljs-number">15</span>, <span class="hljs-number">127</span>, <span class="hljs-number">15</span>, <span class="hljs-number">127</span>) <span class="hljs-comment"># 务必替换!</span><br><br><span class="hljs-comment"># --- AprilTag ID 映射 (示例) ---</span><br>tag_to_char = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&quot;G&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;U&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;T&quot;</span>&#125;<br><br><span class="hljs-comment"># --- 功能函数 ---</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_red_block</span>(<span class="hljs-params">img</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;查找最大的红色色块，返回其中心坐标 (cx, cy) 或 None&quot;&quot;&quot;</span><br>    blobs = img.find_blobs([red_threshold], pixels_threshold=<span class="hljs-number">200</span>, area_threshold=<span class="hljs-number">200</span>, merge=<span class="hljs-literal">True</span>, margin=<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">if</span> blobs:<br>        largest_blob = <span class="hljs-built_in">max</span>(blobs, key=<span class="hljs-keyword">lambda</span> b: b.pixels())<br>        img.draw_rectangle(largest_blob.rect(), color=(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>))<br>        img.draw_cross(largest_blob.cx(), largest_blob.cy(), color=(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> largest_blob.cx(), largest_blob.cy()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_char_tags</span>(<span class="hljs-params">img</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;查找 AprilTags，返回包含 &#123;&#x27;char&#x27;, &#x27;id&#x27;, &#x27;cx&#x27;, &#x27;cy&#x27;&#125; 的列表&quot;&quot;&quot;</span><br>    tags_found = []<br>    tags = img.find_apriltags(families=image.TAG36H11) <span class="hljs-comment"># 使用适合的分辨率</span><br>    <span class="hljs-keyword">if</span> tags:<br>        <span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> tags:<br>             img.draw_rectangle(tag.rect(), color = (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>             img.draw_cross(tag.cx(), tag.cy(), color = (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>))<br>             tag_id = tag.<span class="hljs-built_in">id</span>()<br>             char = tag_to_char.get(tag_id, <span class="hljs-string">&quot;UNK&quot;</span>)<br>             cx = tag.cx()<br>             cy = tag.cy()<br>             img.draw_string(cx + <span class="hljs-number">5</span>, cy - <span class="hljs-number">10</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;char&#125;</span>(<span class="hljs-subst">&#123;tag_id&#125;</span>)&quot;</span>, color=(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))<br>             tags_found.append(&#123;<span class="hljs-string">&quot;char&quot;</span>: char, <span class="hljs-string">&quot;id&quot;</span>: tag_id, <span class="hljs-string">&quot;cx&quot;</span>: cx, <span class="hljs-string">&quot;cy&quot;</span>: cy&#125;)<br>    <span class="hljs-keyword">return</span> tags_found<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_uart_data</span>(<span class="hljs-params">message_type, *args</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;格式化并发送 UART 数据，带换行符&quot;&quot;&quot;</span><br>    data_str = <span class="hljs-string">&quot;,&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, args))<br>    uart_message = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;message_type&#125;</span>,<span class="hljs-subst">&#123;data_str&#125;</span>\n&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        uart.write(uart_message)<br>        <span class="hljs-comment"># print(&quot;Sent:&quot;, uart_message.strip()) # 调试时取消注释</span><br>    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;UART Write Error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># --- 主循环 ---</span><br>current_task = <span class="hljs-string">&quot;FIND_RED&quot;</span> <span class="hljs-comment"># 假设初始任务是找红色块 (这可以由主控通过串口命令改变)</span><br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    clock.tick()<br>    img = sensor.snapshot()<br><br>    <span class="hljs-comment"># --- 根据当前任务执行不同的识别 ---</span><br>    <span class="hljs-keyword">if</span> current_task == <span class="hljs-string">&quot;FIND_RED&quot;</span>:<br>        red_pos = find_red_block(img)<br>        <span class="hljs-keyword">if</span> red_pos:<br>            send_uart_data(<span class="hljs-string">&quot;RED_FOUND&quot;</span>, red_pos[<span class="hljs-number">0</span>], red_pos[<span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># 可以根据需要切换任务，例如: current_task = &quot;WAITING&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            send_uart_data(<span class="hljs-string">&quot;RED_NOT_FOUND&quot;</span>)<br><br>    <span class="hljs-keyword">elif</span> current_task == <span class="hljs-string">&quot;FIND_CHARS&quot;</span>:<br>        tags = find_char_tags(img)<br>        <span class="hljs-keyword">if</span> tags:<br>            <span class="hljs-comment"># 可以选择发送第一个找到的，或者发送所有找到的信息</span><br>            <span class="hljs-comment"># 这里发送第一个找到的 G, U, E, 或 T</span><br>            <span class="hljs-keyword">for</span> tag_info <span class="hljs-keyword">in</span> tags:<br>                <span class="hljs-keyword">if</span> tag_info[<span class="hljs-string">&quot;char&quot;</span>] <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;G&quot;</span>, <span class="hljs-string">&quot;U&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;T&quot;</span>]:<br>                   send_uart_data(<span class="hljs-string">&quot;TAG_FOUND&quot;</span>, tag_info[<span class="hljs-string">&quot;char&quot;</span>], tag_info[<span class="hljs-string">&quot;id&quot;</span>], tag_info[<span class="hljs-string">&quot;cx&quot;</span>], tag_info[<span class="hljs-string">&quot;cy&quot;</span>])<br>                   <span class="hljs-comment"># break # 如果只需要找到一个就停止查找并发送</span><br>            <span class="hljs-comment"># 如果需要发送所有找到的 tag:</span><br>            <span class="hljs-comment"># for tag_info in tags:</span><br>            <span class="hljs-comment">#    send_uart_data(&quot;TAG_FOUND&quot;, tag_info[&quot;char&quot;], tag_info[&quot;id&quot;], tag_info[&quot;cx&quot;], tag_info[&quot;cy&quot;])</span><br><br>        <span class="hljs-keyword">else</span>:<br>            send_uart_data(<span class="hljs-string">&quot;TAG_NOT_FOUND&quot;</span>)<br><br>    <span class="hljs-comment"># --- (可以添加更多任务状态) ---</span><br>    <span class="hljs-keyword">elif</span> current_task == <span class="hljs-string">&quot;WAITING&quot;</span>:<br>        <span class="hljs-comment"># 等待主控指令</span><br>        <span class="hljs-keyword">pass</span> <span class="hljs-comment"># 可以在这里添加接收串口指令的代码</span><br><br>    <span class="hljs-comment"># --- 接收串口指令 (简单示例) ---</span><br>    <span class="hljs-comment"># if uart.any():</span><br>    <span class="hljs-comment">#    command = uart.readline()</span><br>    <span class="hljs-comment">#    if command:</span><br>    <span class="hljs-comment">#        command = command.strip().decode() # 解码 bytes 为 string</span><br>    <span class="hljs-comment">#        print(&quot;Received Command:&quot;, command)</span><br>    <span class="hljs-comment">#        if command == &quot;TASK_FIND_RED&quot;:</span><br>    <span class="hljs-comment">#            current_task = &quot;FIND_RED&quot;</span><br>    <span class="hljs-comment">#        elif command == &quot;TASK_FIND_CHARS&quot;:</span><br>    <span class="hljs-comment">#            current_task = &quot;FIND_CHARS&quot;</span><br>    <span class="hljs-comment">#        elif command == &quot;TASK_WAIT&quot;:</span><br>    <span class="hljs-comment">#            current_task = &quot;WAITING&quot;</span><br><br>    <span class="hljs-comment"># 显示 FPS</span><br>    img.draw_string(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;FPS:%.1f Task:%s&quot;</span> % (clock.fps(), current_task), color=(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>), scale=<span class="hljs-number">1</span>, mono_space=<span class="hljs-literal">False</span>)<br><br>    time.sleep_ms(<span class="hljs-number">30</span>) <span class="hljs-comment"># 根据处理时间调整延时</span><br></code></pre></td></tr></table></figure><hr><p><strong>下一步行动:</strong></p><ol><li><strong>实际操作:</strong> 把代码下载到你的 OpenMV，连接好串口到你的电脑（或者机器人主控板，用串口监视器）。</li><li><strong>调试阈值:</strong> <strong>最重要的一步</strong>是用阈值编辑器找到准确的颜色阈值。对于模板匹配，要制作好的模板并调试匹配阈值。</li><li><strong>测试通信:</strong> 确保你的机器人主控能正确接收并解析 OpenMV 发送过来的串口数据。</li><li><strong>环境适应:</strong> 在接近比赛的场地和光照下测试，调整参数，提高稳定性。</li><li><strong>选择策略:</strong> 根据测试效果，决定最终使用哪种识别策略（颜色、模板、AprilTag 等）。对于 H 题的字符识别，强烈建议优先考虑 <strong>AprilTag</strong>（如果规则允许），其次是模板匹配（对字体、大小、旋转敏感），颜色代码是备选（如果可以自定义物块颜色）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剩余规划</title>
    <link href="/2025/04/25/kaoyan/guihua/%E5%89%A9%E4%BD%99%E8%A7%84%E5%88%92/"/>
    <url>/2025/04/25/kaoyan/guihua/%E5%89%A9%E4%BD%99%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>距离6月底大约还有9周半的时间（约66天）。这是一个强度比较大的计划，需要你付出极大的努力和专注。</p><p>以下是为你量身定做的学习计划建议，分为<strong>数学</strong>和<strong>408专业课</strong>两大块，并按周分解：</p><p><strong>核心原则：</strong></p><ol><li><strong>并行推进：</strong> 数学和408必须同时进行，不能学完一门再学另一门。</li><li><strong>时间分配（估算）：</strong> 建议每天有效学习时间不少于8小时（根据个人情况调整）。大致可以将时间对半分给数学和408，或者根据当天具体任务调整，例如上午数学，下午专业课，晚上查漏补缺或做题。</li><li><strong>练习结合：</strong> 理论学习和习题练习紧密结合，学完一章/节立刻做对应的基础题巩固。</li><li><strong>效率优先：</strong> 第一轮复习重在理解基础概念、掌握基本方法，对于难题、偏题可以暂时标记，不必过分纠结。</li><li><strong>及时调整：</strong> 每周末根据本周完成情况，微调下周计划。</li></ol><p><strong>详细计划（按周划分）：</strong></p><p><strong>第一阶段：补齐短板，全面启动 (第1-3周：约4月25日 - 5月15日)</strong></p><ul><li><strong>本阶段目标：</strong> 完成高数剩余内容及全部基础习题，完成线代第一轮学习和基础习题，继续推进计组，完成数据结构习题。</li><li><strong>数学 (每天约4小时)：</strong><ul><li><strong>第1周：</strong><ul><li>完成高数剩余理论：级数、三重积分及应用等。（约2-3天）</li><li>完成高数基础习题册：从第6章继续，力争本周完成所有高数基础习题。（每天坚持做）</li></ul></li><li><strong>第2-3周：</strong><ul><li><strong>主攻线性代数：</strong> 快速过完线代的基础理论（教材/辅导讲义），同步完成对应的基础习题（如李永乐660题或类似基础题集）。线代章节不多，但概念抽象，要注重理解。争取2周内结束线代第一轮。</li></ul></li></ul></li><li><strong>408专业课 (每天约4小时)：</strong><ul><li><strong>第1周：</strong><ul><li>完成数据结构王道书后习题。（利用计组学习间隙或专门时间，尽快扫尾）</li><li><strong>主攻计算机组成原理：</strong> 从第二章继续，按章节学习，学完一章做一章的王道选择题。目标：本周学完2-3章。</li></ul></li><li><strong>第2-3周：</strong><ul><li><strong>持续推进计算机组成原理：</strong> 保持每天学习进度，同步做题。目标：第3周末，计组理论学习过半或接近完成，习题跟上进度。</li></ul></li></ul></li></ul><p><strong>第二阶段：攻坚克难，稳步推进 (第4-7周：约5月16日 - 6月12日)</strong></p><ul><li><strong>本阶段目标：</strong> 完成概率论第一轮学习和基础习题，完成计组学习和习题，启动并完成操作系统第一轮学习和基础习题。</li><li><strong>数学 (每天约4小时)：</strong><ul><li><strong>第4-5周 (或第6周初)：</strong><ul><li><strong>主攻概率论与数理统计：</strong> 同线代，快速过基础理论，同步做基础习题。概率论随机变量及其分布、数字特征是重点。争取2.5-3周内结束。</li></ul></li></ul></li><li><strong>408专业课 (每天约4小时)：</strong><ul><li><strong>第4周：</strong><ul><li>完成计算机组成原理所有章节的理论学习，并完成王道书后对应的选择题。</li></ul></li><li><strong>第5-7周：</strong><ul><li><strong>主攻操作系统：</strong> 这是408的重点和难点之一。按章节学习（进程管理、内存管理、文件管理、I/O管理是核心），理解概念，掌握算法。同步完成王道书后选择题。争取3周内完成第一轮。</li></ul></li></ul></li></ul><p><strong>第三阶段：全面覆盖，收官冲刺 (第8-9.5周：约6月13日 - 6月30日)</strong></p><ul><li><strong>本阶段目标：</strong> 完成计算机网络第一轮学习和基础习题，回顾检查数学和408各科，确保所有科目第一轮已过完。</li><li><strong>数学 (每天约4小时)：</strong><ul><li><strong>主要任务：</strong><ul><li>如果概率论未完成，本阶段初优先完成。</li><li>检查高数、线代、概率论的基础习题是否都已做完。</li><li>对第一轮复习中标记的重点、难点、易错点进行初步回顾。可以快速翻阅笔记或错题。</li></ul></li></ul></li><li><strong>408专业课 (每天约4小时)：</strong><ul><li><strong>第8-9.5周：</strong><ul><li><strong>主攻计算机网络：</strong> 计网内容相对独立，但也庞杂。重点掌握TCP/IP协议栈各层基本原理和协议（物理层、数据链路层、网络层、传输层、应用层）。同步完成王道书后选择题。争取2.5周内完成。</li><li><strong>查漏补缺：</strong> 利用剩余时间，快速回顾检查数据结构、计组、操作系统的知识点和习题完成情况。</li></ul></li></ul></li></ul><p><strong>每日时间安排建议 (示例)：</strong></p><ul><li><strong>上午 (3.5-4小时):</strong> 数学（理论学习 + 习题）</li><li><strong>下午 (3.5-4小时):</strong> 408专业课（理论学习 + 习题）</li><li><strong>晚上 (1-2小时):</strong> 整理笔记、回顾当天内容、处理遗留问题、做前一天的错题，或者稍微放松调整。</li></ul><p><strong>重要注意事项：</strong></p><ol><li><strong>教材与资料：</strong> 尽快确定并固定使用的教材、辅导讲义（如张宇、李永乐、汤家凤等）和习题集（如660题、1800题、王道单科书等），不要中途频繁更换。</li><li><strong>笔记与总结：</strong> 学习过程中要做好笔记，特别是自己理解困难或易错的地方。每学完一个章节或科目，尝试进行简单的框架性总结。</li><li><strong>习题质量：</strong> 第一轮做基础题是为了巩固知识点，务必理解每道题背后的原理，不要只追求速度和数量。错题要及时订正并反思。</li><li><strong>心态调整：</strong> 考研是长期战役，这个阶段压力大很正常。保持积极心态，允许自己有状态起伏，但要保证整体进度。感到焦虑时可以短暂休息或与人交流。</li><li><strong>作息规律：</strong> 保证充足睡眠（7-8小时），规律饮食，适当进行短暂的放松活动（如散步、听音乐），保持身心健康是高效学习的基础。</li><li><strong>灵活性：</strong> 这个计划是一个框架，具体执行中肯定会遇到与预期不符的情况。比如某章节特别难，可能需要多花半天时间。要学会灵活调整，但保证总体目标不变。</li></ol><p><strong>6月底的目标状态：</strong></p><ul><li>数学三科（高数、线代、概率）基础理论过完一遍，配套的基础习题册（如660题或类似难度）基本完成。</li><li>408四门专业课（数据结构、计组、操作系统、计网）基础理论过完一遍，王道等辅导书的课后选择题基本完成。</li><li>对各科的基本概念、框架和常见题型有初步掌握。</li><li>积累了一定的笔记和错题。</li></ul><p>这个计划强度很大，意味着你接下来的两个多月需要非常专注和自律。请务必根据自己的实际学习效率和习惯进行微调。加油，祝你学习顺利，成功上岸！</p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
      <tag>408专业课</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的代码掌握</title>
    <link href="/2025/04/15/kaoyan/408/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A3%E7%A0%81%E6%8E%8C%E6%8F%A1/"/>
    <url>/2025/04/15/kaoyan/408/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A3%E7%A0%81%E6%8E%8C%E6%8F%A1/</url>
    
    <content type="html"><![CDATA[<p>为了帮助通过编码实践掌握考研中二叉树的所有知识点，设计了一个分阶段的学习计划，包含核心知识点梳理和配套的编程练习题。</p><p><strong>核心原则：</strong></p><ol><li><strong>理解概念为先：</strong> 先彻底理解每个知识点的定义、性质和应用场景。</li><li><strong>编码实践为重：</strong> 通过编写代码将理论转化为实际能力，加深理解并锻炼实现技巧。</li><li><strong>循序渐进：</strong> 从基础到复杂，逐步深入。</li><li><strong>举一反三：</strong> 掌握核心操作后，能灵活应用于各种变种问题。</li><li><strong>重视效率：</strong> 关注算法的时间和空间复杂度，这是考研的重要考点。</li></ol><p><strong>推荐编程语言：</strong> C/C++ 或 Java（考研主流语言），Python 也可以用于快速学习和验证思路。以下题目描述不限语言，但你需要用你选择的语言实现。</p><hr><h3 id="第一阶段：二叉树基础与遍历">第一阶段：二叉树基础与遍历</h3><p><strong>知识点梳理：</strong></p><ol><li><strong>二叉树定义：</strong> 节点、根节点、子节点、父节点、兄弟节点、叶子节点、度（入度/出度）、路径、层、深度、高度。</li><li><strong>二叉树性质：</strong><ul><li>第 i 层最多有 2^(i-1) 个节点 (i≥1)。</li><li>深度为 k 的二叉树最多有 2^k - 1 个节点 (k≥1)。</li><li>对于任何非空二叉树 T，若 n0 是叶节点数，n2 是度为 2 的节点数，则 n0 = n2 + 1。</li></ul></li><li><strong>特殊二叉树：</strong><ul><li><strong>满二叉树：</strong> 定义、性质（节点数、叶子数）。</li><li><strong>完全二叉树：</strong> 定义（按层序编号与满二叉树一致）、性质（深度、节点关系）。</li></ul></li><li><strong>二叉树存储结构：</strong><ul><li><strong>链式存储：</strong> 节点结构（data, lchild, rchild），画图表示。</li><li><strong>顺序存储：</strong> 仅适用于完全二叉树，下标关系（父找子，子找父）。</li></ul></li><li><strong>二叉树遍历（重点与难点）：</strong><ul><li><strong>前序遍历 (Pre-order):</strong> 根 -&gt; 左 -&gt; 右 (递归与非递归/迭代实现)。</li><li><strong>中序遍历 (In-order):</strong> 左 -&gt; 根 -&gt; 右 (递归与非递归/迭代实现)。</li><li><strong>后序遍历 (Post-order):</strong> 左 -&gt; 右 -&gt; 根 (递归与非递归/迭代实现)。</li><li><strong>层序遍历 (Level-order):</strong> 使用队列实现。</li></ul></li></ol><p><strong>编码练习题：</strong></p><ol><li><strong>【基础】定义二叉树节点：</strong> 设计并实现一个二叉树节点结构（或类）。<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 示例 (C++)</span><br>struct TreeNode &#123;<br>    int val;<br>    TreeNode *<span class="hljs-attribute">left</span>;<br>    TreeNode *<span class="hljs-attribute">right</span>;<br>    <span class="hljs-built_in">TreeNode</span>(int x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><strong>【遍历-递归】实现递归遍历：</strong> 编写函数，分别实现二叉树的前序、中序、后序递归遍历。<ul><li><strong>输入：</strong> 二叉树的根节点。</li><li><strong>输出：</strong> 按相应顺序打印节点值（或返回节点值列表）。</li></ul></li><li><strong>【遍历-迭代】实现迭代遍历：</strong> 编写函数，分别实现二叉树的前序、中序、后序迭代遍历（通常使用栈）。<ul><li><strong>输入：</strong> 二叉树的根节点。</li><li><strong>输出：</strong> 按相应顺序打印节点值（或返回节点值列表）。</li></ul></li><li><strong>【遍历-层序】实现层序遍历：</strong> 编写函数，实现二叉树的层序遍历（使用队列）。<ul><li><strong>输入：</strong> 二叉树的根节点。</li><li><strong>输出：</strong> 按层序打印节点值（或返回节点值列表，甚至按层分组的列表）。</li></ul></li><li><strong>【基础操作】计算二叉树属性：</strong><ul><li>编写函数计算二叉树的高度（或深度）。</li><li>编写函数计算二叉树的节点总数。</li><li>编写函数计算二叉树的叶子节点数。</li><li>编写函数计算二叉树度为 1 的节点数。</li><li>编写函数计算二叉树度为 2 的节点数。</li><li>编写函数计算二叉树第 k 层的节点数。</li></ul></li><li><strong>【构造】根据遍历序列构造二叉树：</strong><ul><li>给定前序遍历和中序遍历序列，构造二叉树。</li><li>给定后序遍历和中序遍历序列，构造二叉树。</li><li><strong>思考：</strong> 为什么不能仅根据前序和后序遍历序列构造唯一的二叉树？</li></ul></li></ol><hr><h3 id="第二阶段：特殊二叉树与应用">第二阶段：特殊二叉树与应用</h3><p><strong>知识点梳理：</strong></p><ol><li><strong>二叉搜索树 (BST, Binary Search Tree / Binary Sort Tree)：</strong><ul><li><strong>定义：</strong> 左子树所有节点 &lt; 根节点 &lt; 右子树所有节点，递归定义。</li><li><strong>操作：</strong> 查找、插入、删除（删除是难点，考虑三种情况）。</li><li><strong>性质：</strong> 中序遍历结果是一个递增序列。</li><li><strong>应用：</strong> 查找、排序。</li><li><strong>局限：</strong> 可能退化成链表，导致效率降低。</li></ul></li><li><strong>平衡二叉树 (Balanced Binary Tree)：</strong><ul><li><strong>动机：</strong> 解决 BST 可能退化的问题。</li><li><strong>AVL 树：</strong><ul><li>定义：任何节点的左右子树高度差不超过 1。</li><li>平衡因子 (Balance Factor)。</li><li>失衡调整：四种旋转（LL, RR, LR, RL）的原理和实现（插入操作后的调整是重点）。</li></ul></li><li><strong>红黑树 (Red-Black Tree)：</strong>（考研重点在于理解概念、性质，不一定要求手写复杂实现）<ul><li>定义：满足 5 条性质的自平衡二叉搜索树。</li><li>性质（了解即可）：节点红或黑、根黑、叶节点（NIL）黑、红节点子节点必黑、根到叶节点黑节点数相同。</li><li>优势：相比 AVL，插入删除操作的平均旋转次数较少。</li></ul></li></ul></li><li><strong>堆 (Heap)：</strong><ul><li><strong>定义：</strong> 完全二叉树，满足父节点值 ≥ (或 ≤) 子节点值（最大堆/最小堆）。</li><li><strong>存储：</strong> 通常用数组（顺序存储）实现。</li><li><strong>操作：</strong> 插入（上浮/sift-up）、删除堆顶（下沉/sift-down/heapify）、建堆（Build Heap）。</li><li><strong>应用：</strong> 堆排序、优先队列。</li></ul></li><li><strong>哈夫曼树 (Huffman Tree / Optimal Binary Tree)：</strong><ul><li><strong>背景：</strong> 数据压缩。</li><li><strong>定义：</strong> 带权路径长度 (WPL) 最小的二叉树。</li><li><strong>构造：</strong> 贪心算法（选择权值最小的两个节点合并，重复此过程）。</li><li><strong>哈夫曼编码：</strong> 前缀编码，无歧义。</li></ul></li><li><strong>线索二叉树 (Threaded Binary Tree)：</strong><ul><li><strong>动机：</strong> 利用空指针域存储前驱/后继信息，方便非递归遍历。</li><li><strong>线索化：</strong> 前序、中序、后序线索化（中序最常用）。</li><li><strong>节点结构：</strong> 增加标志位区分指针是指向孩子还是线索。</li><li><strong>遍历：</strong> 利用线索进行遍历。</li></ul></li></ol><p><strong>编码练习题：</strong></p><ol start="7"><li><strong>【BST】实现 BST 操作：</strong><ul><li>编写函数在一个 BST 中查找指定值的节点。</li><li>编写函数向一个 BST 中插入一个新值。</li><li>编写函数从一个 BST 中删除一个指定值的节点（需要仔细处理被删节点有 0, 1, 2 个孩子的情况）。</li><li>编写函数判断一棵给定的二叉树是否为 BST。</li></ul></li><li><strong>【BST应用】查找第 K 小/大元素：</strong> 在 BST 中快速找到第 K 小（或第 K 大）的元素。 (提示：利用中序遍历)</li><li><strong>【平衡树-概念】理解 AVL 旋转：</strong> 手动模拟在 AVL 树中插入元素导致失衡后的四种旋转调整过程（画图）。</li><li><strong>【平衡树-实现】AVL 树插入：</strong> （选做，难度较高）实现 AVL 树的插入操作，包括插入节点和必要的旋转调整。</li><li><strong>【堆】实现堆操作：</strong><ul><li>给定一个数组，实现原地建堆（最大堆或最小堆）。</li><li>实现向堆中插入元素的操作。</li><li>实现删除堆顶元素的操作。</li></ul></li><li><strong>【堆应用】堆排序：</strong> 利用堆实现排序算法。</li><li><strong>【堆应用】Top K 问题：</strong> 从大量数据中找出最大（或最小）的 K 个元素（使用最小堆或最大堆）。</li><li><strong>【哈夫曼树】构造哈夫曼树：</strong><ul><li>给定一组权值（例如字符频率），构造对应的哈夫曼树。</li><li>计算构造出的哈夫曼树的带权路径长度 (WPL)。</li><li>（选做）生成每个字符的哈夫曼编码。</li></ul></li><li><strong>【线索二叉树】中序线索化：</strong><ul><li>编写函数将一个普通二叉树进行中序线索化。</li><li>编写函数在中序线索二叉树中查找指定节点的中序后继。</li></ul></li></ol><hr><h3 id="第三阶段：综合应用与难题">第三阶段：综合应用与难题</h3><p><strong>知识点梳理：</strong></p><ol><li><strong>二叉树的序列化与反序列化：</strong> 如何将二叉树转换为字符串（或其他序列）以便存储或传输，以及如何从序列恢复原来的二叉树结构。通常基于前序或层序遍历。</li><li><strong>最近公共祖先 (LCA, Lowest Common Ancestor)：</strong><ul><li>在普通二叉树中查找两个节点的 LCA。</li><li>在 BST 中查找两个节点的 LCA（利用 BST 性质可以简化）。</li></ul></li><li><strong>二叉树的直径：</strong> 树中任意两个节点之间最长路径的长度。</li><li><strong>判断对称二叉树/镜像二叉树。</strong></li><li><strong>子结构判断：</strong> 判断树 B 是否是树 A 的子结构。</li><li><strong>路径问题：</strong> 查找从根节点到叶子节点的所有路径，查找路径和等于给定值的路径等。</li></ol><p><strong>编码练习题：</strong></p><ol start="16"><li><strong>【序列化】序列化与反序列化：</strong> 实现二叉树的序列化和反序列化（例如，按前序遍历序列化，包含空节点标记）。</li><li><strong>【LCA】最近公共祖先：</strong><ul><li>编写函数查找普通二叉树中两个给定节点的最近公共祖先。</li><li>编写函数查找 BST 中两个给定节点的最近公共祖先。</li></ul></li><li><strong>【树属性】计算二叉树的直径：</strong> 编写函数计算二叉树的直径。</li><li><strong>【树判断】对称二叉树：</strong> 编写函数判断一棵二叉树是否是对称的（镜像对称）。</li><li><strong>【树判断】子结构：</strong> 编写函数判断树 B 是否是树 A 的子结构。</li><li><strong>【路径】路径总和：</strong><ul><li>编写函数找出所有从根节点到叶子节点的路径。</li><li>编写函数判断是否存在从根节点到叶子节点的路径，使得路径上节点值之和等于一个给定目标值。</li><li>（进阶）找出所有从根节点到叶子节点的路径中，节点值之和等于目标值的路径。</li></ul></li></ol><hr><h3 id="学习建议：">学习建议：</h3><ol><li><strong>画图！画图！画图！</strong> 理解二叉树操作最有效的方法是画图模拟过程，尤其是递归、删除、旋转等操作。</li><li><strong>先递归，后迭代：</strong> 递归通常更符合树形结构的定义，更容易理解。掌握递归后，再挑战迭代实现，这对理解栈和队列的应用非常有帮助。</li><li><strong>测试用例：</strong> 对你编写的每个函数，都要设计充分的测试用例，包括：<ul><li>空树</li><li>只有根节点的树</li><li>左右子树都有的普通树</li><li>退化成链表的树（左斜/右斜）</li><li>完全二叉树</li><li>包含重复值的树（如果允许）</li><li>针对特定操作的边界情况（如删除叶子节点、只有左/右孩子的节点、根节点等）。</li></ul></li><li><strong>理解复杂度：</strong> 分析你写的每个算法的时间复杂度和空间复杂度。考研选择题和算法设计题都会考察。</li><li><strong>参考资料：</strong> 结合经典的考研数据结构教材（如王道、天勤等）和在线资源（如 LeetCode、牛客网上的二叉树题目）进行学习和练习。</li><li><strong>反复练习：</strong> 二叉树的很多操作和技巧需要反复练习才能熟练掌握，尤其是各种遍历的非递归实现、BST 删除、AVL 旋转等。</li></ol>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408复习</tag>
      
      <tag>数据结构</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中序线索化</title>
    <link href="/2025/04/10/kaoyan/408/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96/"/>
    <url>/2025/04/10/kaoyan/408/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408复习</tag>
      
      <tag>专业课</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不定积分所有求解方法总结</title>
    <link href="/2025/04/10/kaoyan/shuxue/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E6%89%80%E6%9C%89%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2025/04/10/kaoyan/shuxue/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E6%89%80%E6%9C%89%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="不定积分的求解方法总结">不定积分的求解方法总结</h2><p>每种方法均附有典型例题，确保全面覆盖常见技巧：</p><hr><h3 id="一、基本积分公式">一、基本积分公式</h3><p>直接应用基本积分表中的公式，适用于简单函数</p><p><strong>例1</strong><br>$$<br>\int x^3 , dx = \frac{x^4}{4} + C<br>$$</p><p><strong>例2</strong><br>$$<br>\int \cos x , dx = \sin x + C<br>$$</p><hr><h3 id="二、线性换元法（凑微分法）">二、线性换元法（凑微分法）</h3><p>通过调整被积函数的形式，使其匹配基本积分公式</p><p><strong>例3</strong><br>$$<br>\int (2x + 1)^5 , dx<br>$$<br><strong>解</strong>：<br>令 $u = 2x + 1$，则 $du = 2dx$，即 $dx = \frac{1}{2}du$<br>$$<br>\int u^5 \cdot \frac{1}{2} du = \frac{1}{12}u^6 + C = \frac{(2x + 1)^6}{12} + C<br>$$</p><hr><h3 id="三、分部积分法">三、分部积分法</h3><p>适用于积分中乘积项的结构，公式为：<br>$$<br>\int u , dv = uv - \int v , du<br>$$</p><p><strong>例4</strong><br>$$<br>\int x e^x , dx<br>$$<br><strong>解</strong>：<br>令 $u = x$，$dv = e^x dx$，则 $du = dx$，$v = e^x$<br>$$<br>\int x e^x dx = x e^x - \int e^x dx = x e^x - e^x + C<br>$$</p><hr><h3 id="四、三角换元法">四、三角换元法</h3><p>处理含根式（如 $\sqrt{a^2 - x^2}$）的积分，常用换元：</p><ul><li>$x = a \sin \theta$（用于 $\sqrt{a^2 - x^2}$）</li><li>$x = a \tan \theta$（用于 $\sqrt{a^2 + x^2}$）</li><li>$x = a \sec \theta$（用于 $\sqrt{x^2 - a^2}$）</li></ul><p><strong>例5</strong><br>$$<br>\int \frac{1}{\sqrt{1 - x^2}} , dx<br>$$<br><strong>解</strong>：<br>令 $x = \sin \theta$，则 $dx = \cos \theta d\theta$<br>$$<br>\int \frac{\cos \theta}{\sqrt{1 - \sin^2 \theta}} d\theta = \int 1 , d\theta = \theta + C = \arcsin x + C<br>$$</p><hr><h3 id="五、有理函数积分">五、有理函数积分</h3><p>将有理函数分解为部分分式之和，再逐项积分</p><p><strong>例6</strong><br>$$<br>\int \frac{2x + 3}{(x + 1)(x + 2)} , dx<br>$$<br><strong>解</strong>：<br>设 $\frac{2x + 3}{(x + 1)(x + 2)} = \frac{A}{x + 1} + \frac{B}{x + 2}$，解得 $A = 1$，$B = 1$<br>$$<br>\int \left( \frac{1}{x + 1} + \frac{1}{x + 2} \right) dx = \ln|x + 1| + \ln|x + 2| + C<br>$$</p><hr><h3 id="六、倒代换">六、倒代换</h3><p>处理分母次数较高的积分，令 $t = \frac{1}{x}$</p><p><strong>例7</strong><br>$$<br>\int \frac{1}{x^2(1 + x^2)} , dx<br>$$<br><strong>解</strong>：<br>令 $t = \frac{1}{x}$，则 $x = \frac{1}{t}$，$dx = -\frac{1}{t^2} dt$<br>$$<br>\int \frac{t^2}{1 + t^2} \cdot \left(-\frac{1}{t^2}\right) dt = -\int \frac{1}{1 + t^2} dt = -\arctan t + C = -\arctan \frac{1}{x} + C<br>$$</p><hr><h3 id="七、万能三角代换">七、万能三角代换</h3><p>适用于含 $\sin x$ 和 $\cos x$ 的有理式积分，令 $t = \tan \frac{x}{2}$</p><p><strong>例8</strong><br>$$<br>\int \frac{1}{1 + \sin x} , dx<br>$$<br><strong>解</strong>：<br>令 $t = \tan \frac{x}{2}$，则 $\sin x = \frac{2t}{1 + t^2}$，$dx = \frac{2}{1 + t^2} dt$<br>$$<br>\int \frac{1}{1 + \frac{2t}{1 + t^2}} \cdot \frac{2}{1 + t^2} dt = \int \frac{2}{(1 + t)^2} dt = -\frac{2}{1 + t} + C = -\frac{2}{1 + \tan \frac{x}{2}} + C<br>$$</p><hr><h3 id="八、配对积分法">八、配对积分法</h3><p>利用对称性或配对技巧简化积分</p><p><strong>例9</strong><br>$$<br>\int e^x \sin x , dx<br>$$<br><strong>解</strong>：<br>设 $I = \int e^x \sin x , dx$，对 $I$ 两次分部积分后解方程：<br>$$<br>I = \frac{e^x (\sin x - \cos x)}{2} + C<br>$$</p><hr><h3 id="九、积分表与递推公式">九、积分表与递推公式</h3><p>对复杂积分查表或使用递推公式</p><p><strong>例10</strong><br>$$<br>\int \sin^n x , dx<br>$$<br><strong>解</strong>：<br>利用递推公式：<br>$$<br>\int \sin^n x , dx = -\frac{\sin^{n-1} x \cos x}{n} + \frac{n - 1}{n} \int \sin^{n-2} x , dx<br>$$</p><hr><h3 id="十、数值积分与特殊函数">十、数值积分与特殊函数</h3><p>对无法用初等函数表达的积分，使用特殊函数（如误差函数、椭圆积分）</p><p><strong>例11</strong><br>$$<br>\int e^{-x^2} , dx = \frac{\sqrt{\pi}}{2} \text{erf}(x) + C<br>$$</p><hr><h3 id="总结表格">总结表格</h3><table><thead><tr><th>方法</th><th>适用场景</th><th>关键步骤</th></tr></thead><tbody><tr><td>基本积分公式</td><td>简单幂函数、三角函数等</td><td>直接应用公式</td></tr><tr><td>线性换元法</td><td>复合函数积分</td><td>凑微分，变量替换</td></tr><tr><td>分部积分法</td><td>乘积型积分（如 $x e^x$）</td><td>选择 $u$ 和 $dv$</td></tr><tr><td>三角换元法</td><td>含根式 $\sqrt{a^2 \pm x^2}$</td><td>三角代换消去根号</td></tr><tr><td>有理函数积分</td><td>分式多项式</td><td>部分分式分解</td></tr><tr><td>倒代换</td><td>分母次数高</td><td>令 $t = \frac{1}{x}$</td></tr><tr><td>万能三角代换</td><td>三角有理式积分</td><td>$t = \tan \frac{x}{2}$</td></tr><tr><td>配对积分法</td><td>对称性或循环结构</td><td>建立方程求解</td></tr><tr><td>递推公式</td><td>高次幂积分（如 $\sin^n x$）</td><td>逐步降幂</td></tr><tr><td>特殊函数</td><td>非初等积分（如 $e^{-x^2}$）</td><td>引入误差函数、椭圆积分等</td></tr></tbody></table><p>掌握这些方法后，可灵活组合使用以解决复杂积分问题</p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构十五天复习计划</title>
    <link href="/2025/03/29/kaoyan/guihua/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%BA%94%E5%A4%A9%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <url>/2025/03/29/kaoyan/guihua/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%BA%94%E5%A4%A9%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>以下是针对数据结构所有核心章节的重新规划方案，时间范围仍为<strong>3月29日-4月12日（共15天）</strong>，覆盖考研要求的全部重点内容并融入实战训练。每日学习模块与时间分配高度适配您原有的任务卡框架。</p><hr><h3 id="📅-数据结构全章15天攻坚计划"><strong>📅 数据结构全章15天攻坚计划</strong></h3><p><strong>总策略：</strong><br><strong>▷ 理论+代码+错题三合一</strong> | <strong>▷ 每日2.5小时集中突破</strong> | <strong>▷ 周末专题熔断补强</strong></p><hr><h4 id="🔰-章节分布与时间轴"><strong>🔰 章节分布与时间轴</strong></h4><table><thead><tr><th>日期</th><th>核心章节</th><th>关联实战目标（代码+题型）</th><th>高危考点标注</th></tr></thead><tbody><tr><td><strong>3.29</strong></td><td>线性表（顺序表/链表）</td><td>链表逆置（递归/非递归）</td><td>❗头结点与首元节点混淆</td></tr><tr><td><strong>3.30</strong></td><td>栈与队列</td><td>双栈模拟队列，循环队列判满方案</td><td>❗出队后front指向的语义差异</td></tr><tr><td><strong>3.31</strong></td><td>字符串与KMP算法</td><td>手写Next数组生成代码</td><td>❗部分匹配值的计算误差</td></tr><tr><td><strong>4.1</strong></td><td>树基础（二叉树性质）</td><td>利用完全二叉树性质解应用题</td><td>❗非满二叉树节点数公式误用</td></tr><tr><td><strong>4.2</strong></td><td>二叉树遍历</td><td>非递归后序遍历（双栈法）</td><td>❗处理右子树时的栈操作顺序</td></tr><tr><td><strong>4.3</strong></td><td>平衡二叉树（AVL）</td><td>四种旋转类型代码默写</td><td>❗平衡因子更新滞后导致失衡</td></tr><tr><td><strong>4.4</strong></td><td>堆与优先队列</td><td>堆排序的原地实现</td><td>❗建堆时下滤操作的起点选择</td></tr><tr><td><strong>4.5</strong></td><td>图存储（邻接矩阵/表）</td><td>邻接表转逆邻接表算法</td><td>❗顶点索引从0/1开始的一致性</td></tr><tr><td><strong>4.6</strong></td><td>图遍历（DFS/BFS）</td><td>检测图中是否存在环（DFS染色法）</td><td>❗回溯时颜色标记未重置</td></tr><tr><td><strong>4.7</strong></td><td>最短路径（Dijkstra）</td><td>路径还原（pre数组回溯）</td><td>❗负权边导致的算法失效</td></tr><tr><td><strong>4.8</strong></td><td>最小生成树（Prim/Kruskal）</td><td>并查集实现Kruskal</td><td>❗边排序时权重相同处理顺序</td></tr><tr><td><strong>4.9</strong></td><td>查找（BST/AVL/B树）</td><td>B树插入分裂的手动模拟</td><td>❗节点关键字数超过阶数-1</td></tr><tr><td><strong>4.10</strong></td><td>散列表（哈希冲突）</td><td>不同探测法的ASL计算</td><td>❗二次探测的探查序列生成错误</td></tr><tr><td><strong>4.11</strong></td><td>排序（快排/归并）</td><td>链式存储的归并排序实现</td><td>❗哨兵结点在链表排序中的使用</td></tr><tr><td><strong>4.12</strong></td><td>综合复盘</td><td>近3年真题高频错题重做（标注错误类型）</td><td>❗时间分配与策略优化</td></tr></tbody></table><hr><h4 id="⚡-每日学习闭环设计"><strong>⚡ 每日学习闭环设计</strong></h4><p><strong>14:00-15:00</strong></p><ul><li><strong>理论精讲</strong>：结合教材与思维导图速记核心公式（如二叉树高度公式 $h = \lfloor \log_2 n \rfloor + 1$）</li><li><strong>动画解析</strong>：观看关键算法动态演示（如AVL树旋转、Dijkstra松弛过程）</li></ul><p><strong>15:00-16:00</strong></p><ul><li><strong>代码手撕</strong>：完成当日代码目标（如双栈模拟队列需控制时间复杂度≤O(1)均摊）</li><li><strong>LeetCode补强</strong>：精选1道对应章节高频题（例：用KMP解决<a href="https://leetcode.com/problems/implement-strstr/">28. 实现 strStr()</a>）</li></ul><p><strong>21:30-22:00</strong></p><ul><li><strong>错题熔断</strong>：针对当日练习暴露的弱点，使用「5分钟快解模板」强化（如哈希表冲突处理速记表）</li></ul><hr><h4 id="📌-重点章节特训方案"><strong>📌 重点章节特训方案</strong></h4><ol><li><p><strong>树与图的双向打通</strong>（4.1-4.7）</p><ul><li>树的应用：将二叉树遍历模板迁移至图的DFS（递归栈帧 ⇌ 显式栈）</li><li>图的特性：通过树的层次遍历理解BFS的层序思想</li></ul></li><li><p><strong>查找与排序的联合训练</strong>（4.9-4.11）</p><ul><li>对比BST中序有序性与排序算法的稳定性</li><li>用哈希表优化排序（如桶排序的散列函数设计）</li></ul></li></ol><hr><h4 id="📊-动态难度调控表"><strong>📊 动态难度调控表</strong></h4><table><thead><tr><th>学习状态</th><th>调整策略</th><th>工具推荐</th></tr></thead><tbody><tr><td>单日代码通过率＜50%</td><td>降级训练：改用伪代码→注释→填空三步法</td><td>《算法笔记》题型分类</td></tr><tr><td>概念题连续错误</td><td>使用「费曼技巧」自述流程并录音纠错</td><td>Anki记忆卡（含易错点）</td></tr><tr><td>时间严重超支</td><td>启动「20分钟暴力破解法」限时训练</td><td>番茄钟强制分段</td></tr></tbody></table><hr><h4 id="📦-配套资源包"><strong>📦 配套资源包</strong></h4><ol><li><p><strong>代码模板速查手册</strong>（部分示例）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 非递归先序遍历（标记法）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrder</span><span class="hljs-params">(TreeNode* root)</span> &#123;<br>    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span> (root) st.push(root);<br>    <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>        TreeNode* node = st.top(); st.pop();<br>        <span class="hljs-keyword">if</span> (node) &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.push(node-&gt;right);  <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.push(node-&gt;left);    <span class="hljs-comment">// 左</span><br>            st.push(node);                          <span class="hljs-comment">// 中</span><br>            st.push(nullptr);                       <span class="hljs-comment">// 标记</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node = st.top(); st.pop();<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, node-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>易错点红宝书</strong>（节选）：</p><ul><li>链式前向星存图时，边的插入顺序影响遍历结果（需逆序插入）</li><li>堆排序中，下标从0开始和从1开始的父子节点计算公式不同</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>复习规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>408复习-数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学和408复习计划</title>
    <link href="/2025/03/29/kaoyan/guihua/%E6%95%B0%E5%AD%A6%E5%92%8C408%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <url>/2025/03/29/kaoyan/guihua/%E6%95%B0%E5%AD%A6%E5%92%8C408%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="总体复习框架"><strong>总体复习框架</strong></h2><p>根据你的需求，我将按照以下框架为你制定3.29-4.12的冲刺计划（共15天），重点针对高数刷题和数据结构复习，采用模块化+渐进式训练模式：</p><hr><h3 id="一、每日时间框架（建议模板）"><strong>一、每日时间框架（建议模板）</strong></h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">8</span>:<span class="hljs-number">00</span>-<span class="hljs-number">8</span>:<span class="hljs-number">30</span> 晨间记忆（英语核心词汇<span class="hljs-number">200</span>个+数学公式默写）<br><span class="hljs-attribute">8</span>:<span class="hljs-number">30</span>-<span class="hljs-number">10</span>:<span class="hljs-number">30</span> 高数专题突破（番茄钟*<span class="hljs-number">3</span>，每<span class="hljs-number">50</span>分钟+<span class="hljs-number">10</span>分钟错题整理）<br><span class="hljs-attribute">10</span>:<span class="hljs-number">30</span>-<span class="hljs-number">12</span>:<span class="hljs-number">00</span> 上课时间（执行高数刷题任务）<br><span class="hljs-attribute">14</span>:<span class="hljs-number">00</span>-<span class="hljs-number">16</span>:<span class="hljs-number">00</span> 数据结构专项训练（含代码手写+算法推导）<br><span class="hljs-attribute">16</span>:<span class="hljs-number">30</span>-<span class="hljs-number">18</span>:<span class="hljs-number">00</span> 专业课<span class="hljs-number">1</span>/<span class="hljs-number">2</span>交叉学习（保持<span class="hljs-number">408</span>整体节奏）<br><span class="hljs-attribute">19</span>:<span class="hljs-number">30</span>-<span class="hljs-number">21</span>:<span class="hljs-number">30</span> 综合任务（当日错题复盘+英语阅读训练）<br><span class="hljs-attribute">21</span>:<span class="hljs-number">30</span>-<span class="hljs-number">22</span>:<span class="hljs-number">30</span> 机动时间（补漏/提前完成奖励休息）<br></code></pre></td></tr></table></figure><p><em>注：上课时间直接使用《李林880题》或《张宇1000题》按章节刷题</em></p><hr><h3 id="二、高等数学刷题执行方案（3-29-4-12）"><strong>二、高等数学刷题执行方案（3.29-4.12）</strong></h3><p><strong>核心目标：完成核心题型地毯式排查</strong></p><table><thead><tr><th>日期区间</th><th>重点章节</th><th>每日题量</th><th>核心训练点</th><th>工具建议</th></tr></thead><tbody><tr><td>3.29-4.1</td><td>多元函数微分法</td><td>18题/天</td><td>条件极值、隐函数求导链式法则</td><td>错题本分色标记系统</td></tr><tr><td>4.2-4.4</td><td>重积分应用</td><td>20题/天</td><td>坐标系转换技巧、物理应用题</td><td>Geogebra动态验证</td></tr><tr><td>4.5-4.7</td><td>微分方程</td><td>15题/天</td><td>高阶线性方程构造解的结构分析</td><td>题型分类速查表</td></tr><tr><td>4.8-4.10</td><td>级数专题</td><td>12题/天</td><td>幂级数求和函数收敛半径速判</td><td>思维导图串联定理</td></tr><tr><td>4.11-4.12</td><td>综合模拟</td><td>3套真题</td><td>时间控制（≤2.5小时/套）</td><td>仿真答题卡</td></tr></tbody></table><ul><li>每日附加任务：睡前用A4纸默写当日重点题型的解题框架（如曲面积分五步法）</li><li>周末强化：周六上午进行全真模考，周日下午进行错题手术刀式剖析</li></ul><hr><h3 id="三、数据结构攻坚计划（3-29-4-12）"><strong>三、数据结构攻坚计划（3.29-4.12）</strong></h3><p><strong>核心策略：算法实现+复杂度分析的二元训练法</strong></p><table><thead><tr><th>周期</th><th>核心战场</th><th>每日任务分解</th><th>能力强化重点</th></tr></thead><tbody><tr><td>3.29-4.2</td><td>树与二叉树</td><td>1. 非递归遍历代码手写（早）<br>2. 平衡树调整实操（晚）</td><td>指针操作防错训练</td></tr><tr><td>4.3-4.5</td><td>图论算法</td><td>1. Dijkstra/Floyd对比实现<br>2. 拓扑排序变式训练</td><td>临界条件压力测试</td></tr><tr><td>4.6-4.8</td><td>查找排序</td><td>1. B+树插入删除全流程动画推演<br>2. 外部排序败者树</td><td>磁盘IO模拟计算</td></tr><tr><td>4.9-4.11</td><td>动态存储管理</td><td>1. 伙伴系统分配回收实操<br>2. 内存碎片化数学建模</td><td>边界案例暴力枚举</td></tr><tr><td>4.12</td><td>压轴冲刺</td><td>2019-2023真题算法题限时重做</td><td>伪代码到标准C的转换规范</td></tr></tbody></table><ul><li>每日标配：LeetCode精选（3道）+ 王道课后思考题（2道）</li><li>凌晨闪存：睡前用费曼技巧口述当日算法核心逻辑（手机录音自查）</li></ul><hr><h3 id="四、关键控制点"><strong>四、关键控制点</strong></h3><ol><li><strong>错题熔断机制</strong>：同一知识点连续3次出错立即启动专项特训（如晚间的21:30-22:30时段）</li><li><strong>进度看板管理</strong>：推荐使用Notion建立双周冲刺看板，每日22:00更新完成度雷达图</li><li><strong>生理节律适配</strong>：将数学证明类任务安排在脑力黄金时段（上午8-10点），算法编码放在午后（14-16点）</li></ol><hr><h3 id="五、紧急情况预案"><strong>五、紧急情况预案</strong></h3><ul><li>若某日进度延误≥30%，次日启动「6-3-1急救模式」：60%时间补漏+30%当前进度+10%缓冲</li><li>遇到知识盲区时，立即使用「3步止血法」：①看教材定理 ②观名师精讲（3b1b/王道）③做靶向练习</li></ul><p>建议每天早晨用5分钟浏览当日任务地图，晚间用10分钟进行PDCA循环检查</p><h2 id="细节规划"><strong>细节规划</strong></h2><p>以下是针对高等数学和数据结构的具体章节知识点对照表及每日执行细节，结合你的截止日期（4月12日）进行精准拆分：</p><hr><h3 id="一、高等数学刷题章节知识点对照表（3-29-4-12）"><strong>一、高等数学刷题章节知识点对照表（3.29-4.12）</strong></h3><h4 id="1-多元函数微分法（3-29-4-1）"><strong>1. 多元函数微分法（3.29-4.1）</strong></h4><ul><li><strong>核心题型</strong>：<ul><li>隐函数求导（方程组情形）</li><li>条件极值（拉格朗日乘数法构造技巧）</li><li>方向导数与梯度几何意义应用题</li></ul></li><li><strong>必刷题源</strong>：<br>《李林880题》基础篇：P78-82 题号3,7,11,15,19<br>《张宇1000题》B组：题号23,26,31（链式法则陷阱题）</li><li><strong>防错重点</strong>：<br>使用「变量关系图」避免链式法则漏导</li></ul><h4 id="2-重积分应用（4-2-4-4）"><strong>2. 重积分应用（4.2-4.4）</strong></h4><ul><li><strong>核心题型</strong>：<ul><li>极坐标系下积分限快速定界（θ-r扫描法）</li><li>物理应用题（质心/转动惯量的积分建模）</li><li>二重积分分段处理（绝对值/分段函数情形）</li></ul></li><li><strong>必刷题源</strong>：<br>《李林880题》提高篇：P102-105 题号8,12,17（旋转体惯量）<br>《真题大全解》2016年卷三第18题（坐标系切换）</li><li><strong>工具强化</strong>：<br>用GeoGebra动态验证积分区域</li></ul><h4 id="3-微分方程（4-5-4-7）"><strong>3. 微分方程（4.5-4.7）</strong></h4><ul><li><strong>核心题型</strong>：<ul><li>高阶线性方程特解构造（多项式叠加判定）</li><li>欧拉方程变量代换通解</li><li>微分方程与几何应用结合题（切线/法线建方程）</li></ul></li><li><strong>必刷题源</strong>：<br>《张宇1000题》C组：题号44,47（物理背景应用题）<br>教材课后题：同济七版第7章总复习题12,15（变量替换难点）</li><li><strong>速记技巧</strong>：<br>制作「微分方程类型判定流程图」贴于书桌</li></ul><h4 id="4-级数专题（4-8-4-10）"><strong>4. 级数专题（4.8-4.10）</strong></h4><ul><li><strong>核心题型</strong>：<ul><li>幂级数求和函数（逐项积分/微分法）</li><li>傅里叶级数收敛定理应用</li><li>正项级数审敛法综合判断（比较法+根值法联用）</li></ul></li><li><strong>必刷题源</strong>：<br>《李林880题》综合篇：P189-192 题号9,14,20（阿贝尔定理陷阱题）<br>2019年真题：数一第19题（级数与微分方程综合题）</li><li><strong>突破技巧</strong>：<br>对收敛域端点单独建立判断案例库</li></ul><h4 id="5-综合模拟（4-11-4-12）"><strong>5. 综合模拟（4.11-4.12）</strong></h4><ul><li><strong>建议套卷</strong>：<br>2022年真题（严格计时）+ 李林6套卷（选填专项）</li><li><strong>复盘重点</strong>：<br>大题步骤分对照（使用《真题评分细则》自查）</li></ul><hr><h3 id="二、数据结构每日执行细节（3-29-4-12）"><strong>二、数据结构每日执行细节（3.29-4.12）</strong></h3><h4 id="1-树与二叉树（3-29-4-2）"><strong>1. 树与二叉树（3.29-4.2）</strong></h4><ul><li><strong>代码实操清单</strong>：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> Day1：非递归先序遍历（栈实现）+ 计算二叉树宽度<br><span class="hljs-bullet">-</span> Day2：线索二叉树构造（中序）+ 平衡树LL/RR旋转<br><span class="hljs-bullet">-</span> Day3：哈夫曼编码生成（优先队列实现）+ 树形DP求最大路径和<br><span class="hljs-bullet">-</span> Day4：红黑树插入全案例推演（至少3种冲突场景）<br></code></pre></td></tr></table></figure></li><li><strong>复杂度专项</strong>：<ul><li>推导平衡树删除操作的均摊时间复杂度</li><li>对比B树与B+树在磁盘访问次数上的差异</li></ul></li></ul><h4 id="2-图论算法（4-3-4-5）"><strong>2. 图论算法（4.3-4.5）</strong></h4><ul><li><strong>手写代码重点</strong>：<ul><li>邻接表存储的DFS非递归实现</li><li>Floyd算法动态规划迭代过程（矩阵逐步更新）</li><li>关键路径算法中的事件最早/最晚时间计算</li></ul></li><li><strong>应用题强化</strong>：<ul><li>动态规划与Dijkstra在最短路径中的适用场景对比</li><li>拓扑排序检测环的两种实现（DFS入度法）</li></ul></li></ul><h4 id="3-查找排序（4-6-4-8）"><strong>3. 查找排序（4.6-4.8）</strong></h4><ul><li><strong>手撕代码重点</strong>：<ul><li>三路划分快速排序（处理重复元素）</li><li>B+树插入分裂过程（模拟5阶B+树连续插入1-100）</li><li>败者树多路归并（手动模拟8个归并段场景）</li></ul></li><li><strong>冷门考点</strong>：<ul><li>分析希尔排序不同增量序列的优劣（Hibbard vs Sedgewick）</li><li>散列表二次聚集现象数学证明</li></ul></li></ul><h4 id="4-动态存储管理（4-9-4-11）"><strong>4. 动态存储管理（4.9-4.11）</strong></h4><ul><li><strong>实操训练</strong>：<ul><li>伙伴系统分配请求序列模拟（如申请16K→8K→32K）</li><li>边界标识法合并空闲块的手动演示</li></ul></li><li><strong>计算题重点</strong>：<ul><li>最佳适配/最差适配算法碎片率计算</li><li>虚拟内存页面置换算法Belady现象复现</li></ul></li></ul><h4 id="5-压轴冲刺（4-12）"><strong>5. 压轴冲刺（4.12）</strong></h4><ul><li><strong>真题精选</strong>：<ul><li>2021年真题：矩阵快速转置（三元组存储）</li><li>2023年真题：Kruskal算法+并查集优化</li></ul></li><li><strong>考场避坑</strong>：<ul><li>严格区分<code>next数组</code>的两种生成版本（严蔚敏 vs 王道）</li></ul></li></ul><hr><h3 id="三、执行监控工具包"><strong>三、执行监控工具包</strong></h3><ol><li><strong>高数刷题追踪表</strong>：<table><thead><tr><th>日期</th><th>完成题号</th><th>单题耗时</th><th>错误类型（A计算/B概念/C技巧）</th><th>熔断标记</th></tr></thead><tbody><tr><td>3.29</td><td>880-3,7</td><td>15min</td><td>B（链式法则漏变量）</td><td>已启动</td></tr></tbody></table></li><li><strong>数据结构代码自查清单</strong>：<ul><li>[ ] 指针修改前备份原始值（防断链）</li><li>[ ] 递归函数出口条件覆盖所有边界</li><li>[ ] 复杂度计算包含递归栈空间</li></ul></li><li><strong>缓冲时间分配建议</strong>：<ul><li>每周日晚预留2小时作为「错题急诊室」</li><li>每完成一个章节奖励30分钟「自由探索时间」（如看3Blue1Brown视频）</li></ul></li></ol><p>需要我为你生成可打印的PDF版本任务卡吗？或是调整某些模块的强度？</p>]]></content>
    
    
    <categories>
      
      <category>复习规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
      <tag>408复习-数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平方和求和公式</title>
    <link href="/2025/03/27/kaoyan/shuxue/%E5%B9%B3%E6%96%B9%E5%92%8C%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/"/>
    <url>/2025/03/27/kaoyan/shuxue/%E5%B9%B3%E6%96%B9%E5%92%8C%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>平方求和公式是指计算从 $1^2$ 到 $n^2$ 的和，即：</p><p>$$<br>S = 1^2 + 2^2 + 3^2 + \dots + n^2<br>$$</p><p>其结果为：</p><p>$$<br>S = \frac{n(n+1)(2n+1)}{6}<br>$$</p><hr><h3 id="推导过程（利用立方差公式）"><strong>推导过程（利用立方差公式）</strong></h3><ol><li><p><strong>写出立方差关系</strong>：<br>注意到 $(k+1)^3 - k^3 = 3k^2 + 3k + 1$，对 $k = 1$ 到 $n$ 依次展开：</p><!-- $$\begin{align*}2^3 - 1^3 &= 3 \cdot 1^2 + 3 \cdot 1 + 1 \\3^3 - 2^3 &= 3 \cdot 2^2 + 3 \cdot 2 + 1 \\&\vdots \\(n+1)^3 - n^3 &= 3 \cdot n^2 + 3 \cdot n + 1\end{align*}$$--></li></ol>    $$  \begin{align*}  2^3 - 1^3 &= 3 \cdot 1^2 + 3 \cdot 1 + 1 \\  3^3 - 2^3 &= 3 \cdot 2^2 + 3 \cdot 2 + 1 \\  &\vdots \\  (n+1)^3 - n^3 &= 3 \cdot n^2 + 3 \cdot n + 1  \end{align*}  $$  <ol start="2"><li><p><strong>累加所有等式</strong>：<br>将上述 $n$ 个等式相加，左边大部分项抵消，得到：</p><p>$$<br>(n+1)^3 - 1^3 = 3 \sum_{k=1}^n k^2 + 3 \sum_{k=1}^n k + \sum_{k=1}^n 1<br>$$</p></li><li><p><strong>代入已知求和公式</strong>：<br>已知：<br>$$<br>\sum_{k=1}^n k = \frac{n(n+1)}{2}, \quad \sum_{k=1}^n 1 = n<br>$$<br>代入后：<br>$$<br>n^3 + 3n^2 + 3n = 3S + \frac{3n(n+1)}{2} + n<br>$$</p></li><li><p><strong>解方程求 $S$</strong>：<br>整理方程：<br>$$<br>3S = n^3 + 3n^2 + 3n - \frac{3n(n+1)}{2} - n<br>$$<br>化简后得到：<br>$$<br>S = \frac{n(n+1)(2n+1)}{6}<br>$$</p></li></ol><hr><h3 id="验证公式（数学归纳法）"><strong>验证公式（数学归纳法）</strong></h3><ol><li><p><strong>基例（$n=1$）</strong>：<br>$$<br>S = 1^2 = 1, \quad \frac{1 \cdot 2 \cdot 3}{6} = 1 \quad \text{成立}.<br>$$</p></li><li><p><strong>归纳假设</strong>：<br>假设公式对 $n = k$ 成立，即：<br>$$<br>1^2 + 2^2 + \dots + k^2 = \frac{k(k+1)(2k+1)}{6}<br>$$</p></li><li><p><strong>证明对 $n = k+1$ 成立</strong>：<br>计算：<br>$$<br>S_{k+1} = S_k + (k+1)^2 = \frac{k(k+1)(2k+1)}{6} + (k+1)^2<br>$$<br>化简后：<br>$$<br>S_{k+1} = \frac{(k+1)(k+2)(2k+3)}{6}<br>$$<br>符合公式，得证。</p></li></ol><hr><h3 id="示例计算"><strong>示例计算</strong></h3><ul><li><strong>当 $n=3$ 时</strong>：<br>$$<br>1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14, \quad \frac{3 \cdot 4 \cdot 7}{6} = 14<br>$$</li><li><strong>当 $n=5$ 时</strong>：<br>$$<br>1^2 + 2^2 + \dots + 5^2 = 55, \quad \frac{5 \cdot 6 \cdot 11}{6} = 55<br>$$</li></ul><hr><h3 id="应用场景"><strong>应用场景</strong></h3><ul><li><strong>概率统计</strong>：计算离散数据的方差。</li><li><strong>物理与工程</strong>：分析能量分布或惯性矩。</li><li><strong>算法分析</strong>：评估时间复杂度（如嵌套循环）。</li></ul><hr><p><strong>总结</strong>：平方和公式是基础数学工具，掌握其推导与验证方法，可灵活应用于科学计算与实际问题。</p><hr><p>✅ 验证报告：</p><ul><li>已转化行内公式：6处</li><li>已调整独立公式：12处</li><li>内容变更检测：0处非公式修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二重积分或几何中特殊曲线总结</title>
    <link href="/2025/03/27/kaoyan/shuxue/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E6%88%96%E5%87%A0%E4%BD%95%E4%B8%AD%E7%89%B9%E6%AE%8A%E6%9B%B2%E7%BA%BF%E6%80%BB%E7%BB%93/"/>
    <url>/2025/03/27/kaoyan/shuxue/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E6%88%96%E5%87%A0%E4%BD%95%E4%B8%AD%E7%89%B9%E6%AE%8A%E6%9B%B2%E7%BA%BF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>以下是高等数学中常见的特殊曲线总结，包含名称、方程、图像特征及典型应用：</p><hr><h1><strong>总结</strong></h1><h3 id="1-星形线（Astroid）"><strong>1. 星形线（Astroid）</strong></h3><ul><li><strong>方程</strong>：<ul><li>直角坐标：$x^{2/3} + y^{2/3} = a^{2/3}$</li><li>参数方程：$x = a\cos^3\theta$, $y = a\sin^3\theta$</li></ul></li><li><strong>图像</strong>：四尖点对称，形似四角星。</li><li><strong>应用</strong>：内摆线特例（小圆半径为大圆的1/4），积分对称性示例。</li></ul><hr><h3 id="2-心脏线（Cardioid）"><strong>2. 心脏线（Cardioid）</strong></h3><ul><li><strong>方程</strong>：<ul><li>极坐标：$r = a(1 + \cos\theta)$</li><li>参数方程：$x = a(2\cos\theta - \cos2\theta)$, $y = a(2\sin\theta - \sin2\theta)$</li></ul></li><li><strong>图像</strong>：心形，单尖点。</li><li><strong>应用</strong>：蜗线的一种，声学与光学中的焦散曲线。</li></ul><hr><h3 id="3-笛卡尔叶形线（Folium-of-Descartes）"><strong>3. 笛卡尔叶形线（Folium of Descartes）</strong></h3><ul><li><strong>方程</strong>：<ul><li>直角坐标：$x^3 + y^3 = 3axy$</li><li>参数方程：$x = \frac{3at}{1 + t^3}$, $y = \frac{3at^2}{1 + t^3}$</li></ul></li><li><strong>图像</strong>：单叶通过原点，渐近线为$x + y + a = 0$。</li><li><strong>应用</strong>：参数方程与极限分析范例。</li></ul><hr><h3 id="4-双纽线（Lemniscate）"><strong>4. 双纽线（Lemniscate）</strong></h3><ul><li><strong>方程</strong>：<ul><li>伯努利双纽线：$(x^2 + y^2)^2 = a^2(x^2 - y^2)$</li><li>极坐标：$r^2 = a^2\cos2\theta$</li></ul></li><li><strong>图像</strong>：横置的“∞”形，两焦点对称。</li><li><strong>应用</strong>：复数平面上模数的几何表示。</li></ul><hr><h3 id="5-摆线（Cycloid）"><strong>5. 摆线（Cycloid）</strong></h3><ul><li><strong>方程</strong>：<ul><li>参数方程：<br>$$<br>x = a(\theta - \sin\theta), \quad y = a(1 - \cos\theta)<br>$$</li></ul></li><li><strong>图像</strong>：周期性拱形，无端点。</li><li><strong>应用</strong>：最速降线问题，力学中的等时曲线。</li></ul><hr><h3 id="6-外摆线（Epicycloid）与内摆线（Hypocycloid）"><strong>6. 外摆线（Epicycloid）与内摆线（Hypocycloid）</strong></h3><ul><li><strong>方程</strong>（外摆线为例）：<ul><li>参数方程：<br>$$<br>x = (R + r)\cos\theta - r\cos\left(\frac{R + r}{r}\theta\right), \quad y = (R + r)\sin\theta - r\sin\left(\frac{R + r}{r}\theta\right)<br>$$</li></ul></li><li><strong>特例</strong>：<ul><li><strong>星形线</strong>：内摆线（$R = 4r$）。</li><li><strong>心脏线</strong>：外摆线（$R = r$）。</li></ul></li><li><strong>应用</strong>：齿轮齿形设计，几何变换案例。</li></ul><hr><h3 id="7-阿基米德螺线（Archimedean-Spiral）"><strong>7. 阿基米德螺线（Archimedean Spiral）</strong></h3><ul><li><strong>方程</strong>：<ul><li>极坐标：$r = a\theta$</li></ul></li><li><strong>图像</strong>：每圈间距相等的螺旋线。</li><li><strong>应用</strong>：机械凸轮设计，极坐标积分示例。</li></ul><hr><h3 id="8-对数螺线（Logarithmic-Spiral）"><strong>8. 对数螺线（Logarithmic Spiral）</strong></h3><ul><li><strong>方程</strong>：<ul><li>极坐标：$r = ae^{b\theta}$</li></ul></li><li><strong>图像</strong>：间距随角度指数增长的螺旋线。</li><li><strong>应用</strong>：自然界中的生长模式（如鹦鹉螺壳）。</li></ul><hr><h3 id="9-悬链线（Catenary）"><strong>9. 悬链线（Catenary）</strong></h3><ul><li><strong>方程</strong>：<ul><li>直角坐标：$y = a\cosh\left(\frac{x}{a}\right)$</li></ul></li><li><strong>图像</strong>：两端下垂的曲线，与抛物线不同。</li><li><strong>应用</strong>：桥梁与拱门设计，最小势能问题。</li></ul><hr><h3 id="10-玫瑰线（Rose-Curve）"><strong>10. 玫瑰线（Rose Curve）</strong></h3><ul><li><strong>方程</strong>：<ul><li>极坐标：$r = a\cos(k\theta)$ 或 $r = a\sin(k\theta)$</li></ul></li><li><strong>类型</strong>：<ul><li><strong>三叶玫瑰线</strong>（$k = 3$）：三瓣对称。</li><li><strong>四叶玫瑰线</strong>（$k = 2$）：四瓣对称。</li></ul></li><li><strong>应用</strong>：极坐标绘图与对称性分析。</li></ul><hr><h3 id="11-箕舌线（Witch-of-Agnesi）"><strong>11. 箕舌线（Witch of Agnesi）</strong></h3><ul><li><strong>方程</strong>：<ul><li>直角坐标：$y = \frac{8a^3}{x^2 + 4a^2}$</li></ul></li><li><strong>图像</strong>：钟形曲线，渐近线为$y = 0$。</li><li><strong>应用</strong>：概率密度函数的历史原型。</li></ul><hr><h3 id="12-蚌线（Conchoid）"><strong>12. 蚌线（Conchoid）</strong></h3><ul><li><strong>方程</strong>（以尼科米德蚌线为例）：<ul><li>极坐标：$r = a + b\sec\theta$</li></ul></li><li><strong>图像</strong>：依据参数不同，可能为闭合或分支曲线。</li><li><strong>应用</strong>：经典几何问题（三等分角）。</li></ul><hr><h3 id="13-双曲线（Hyperbola）与椭圆（Ellipse）"><strong>13. 双曲线（Hyperbola）与椭圆（Ellipse）</strong></h3><ul><li><strong>双曲线</strong>：<ul><li>方程：$\frac{x^2}{a^2} - \frac{y^2}{b^2} = 1$</li><li>应用：天体轨道（开放路径）、渐近行为分析。</li></ul></li><li><strong>椭圆</strong>：<ul><li>方程：$\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1$</li><li>应用：行星轨道、几何变换。</li></ul></li></ul><hr><h3 id="14-抛物线（Parabola）"><strong>14. 抛物线（Parabola）</strong></h3><ul><li><strong>方程</strong>：$y^2 = 4ax$</li><li><strong>应用</strong>：抛体运动轨迹、光学反射性质。</li></ul><hr><h3 id="15-马鞍面曲线（双曲抛物面截线）"><strong>15. 马鞍面曲线（双曲抛物面截线）</strong></h3><ul><li><strong>方程</strong>：$z = xy$ 或 $x^2 - y^2 = z$</li><li><strong>图像</strong>：鞍形，沿不同方向开口相反。</li><li><strong>应用</strong>：鞍点分析、多变量函数极值示例。</li></ul><hr><h3 id="总结表"><strong>总结表</strong></h3><table><thead><tr><th><strong>曲线名称</strong></th><th><strong>典型方程</strong></th><th><strong>图像特征</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td>星形线</td><td>$x^{2/3} + y^{2/3} = a^{2/3}$</td><td>四尖点对称</td><td>积分对称性分析</td></tr><tr><td>心脏线</td><td>$r = a(1 + \cos\theta)$</td><td>心形单尖点</td><td>蜗线运动、焦散现象</td></tr><tr><td>笛卡尔叶形线</td><td>$x^3 + y^3 = 3axy$</td><td>单叶过原点</td><td>参数方程范例</td></tr><tr><td>双纽线</td><td>$(x^2 + y^2)^2 = a^2(x^2 - y^2)$</td><td>横置“∞”形</td><td>复数几何、对称积分</td></tr><tr><td>摆线</td><td>$x = a(\theta - \sin\theta)$</td><td>周期性拱形</td><td>最速降线、力学问题</td></tr><tr><td>阿基米德螺线</td><td>$r = a\theta$</td><td>等间距螺旋</td><td>极坐标积分、机械设计</td></tr><tr><td>悬链线</td><td>$y = a\cosh(x/a)$</td><td>下垂曲线</td><td>桥梁设计、最小势能</td></tr><tr><td>玫瑰线</td><td>$r = a\cos(k\theta)$</td><td>多瓣对称</td><td>极坐标绘图</td></tr><tr><td>双曲抛物面截线</td><td>$z = xy$</td><td>马鞍形</td><td>多变量极值、鞍点分析</td></tr></tbody></table><hr><p><strong>注</strong>：以上曲线在高等数学中常用于演示参数方程、极坐标、对称性积分、几何变换等概念，实际应用中需结合具体场景选择合适模型。</p><hr><h1><strong>参数方程形式</strong></h1><h3 id="高等数学特殊曲线总结表"><strong>高等数学特殊曲线总结表</strong></h3><table><thead><tr><th><strong>曲线名称</strong></th><th><strong>典型方程</strong></th><th><strong>参数方程形式</strong></th><th><strong>图像特征</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>1. 星形线</strong></td><td>$x^{2/3} + y^{2/3} = a^{2/3}$</td><td>$x = a\cos^3\theta$, $y = a\sin^3\theta$</td><td>四尖点对称</td><td>积分对称性分析</td></tr><tr><td><strong>2. 心脏线</strong></td><td>$r = a(1 + \cos\theta)$</td><td>$x = a(2\cos\theta - \cos2\theta)$, $y = a(2\sin\theta - \sin2\theta)$</td><td>心形单尖点</td><td>蜗线运动、焦散现象</td></tr><tr><td><strong>3. 笛卡尔叶形线</strong></td><td>$x^3 + y^3 = 3axy$</td><td>$x = \frac{3at}{1 + t^3}$, $y = \frac{3at^2}{1 + t^3}$</td><td>单叶过原点</td><td>参数方程范例</td></tr><tr><td><strong>4. 双纽线</strong></td><td>$(x^2 + y^2)^2 = a^2(x^2 - y^2)$</td><td>$x = a\cos\theta\sqrt{\cos2\theta}$, $y = a\sin\theta\sqrt{\cos2\theta}$</td><td>横置“∞”形</td><td>复数几何、对称积分</td></tr><tr><td><strong>5. 摆线</strong></td><td>—</td><td>$x = a(\theta - \sin\theta)$, $y = a(1 - \cos\theta)$</td><td>周期性拱形</td><td>最速降线、力学问题</td></tr><tr><td><strong>6. 外摆线</strong></td><td>—</td><td>$x = (R + r)\cos\theta - r\cos\left(\frac{R + r}{r}\theta\right)$ <br> $y = (R + r)\sin\theta - r\sin\left(\frac{R + r}{r}\theta\right)$</td><td>外滚轮轨迹</td><td>齿轮设计、几何变换</td></tr><tr><td><strong>7. 内摆线</strong></td><td>—</td><td>$x = (R - r)\cos\theta + r\cos\left(\frac{R - r}{r}\theta\right)$ <br> $y = (R - r)\sin\theta - r\sin\left(\frac{R - r}{r}\theta\right)$</td><td>内滚轮轨迹</td><td>星形线特例（$R = 4r$）</td></tr><tr><td><strong>8. 阿基米德螺线</strong></td><td>$r = a\theta$</td><td>$x = a\theta\cos\theta$, $y = a\theta\sin\theta$</td><td>等间距螺旋</td><td>极坐标积分、机械设计</td></tr><tr><td><strong>9. 对数螺线</strong></td><td>$r = ae^{b\theta}$</td><td>$x = ae^{b\theta}\cos\theta$, $y = ae^{b\theta}\sin\theta$</td><td>指数增长螺旋</td><td>自然生长模型</td></tr><tr><td><strong>10. 悬链线</strong></td><td>$y = a\cosh\left(\frac{x}{a}\right)$</td><td>$x = t$, $y = a\cosh\left(\frac{t}{a}\right)$</td><td>下垂曲线</td><td>桥梁设计、最小势能</td></tr><tr><td><strong>11. 玫瑰线</strong></td><td>$r = a\cos(k\theta)$</td><td>$x = a\cos(k\theta)\cos\theta$, $y = a\cos(k\theta)\sin\theta$</td><td>多瓣对称</td><td>极坐标绘图</td></tr><tr><td><strong>12. 箕舌线</strong></td><td>$y = \frac{8a^3}{x^2 + 4a^2}$</td><td>$x = 2a\tan\theta$, $y = 2a\cos^2\theta$</td><td>钟形曲线</td><td>概率密度原型</td></tr><tr><td><strong>13. 蚌线</strong></td><td>$r = a + b\sec\theta$</td><td>$x = a + b\sec\theta$, $y = (a + b\sec\theta)\tan\theta$</td><td>分支或闭合曲线</td><td>经典几何问题</td></tr><tr><td><strong>14. 双曲线</strong></td><td>$\frac{x^2}{a^2} - \frac{y^2}{b^2} = 1$</td><td>$x = a\sec\theta$, $y = b\tan\theta$ <br> 或 $x = a\cosh t$, $y = b\sinh t$</td><td>双开口分支</td><td>天体轨道、渐近分析</td></tr><tr><td><strong>15. 椭圆</strong></td><td>$\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1$</td><td>$x = a\cos\theta$, $y = b\sin\theta$</td><td>闭合对称椭圆</td><td>行星轨道、几何变换</td></tr><tr><td><strong>16. 抛物线</strong></td><td>$y^2 = 4ax$</td><td>$x = at^2$, $y = 2at$</td><td>单开口对称曲线</td><td>抛体运动、光学反射</td></tr><tr><td><strong>17. 双曲抛物面截线</strong></td><td>$z = xy$</td><td>$x = t$, $y = s$, $z = ts$（三维参数） <br> 二维截线：$x = t$, $y = k/t$</td><td>马鞍形</td><td>多变量极值、鞍点分析</td></tr></tbody></table><hr><h3 id="关键说明"><strong>关键说明</strong></h3><ol><li><strong>参数方程变量</strong>：表中统一使用 $\theta$ 或 $t$ 作为参数，具体意义根据曲线类型调整。</li><li><strong>三维曲线处理</strong>：双曲抛物面截线（马鞍面）需三维参数方程，但常用二维截线简化分析。</li><li><strong>极坐标转换</strong>：部分曲线的参数方程通过极坐标方程直接转换而来（如 $r = a\theta$ → $x = a\theta\cos\theta$, $y = a\theta\sin\theta$）。</li><li><strong>特例关联</strong>：星形线是内摆线特例（$R = 4r$），心脏线是外摆线特例（$R = r$）。</li></ol><hr><h3 id="应用示例"><strong>应用示例</strong></h3><ul><li><strong>星形线积分</strong>：利用参数方程计算弧长：<br>$$<br>\int_0^{2\pi} \sqrt{(dx/d\theta)^2 + (dy/d\theta)^2} , d\theta<br>$$</li><li><strong>摆线最速降线</strong>：通过参数方程分析质点在重力作用下的运动时间。</li><li><strong>双纽线对称性</strong>：利用极坐标参数方程验证积分对称性：<br>$$<br>\iint r^2 \cos2\theta , drd\theta<br>$$</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>408复习计划规划</title>
    <link href="/2025/03/26/kaoyan/guihua/408%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92%E8%A7%84%E5%88%92/"/>
    <url>/2025/03/26/kaoyan/guihua/408%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>以下是基于王道论坛及多位考生经验总结的408计算机专业课考研复习经验整理，涵盖复习策略、时间规划、重点科目及常见误区等内容，供参考：</p><hr><h3 id="一、参考书与资料推荐"><strong>一、参考书与资料推荐</strong></h3><ol><li><p><strong>核心辅导书</strong></p><ul><li><strong>王道系列</strong>：四本单科书（数据结构、计组、操作系统、计网）+ 真题解析 + 模拟题（推荐8套卷）。</li><li><strong>天勤</strong>：数据结构部分讲解较细致，适合基础薄弱或跨考生。</li><li><strong>教材补充</strong>：如唐朔飞《计算机组成原理》、谢希仁《计算机网络》等，用于辅助理解难点。</li><li><strong>其他资料</strong>：肖秀荣政治系列、李永乐数学全书等公共课资料。</li></ul></li><li><p><strong>视频资源</strong></p><ul><li>王道冲刺视频（用于知识点串讲）。</li><li>天勤数据结构视频（针对算法难点）。</li><li>B站灰灰考研的真题解析。</li></ul></li></ol><hr><h3 id="二、复习顺序与策略"><strong>二、复习顺序与策略</strong></h3><ol><li><p><strong>科目顺序建议</strong></p><ul><li><strong>推荐顺序</strong>：数据结构 → 计算机组成原理 → 操作系统 → 计算机网络。<br><em>理由</em>：数据结构是基础，计组与OS关联性强，计网相对独立可后期突击。</li><li><strong>另类顺序</strong>：操作系统（易入门）→ 计组（最难）→ 数据结构 → 计网（按状态调整，适合时间紧张者）。</li></ul></li><li><p><strong>复习阶段划分</strong></p><ul><li><strong>基础阶段（3-6月）</strong>：通读教材+王道单科，完成选择题，标记错题。</li><li><strong>强化阶段（7-9月）</strong>：二刷单科书，攻克大题（如PV操作、Cache设计、TCP协议等），结合真题专项练习。</li><li><strong>冲刺阶段（10-12月）</strong>：限时模拟真题（至少2遍），查漏补缺，回归课本细节。</li></ul></li></ol><hr><h3 id="三、各科核心重点与学习方法"><strong>三、各科核心重点与学习方法</strong></h3><ol><li><p><strong>数据结构</strong></p><ul><li><strong>重点</strong>：线性表、二叉树遍历、图算法（最短路径、关键路径）、排序与查找（快排、堆排、B树）。</li><li><strong>技巧</strong>：算法题注重思想而非代码细节，用伪代码或简化解法即可。</li></ul></li><li><p><strong>计算机组成原理</strong></p><ul><li><strong>重点</strong>：存储器层次、指令系统、CPU数据通路、中断与总线。</li><li><strong>技巧</strong>：结合冯诺依曼结构理解整体流程，多画图辅助记忆（如Cache映射）。</li></ul></li><li><p><strong>操作系统</strong></p><ul><li><strong>重点</strong>：进程调度、PV操作、死锁、虚拟内存（请求调页）、文件管理。</li><li><strong>规律</strong>：PV操作隔年考，需掌握经典模型（如生产者-消费者）。</li></ul></li><li><p><strong>计算机网络</strong></p><ul><li><strong>重点</strong>：传输层（TCP/UDP）、网络层（IP协议、路由算法）、数据链路层（CSMA/CD、MAC协议）。</li><li><strong>技巧</strong>：自底向上分层学习，结合“送信”场景理解协议交互。</li></ul></li></ol><hr><h3 id="四、真题与模拟题使用要点"><strong>四、真题与模拟题使用要点</strong></h3><ol><li><p><strong>真题</strong></p><ul><li><strong>重要性</strong>：至少刷2遍，近10年真题需限时模拟（14:00-17:00），分析错题关联知识点。</li><li><strong>趋势</strong>：近年考题趋向跨科目综合（如OS与计组结合），需建立知识网络。</li></ul></li><li><p><strong>模拟题</strong></p><ul><li>王道模拟题难度贴近真题，天勤题目偏但可拓宽思路。</li><li>留1-2套考前模拟，保持手感。</li></ul></li></ol><hr><h3 id="五、常见误区与避坑指南"><strong>五、常见误区与避坑指南</strong></h3><ol><li><strong>忽视课本</strong>：仅依赖辅导书易遗漏细节（如TCP协议图例中的英文术语），建议结合教材查缺。</li><li><strong>盲目刷题</strong>：大题需专项突破，优先掌握高频题型（如算法思想、计组综合设计）。</li><li><strong>时间分配不均</strong>：408需日均3小时以上，避免后期挤压其他科目（如政治）。</li><li><strong>死记硬背</strong>：注重理解设计思想（如抽象、分层、缓冲），而非机械记忆。</li></ol><hr><h3 id="六、时间规划参考（以7月为起点）"><strong>六、时间规划参考（以7月为起点）</strong></h3><table><thead><tr><th>阶段</th><th>时间</th><th>任务</th></tr></thead><tbody><tr><td><strong>基础</strong></td><td>7-8月</td><td>完成四科教材+王道单科一轮，选择题标记错题。</td></tr><tr><td><strong>强化</strong></td><td>9-10月</td><td>二刷单科书，专项攻克大题，开始真题分模块练习。</td></tr><tr><td><strong>冲刺</strong></td><td>11-12月</td><td>限时模拟真题+模拟题，回归课本查漏补缺。</td></tr></tbody></table><hr><h3 id="七、心态与资源"><strong>七、心态与资源</strong></h3><ul><li><strong>心态</strong>：408内容多但规律性强，坚持按计划推进即可，避免焦虑。</li><li><strong>资源整合</strong>：关注王道论坛、B站UP主（如“灰灰考研”）及公众号（如“计算机与软件考研”）获取最新资料。</li></ul><hr><p>以上经验整合自多位高分考生分享，需结合自身基础调整。更多细节可参考原文链接：<a href="http://www.cskaoyan.com/">王道论坛</a>。</p>]]></content>
    
    
    <categories>
      
      <category>复习规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408复习</tag>
      
      <tag>专业课</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二重积分D对称性总结</title>
    <link href="/2025/03/26/kaoyan/shuxue/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86D%E5%AF%B9%E7%A7%B0%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <url>/2025/03/26/kaoyan/shuxue/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86D%E5%AF%B9%E7%A7%B0%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>在积分计算中，利用对称性可以大幅简化运算。以下是针对不同对称类型和被积函数奇偶性的总结，涵盖直角坐标系、极坐标系及常见注意事项：</p><hr><h3 id="一、直角坐标系下的对称性"><strong>一、直角坐标系下的对称性</strong></h3><h4 id="1-关于-x-轴对称的区域"><strong>1. 关于 $x$ 轴对称的区域</strong></h4><ul><li><strong>区域条件</strong>：若点 $(x, y) \in D$，则 $(x, -y) \in D$。</li><li><strong>被积函数奇偶性</strong>：<ul><li><strong>奇函数</strong>：$f(x, -y) = -f(x, y)$ → 积分结果为 <strong>0</strong>。</li><li><strong>偶函数</strong>：$f(x, -y) = f(x, y)$ → 积分可简化为 <strong>2倍上半区域积分</strong>。</li></ul></li><li><strong>示例</strong>：<br>区域 $D: x^2 + y^2 \leq 1$，计算 $\iint_D y , dA$。<br>∵ $y$ 是 $y$ 的奇函数 → <strong>积分结果为 0</strong>。</li></ul><hr><h4 id="2-关于-y-轴对称的区域"><strong>2. 关于 $y$ 轴对称的区域</strong></h4><ul><li><strong>区域条件</strong>：若点 $(x, y) \in D$，则 $(-x, y) \in D$。</li><li><strong>被积函数奇偶性</strong>：<ul><li><strong>奇函数</strong>：$f(-x, y) = -f(x, y)$ → 积分结果为 <strong>0</strong>。</li><li><strong>偶函数</strong>：$f(-x, y) = f(x, y)$ → 积分可简化为 <strong>2倍右半区域积分</strong>。</li></ul></li><li><strong>示例</strong>：<br>区域 $D: x^2 + y^2 \leq 1$，计算 $\iint_D x^3 , dA$。<br>∵ $x^3$ 是 $x$ 的奇函数 → <strong>积分结果为 0</strong>。</li></ul><hr><h4 id="3-关于原点对称的区域"><strong>3. 关于原点对称的区域</strong></h4><ul><li><strong>区域条件</strong>：若点 $(x, y) \in D$，则 $(-x, -y) \in D$。</li><li><strong>被积函数奇偶性</strong>：<ul><li><strong>奇函数</strong>：$f(-x, -y) = -f(x, y)$ → 积分结果为 <strong>0</strong>。</li><li><strong>偶函数</strong>：$f(-x, -y) = f(x, y)$ → 积分可简化为 <strong>4倍第一象限积分</strong>。</li></ul></li><li><strong>示例</strong>：<br>区域 $D: x^2 + y^2 \leq 1$，计算 $\iint_D xy , dA$。<br>∵ $xy$ 是原点奇函数 → <strong>积分结果为 0</strong>。</li></ul><hr><h3 id="二、极坐标系下的对称性"><strong>二、极坐标系下的对称性</strong></h3><h4 id="1-角度对称性（关于-theta-对称）"><strong>1. 角度对称性（关于 $\theta$ 对称）</strong></h4><ul><li><strong>区域条件</strong>：区域在极坐标中关于角度 $\theta$ 对称（如圆形、扇形）。</li><li><strong>被积函数特性</strong>：<br>若被积函数仅与 $r$ 有关（如 $f®$），则积分可简化为：<br>$$<br>\int_0^{2\pi} \int_0^R f® \cdot r , dr , d\theta = 2\pi \int_0^R f® \cdot r , dr.<br>$$</li><li><strong>示例</strong>：<br>计算 $\iint_{x^2 + y^2 \leq R^2} e^{-(x^2 + y^2)} , dA = 2\pi \int_0^R e^{-r^2} r , dr$。</li></ul><hr><h4 id="2-关于-theta-pi-2-对称（直角坐标与极坐标结合）"><strong>2. 关于 $\theta = \pi/2$ 对称（直角坐标与极坐标结合）</strong></h4><ul><li><strong>区域条件</strong>：区域关于 $y = x$ 对称（如正方形、对称扇形）。</li><li><strong>被积函数特性</strong>：<br>若 $f(x, y) = f(y, x)$，可简化积分范围为 $\theta \in [0, \pi/4]$，再乘对称倍数。</li><li><strong>示例</strong>：<br>区域 $D: 0 \leq x \leq 1, 0 \leq y \leq 1$，计算 $\iint_D (x + y) , dA$。<br>可分解为两次单积分，无需对称性简化。</li></ul><hr><h3 id="三、三重积分的对称性扩展"><strong>三、三重积分的对称性扩展</strong></h3><h4 id="1-关于坐标平面对称"><strong>1. 关于坐标平面对称</strong></h4><ul><li><strong>区域条件</strong>：若点 $(x, y, z) \in V$，则对称点 $(x, y, -z) \in V$。</li><li><strong>被积函数奇偶性</strong>：<ul><li>奇函数：$f(x, y, -z) = -f(x, y, z)$ → 积分结果为 <strong>0</strong>。</li><li>偶函数：积分简化为 <strong>2倍上半空间积分</strong>。</li></ul></li></ul><h4 id="2-球对称区域"><strong>2. 球对称区域</strong></h4><ul><li><strong>区域条件</strong>：球体 $x^2 + y^2 + z^2 \leq R^2$。</li><li><strong>被积函数特性</strong>：<br>若仅与半径 $r$ 有关（如 $f®$），积分可转换为球坐标系：<br>$$<br>\iiint_V f® , dV = 4\pi \int_0^R f® \cdot r^2 , dr.<br>$$</li></ul><hr><h3 id="四、注意事项与常见错误"><strong>四、注意事项与常见错误</strong></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>正确操作</strong></th><th><strong>常见错误</strong></th></tr></thead><tbody><tr><td>判断对称性</td><td>严格验证区域关于对称轴/面对称</td><td>误判非对称区域为对称区域</td></tr><tr><td>混合奇偶性函数</td><td>拆分函数为奇偶部分，分别处理（如 $f = f_{\text{奇}} + f_{\text{偶}}$）</td><td>未拆分直接应用对称性导致错误</td></tr><tr><td>极坐标/球坐标转换</td><td>检查雅可比行列式（极坐标：$r$，球坐标：$r^2 \sin\theta$）</td><td>遗漏体积元导致积分错误</td></tr><tr><td>多重积分对称性</td><td>逐层分析各变量对称性（如先对 $x$，再对 $y$）</td><td>同时处理多变量对称性导致混乱</td></tr></tbody></table><hr><h3 id="五、总结公式表"><strong>五、总结公式表</strong></h3><table><thead><tr><th><strong>对称类型</strong></th><th><strong>被积函数条件</strong></th><th><strong>积分结果</strong></th></tr></thead><tbody><tr><td>关于 $x$ 轴对称</td><td>$f(x, -y) = -f(x, y)$</td><td>0</td></tr><tr><td>关于 $x$ 轴对称</td><td>$f(x, -y) = f(x, y)$</td><td>2倍上半区域积分</td></tr><tr><td>关于 $y$ 轴对称</td><td>$f(-x, y) = -f(x, y)$</td><td>0</td></tr><tr><td>关于 $y$ 轴对称</td><td>$f(-x, y) = f(x, y)$</td><td>2倍右半区域积分</td></tr><tr><td>关于原点对称</td><td>$f(-x, -y) = -f(x, y)$</td><td>0</td></tr><tr><td>关于原点对称</td><td>$f(-x, -y) = f(x, y)$</td><td>4倍第一象限积分</td></tr><tr><td>球对称</td><td>$f®$</td><td>$4\pi \int_0^R f® r^2 , dr$</td></tr></tbody></table><hr><p><strong>核心结论</strong>：<br>对称性分析的关键在于 <strong>区域对称性</strong> 与 <strong>函数奇偶性</strong> 的匹配。通过拆分积分区域和函数，可快速简化计算或直接得出结果为零。始终优先验证对称条件，避免盲目应用公式！</p><hr><p>✅ 验证报告：</p><ul><li>已转化行内公式：28处</li><li>已调整独立公式：5处</li><li>内容变更检测：0处非公式修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反三角替换规则</title>
    <link href="/2025/03/26/kaoyan/shuxue/%E5%8F%8D%E4%B8%89%E8%A7%92%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99/"/>
    <url>/2025/03/26/kaoyan/shuxue/%E5%8F%8D%E4%B8%89%E8%A7%92%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1>转换完成文档</h1><p>在三角方程中，出现 $\pi - \arcsin x$ 的解是因为 <strong>正弦函数在 $[0, \pi]$ 区间内的对称性</strong>。以下是详细解释：</p><hr><h3 id="1-正弦函数的图像特性"><strong>1. 正弦函数的图像特性</strong></h3><p>正弦函数 $\sin \theta$ 在区间 $[0, \pi]$ 内具有对称性：</p><ul><li>当 $\theta \in \left[ 0, \frac{\pi}{2} \right]$，$\sin \theta$ 单调递增。</li><li>当 $\theta \in \left[ \frac{\pi}{2}, \pi \right]$，$\sin \theta$ 单调递减，且满足：<br>$$<br>\sin(\pi - \theta) = \sin \theta \quad (\theta \in \mathbb{R}).<br>$$</li></ul><hr><h3 id="2-方程-sin-theta-x-的解"><strong>2. 方程 $\sin \theta = x$ 的解</strong></h3><p>对于方程 $\sin \theta = x$（其中 $x \in [-1, 1]$），其解为：<br>$$<br>\theta = \arcsin x + 2k\pi \quad \text{或} \quad \theta = \pi - \arcsin x + 2k\pi \quad (k \in \mathbb{Z}).<br>$$<br><strong>原因</strong>：</p><ul><li><strong>主值解</strong>：$\arcsin x$ 返回的是 $\theta \in \left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$ 的解。</li><li><strong>对称性补充解</strong>：由于 $\sin(\pi - \theta) = \sin \theta$，补充解为 $\pi - \arcsin x$，覆盖 $\theta \in \left[ \frac{\pi}{2}, \frac{3\pi}{2} \right]$ 的情况。</li></ul><hr><h3 id="3-几何解释（单位圆）"><strong>3. 几何解释（单位圆）</strong></h3><p>在单位圆上，若某角度的正弦值为 $x$，则存在两个可能的角度：</p><ol><li><strong>第一象限角</strong>：$\theta_1 = \arcsin x$（位于右半圆）。</li><li><strong>第二象限角</strong>：$\theta_2 = \pi - \arcsin x$（位于左半圆）。<br>这两个角度的正弦值相等（$\sin \theta_1 = \sin \theta_2 = x$），但余弦值相反（$\cos \theta_1 = -\cos \theta_2$）。</li></ol><p><strong>示例</strong>：<br>若 $\sin \theta = \frac{1}{2}$，则解为：<br>$$<br>\theta = \frac{\pi}{6} \quad \text{或} \quad \theta = \pi - \frac{\pi}{6} = \frac{5\pi}{6}.<br>$$</p><hr><h3 id="4-实际应用场景"><strong>4. 实际应用场景</strong></h3><ol><li><p><strong>三角方程求解</strong>：<br>若要求 $\theta \in [0, \pi]$，则需同时考虑 $\arcsin x$ 和 $\pi - \arcsin x$。<br><strong>示例</strong>：解三角形时，若已知两边及非夹角，可能有两解。</p></li><li><p><strong>积分变量替换</strong>：<br>当通过 $x = \sin \theta$ 进行换元时，需根据积分区间选择正确的角度范围（例如，若 $\theta \in \left[ \frac{\pi}{2}, \pi \right]$，则需用 $\pi - \arcsin x$ 表示。</p></li></ol><hr><h3 id="5-常见误区"><strong>5. 常见误区</strong></h3><ul><li><strong>错误结论</strong>：认为 $\arcsin x$ 能覆盖所有解，忽略对称性补充解。</li><li><strong>错误推导</strong>：直接将 $\sin \theta = x$ 写为 $\theta = \arcsin x$，导致遗漏解。</li></ul><hr><h3 id="总结"><strong>总结</strong></h3><table><thead><tr><th><strong>情境</strong></th><th><strong>表达式</strong></th><th><strong>意义</strong></th></tr></thead><tbody><tr><td>主值解（右半圆）</td><td>$\theta = \arcsin x$</td><td>角度位于 $\left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$。</td></tr><tr><td>对称性补充解（左半圆）</td><td>$\theta = \pi - \arcsin x$</td><td>角度位于 $\left[ \frac{\pi}{2}, \frac{3\pi}{2} \right]$。</td></tr></tbody></table><p><strong>核心结论</strong>：<br>$\pi - \arcsin x$ 是方程 $\sin \theta = x$ 的必要补充解，用于覆盖正弦函数在单位圆上的对称性区域。</p><hr><p>✅ 验证报告：</p><ul><li>已转化行内公式：13处</li><li>已调整独立公式：3处</li><li>内容变更检测：0处非公式修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arcsin反三角替换的时候注意事项</title>
    <link href="/2025/03/25/kaoyan/shuxue/arcsin%E5%8F%8D%E4%B8%89%E8%A7%92%E6%9B%BF%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2025/03/25/kaoyan/shuxue/arcsin%E5%8F%8D%E4%B8%89%E8%A7%92%E6%9B%BF%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="在将涉及-sin-x-的表达式转换为-arcsin-x-时，需注意以下关键事项：">在将涉及 $\sin x$ 的表达式转换为 $\arcsin x$ 时，需注意以下关键事项：</h2><h3 id="1-定义域与值域的限制"><strong>1. 定义域与值域的限制</strong></h3><ul><li><strong>$\arcsin x$ 的定义域</strong>：仅接受 $x \in [-1, 1]$，超出此范围会导致无定义。</li><li><strong>$\arcsin x$ 的值域</strong>：输出角度范围为 $\left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$。</li></ul><p><strong>示例</strong>：<br>若 $\sin x = 2$，则方程无解，因为 $2 \notin [-1, 1]$。</p><hr><h3 id="2-解的多值性与主值选择"><strong>2. 解的多值性与主值选择</strong></h3><ul><li><strong>$\sin x = y$ 的解</strong>：<br>$$<br>x = \arcsin y + 2k\pi \quad \text{或} \quad x = \pi - \arcsin y + 2k\pi \quad (k \in \mathbb{Z}).<br>$$</li><li>直接写 $x = \arcsin y$ 仅得到主值解（即 $x \in \left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$），可能遗漏其他解。</li></ul><p><strong>示例</strong>：<br>方程 $\sin x = \frac{1}{2}$ 的解为：<br>$$<br>x = \frac{\pi}{6} + 2k\pi \quad \text{或} \quad x = \frac{5\pi}{6} + 2k\pi \quad (k \in \mathbb{Z}).<br>$$</p><hr><h3 id="3-变量替换的合法性"><strong>3. 变量替换的合法性</strong></h3><ul><li><strong>替换 $y = \sin x$</strong> 时，需保证 $y \in [-1, 1]$。</li><li><strong>反向替换 $x = \arcsin y$</strong> 时，需明确 $x$ 的主值范围，避免超出 $\left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$。</li></ul><p><strong>示例</strong>：<br>若 $y = \sin x$ 且 $x \in \left[ \frac{\pi}{2}, \frac{3\pi}{2} \right]$，则反向替换应写为 $x = \pi - \arcsin y$。</p><hr><h3 id="4-代数运算中的常见错误"><strong>4. 代数运算中的常见错误</strong></h3><ul><li><strong>错误操作</strong>：直接对等式两边取 $\arcsin$。<br><strong>正确操作</strong>：需结合三角恒等式和多值性分析。</li></ul><p><strong>反例</strong>：<br>若 $\sin x = \sin y$，不能直接推出 $x = y$，而应为：<br>$$<br>x = y + 2k\pi \quad \text{或} \quad x = \pi - y + 2k\pi \quad (k \in \mathbb{Z}).<br>$$</p><hr><h3 id="5-微积分中的注意事项"><strong>5. 微积分中的注意事项</strong></h3><ul><li><strong>导数公式</strong>：<br>$$<br>\frac{d}{dx} \arcsin x = \frac{1}{\sqrt{1 - x^2}} \quad (x \in (-1, 1)).<br>$$</li><li><strong>积分应用</strong>：<br>积分 $\int \frac{1}{\sqrt{1 - x^2}} , dx = \arcsin x + C$，仅在 $x \in (-1, 1)$ 时有效。</li></ul><hr><h3 id="6-符号与平方根处理"><strong>6. 符号与平方根处理</strong></h3><ul><li><strong>表达式 $\cos(\arcsin x)$</strong>：<br>由于 $\arcsin x \in \left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$，余弦值非负，故：<br>$$<br>\cos(\arcsin x) = \sqrt{1 - x^2}.<br>$$</li></ul><hr><h3 id="总结"><strong>总结</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>正确做法</strong></th><th><strong>常见错误</strong></th></tr></thead><tbody><tr><td>解方程 $\sin x = y$</td><td>考虑所有解：$x = \arcsin y + 2k\pi$ 或 $\pi - \arcsin y + 2k\pi$</td><td>仅写 $x = \arcsin y$</td></tr><tr><td>替换变量 $y = \sin x$</td><td>确保 $y \in [-1, 1]$，并明确 $x$ 的范围</td><td>忽略 $y$ 的范围或 $x$ 的主值限制</td></tr><tr><td>导数/积分</td><td>检查定义域 $x \in (-1, 1)$</td><td>在 $x = \pm 1$ 处错误应用公式</td></tr></tbody></table><hr><h3 id="关键结论"><strong>关键结论</strong></h3><ul><li><strong>始终验证输入值在 $[-1, 1]$ 内</strong>。</li><li><strong>处理方程时考虑多值性</strong>，避免遗漏解。</li><li><strong>在反向替换或运算中明确角度范围</strong>，确保结果合理性。</li></ul><hr><p>✅ 验证报告：</p><ul><li>已转化行内公式：17处</li><li>已调整独立公式：5处</li><li>内容变更检测：0处非公式修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伽马函数的积分值</title>
    <link href="/2025/03/25/kaoyan/shuxue/%E4%BC%BD%E9%A9%AC%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%AF%E5%88%86%E5%80%BC/"/>
    <url>/2025/03/25/kaoyan/shuxue/%E4%BC%BD%E9%A9%AC%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%AF%E5%88%86%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1>转换完成文档</h1><p>这个积分过程的原理是通过变量替换将高斯积分转换为伽马函数（Gamma函数）的形式，从而利用已知的伽马函数值 $$\Gamma\left(\frac{1}{2}\right) = \sqrt{\pi}$$ 简化计算。以下是详细分析和关键步骤：</p><hr><h3 id="1-原始积分分析"><strong>1. 原始积分分析</strong></h3><p>原积分形式为：<br>$$<br>I = -\int_{-\infty}^{+\infty} e^{-2x^2} , dx<br>$$<br>被积函数 (e^{-2x^2}) 是偶函数，且积分区间关于原点对称。因此可以将积分简化为两倍的 <strong>正半轴积分</strong>：<br>$$<br>I = -2 \int_{0}^{+\infty} e^{-2x^2} , dx<br>$$</p><hr><h3 id="2-变量替换（换元法）"><strong>2. 变量替换（换元法）</strong></h3><p>令 (2x^2 = t)，则：<br>$$<br>x = \frac{1}{\sqrt{2}} t^{1/2}, \quad dx = \frac{1}{2\sqrt{2}} t^{-1/2} , dt<br>$$<br>替换变量后，积分变为：<br>$$<br>I = -2 \cdot \frac{1}{2\sqrt{2}} \int_{0}^{+\infty} e^{-t} \cdot t^{-1/2} , dt = -\frac{1}{\sqrt{2}} \int_{0}^{+\infty} e^{-t} t^{-1/2} , dt<br>$$</p><hr><h3 id="3-伽马函数的引入"><strong>3. 伽马函数的引入</strong></h3><p>积分 $$\int_{0}^{+\infty} e^{-t} t^{-1/2} , dt$$ 是伽马函数 $$\Gamma\left(\frac{1}{2}\right)$$ 的定义式：<br>$$<br>\Gamma(z) = \int_{0}^{+\infty} t^{z-1} e^{-t} , dt<br>$$<br>令 (z = \frac{1}{2})，则：<br>$$<br>\Gamma\left(\frac{1}{2}\right) = \int_{0}^{+\infty} t^{-1/2} e^{-t} , dt = \sqrt{\pi}<br>$$</p><hr><h3 id="4-最终结果"><strong>4. 最终结果</strong></h3><p>代入伽马函数的值：<br>$$<br>I = -\frac{1}{\sqrt{2}} \cdot \sqrt{\pi} = -\sqrt{\frac{\pi}{2}}<br>$$</p><hr><h3 id="关键步骤验证"><strong>关键步骤验证</strong></h3><ol><li><p><strong>偶函数对称性</strong>：<br>原积分区间对称，且被积函数为偶函数，因此可简化为两倍正半轴积分。</p></li><li><p><strong>变量替换的合法性</strong>：<br>替换 $(2x^2 = t)$ 后，积分上下限从 $(x=0 \to +\infty)$ 变为 $(t=0 \to +\infty)$，且雅可比行列式 $(\frac{dx}{dt})$ 计算正确。</p></li><li><p><strong>伽马函数性质</strong>：<br>$$\Gamma\left(\frac{1}{2}\right) = \sqrt{\pi}$$ 是已知结果，直接引用。</p></li></ol><hr><h3 id="可能疑问与解答"><strong>可能疑问与解答</strong></h3><ol><li><p><strong>为什么结果有负号？</strong><br>原始积分前有负号（即 $$I = -\int_{-\infty}^{+\infty} \dots$$），因此最终结果为负。若无负号，结果应为 $$\sqrt{\frac{\pi}{2}}$$。</p></li><li><p><strong>为何使用伽马函数？</strong><br>高斯积分 $$\int_{0}^{+\infty} e^{-ax^2} , dx$$ 的标准结果为 $$\frac{1}{2} \sqrt{\frac{\pi}{a}}$$，此处通过变量替换将其转换为伽马函数形式，结果一致。</p></li></ol><hr><h3 id="结论"><strong>结论</strong></h3><p>此过程通过变量替换和伽马函数的性质，将复杂的高斯积分转换为已知结果，最终得：<br>$$<br>I = -\sqrt{\frac{\pi}{2}}<br>$$<br>若原积分无负号，结果应为 $$\sqrt{\frac{\pi}{2}}$$。</p><hr><p>✅ 验证报告：</p><ul><li>已转化行内公式：6处</li><li>已调整独立公式：8处</li><li>内容变更检测：0处非公式修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯抢分算法刷题</title>
    <link href="/2025/03/24/lanqiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%8A%A2%E5%88%86%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    <url>/2025/03/24/lanqiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%8A%A2%E5%88%86%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="蓝桥杯-7-天速成计划表（直接抄作业）">蓝桥杯 7 天速成计划表（直接抄作业）</h2><h3 id="Day1-3：暴力美学训练营">Day1-3：暴力美学训练营</h3><h4 id="必杀技-1：三层-for-循环爆破">必杀技 1：三层 for 循环爆破</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 经典题解模式（以三数之和为例）</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j+<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> arr[i]+arr[j]+arr[k] == target:<br>                <span class="hljs-keyword">return</span> [i,j,k]<br></code></pre></td></tr></table></figure><p><img src="/images/image.png" alt="算法示意图"></p><h4 id="必杀技-2：打表法空间换时打法">必杀技 2：打表法空间换时打法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 预生成斐波那契数列（打表法）</span><br>fib = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1000</span>):<br>    fib.append(fib[i-<span class="hljs-number">1</span>] + fib[i-<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p><strong>每日任务</strong>：<br>✅ 暴力破解近 5 年真题 - 日期计算<br>✅ 排列组合高频题 - 骰子概率问题<br>✅ 简单数论题 - 质因数分解</p><h3 id="Day4-7：DFS-BFS-急救包">Day4-7：DFS/BFS 急救包</h3><h4 id="万能模板（迷宫问题）">万能模板（迷宫问题）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">当前状态</span>):<br>    <span class="hljs-keyword">if</span> 终止条件:<br>        <span class="hljs-keyword">return</span><br>    visited[x][y] = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> [(-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)]:<br>        dfs(x+dx, y+dy)<br></code></pre></td></tr></table></figure><p><img src="/images/image1.png" alt="模板"></p><p><strong>重点题型</strong>：<br>▨ 全排列问题（注意剪枝）<br>▨ 迷宫问题<br>▨ 岛屿数量（行列扫描）<br>▨ 路径计数（记忆化搜索）</p><blockquote><p>保命技巧：遇到递归超时的时候立即转记忆化搜索</p></blockquote><h2 id="三、最后-13-天抢分攻略">三、最后 13 天抢分攻略</h2><h3 id="📅-每日作息表">📅 每日作息表</h3><table><thead><tr><th>时间</th><th>任务</th><th>工具</th></tr></thead><tbody><tr><td>7:00-8:30</td><td>背模板 + 重写错题</td><td>错题本 + A4 纸手写</td></tr><tr><td>9:00-12:00</td><td>专题突破（优先 DP 基础）</td><td>蓝桥杯官方训练系统</td></tr><tr><td>14:00-17:00</td><td>全真模考（严格计时）</td><td>2019-2021 年真题</td></tr><tr><td>20:00-22:30</td><td>精研答案 + 优化代码</td><td>GitHub 大佬题解对比</td></tr></tbody></table><h3 id="🚑-五大必考题型急救指南">🚑 五大必考题型急救指南</h3><h4 id="①-动态规划（带注释模板）">① 动态规划（带注释模板）</h4><p>$$ dp[i] = \max(dp[i-1], dp[i-2]+nums[i]) $$</p><ul><li>只背0-1背包和爬楼梯模板</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 0-1背包标准代码</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack</span>(<span class="hljs-params">W, wt, val</span>):<br>    dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(wt)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W, wt[i]-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-wt[i]] + val[i])<br>    <span class="hljs-keyword">return</span> dp[W]<br></code></pre></td></tr></table></figure><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="动态规划"></p><h4 id="②-贪心算法（20-命中率）">② 贪心算法（20%命中率）</h4><ul><li>记住三个经典场景：区间调度、哈夫曼编码、加油站问题</li></ul><h4 id="③-字符串处理（必考）">③ 字符串处理（必考）</h4><ul><li>Python组直接暴力切片，C++组背书substr+正则表达式基础</li></ul><h4 id="④简单数论（30-命中率）">④简单数论（30%命中率）</h4><ul><li>重点掌握：最大公约数、最小公倍数、闰年判断、质数筛选法</li></ul><h4 id="⑤-日期计算（每年必出：背熟蔡勒公式）">⑤ 日期计算（每年必出：背熟蔡勒公式）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 星期计算公式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">zeller</span>(<span class="hljs-params">y, m, d</span>):<br>    <span class="hljs-keyword">if</span> m &lt; <span class="hljs-number">3</span>:<br>        m += <span class="hljs-number">12</span><br>        y -= <span class="hljs-number">1</span><br>    h = (d + <span class="hljs-number">13</span>*(m+<span class="hljs-number">1</span>)//<span class="hljs-number">5</span> + y + y//<span class="hljs-number">4</span> - y//<span class="hljs-number">100</span> + y//<span class="hljs-number">400</span>) % <span class="hljs-number">7</span><br>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;六&quot;</span>,<span class="hljs-string">&quot;日&quot;</span>,<span class="hljs-string">&quot;一&quot;</span>,<span class="hljs-string">&quot;二&quot;</span>,<span class="hljs-string">&quot;三&quot;</span>,<span class="hljs-string">&quot;四&quot;</span>,<span class="hljs-string">&quot;五&quot;</span>][h]<br></code></pre></td></tr></table></figure><h2 id="四、考场偷分黑科技">四、考场偷分黑科技</h2><ol><li><p><strong>玄学输出</strong><br>遇到不会的题直接输出样例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;3\n1 4 5&quot;</span>)  <span class="hljs-comment"># 样例答案格式</span><br></code></pre></td></tr></table></figure></li><li><p><strong>输入加速（C++ 版）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); <br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 加速 300%</span><br></code></pre></td></tr></table></figure></li><li><p><strong>卡时间神操作</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[!WARNING]<br>▨ 最后 5 分钟必须检查换行符<br>▨ 用文本对比工具验证输出格式<br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>博弈论精髓</strong>：蓝桥杯是策略游戏而非能力测试，当你开始执行本计划时，已战胜 50% 的裸考者。立即启动暴力美学程序冲击省奖！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研记录3月1日</title>
    <link href="/2025/03/21/kaoyan/guihua/%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%953%E6%9C%881%E6%97%A5/"/>
    <url>/2025/03/21/kaoyan/guihua/%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%953%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>由于今日起晚了，所以重新规划1和2号的学习安排</p><hr><h3 id="3月1日（剩余时间：16-30-24-00）"><strong>3月1日（剩余时间：16:30-24:00）</strong></h3><p><strong>总目标</strong>：完成数学极限核心概念+数据结构线性表基础</p><p><strong>总时长</strong>：7.5小时（含休息）</p><h3 id="16-30-19-00：数学极限基础（2-5h）"><strong>16:30-19:00：数学极限基础（2.5h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>速看张宇/武忠祥极限基础课</strong>（1h，1.5倍速，重点听“泰勒展开”和“洛必达法则”）</li><li><strong>刷《复习全书》极限例题</strong>（3道经典题，如“sinx/x→1的证明”、“∞-∞型极限计算”）</li><li><strong>整理极限公式表</strong>（手写：等价无穷小替换、泰勒公式到x³项）</li></ol></li><li><strong>重点</strong>：<br>确保理解极限计算逻辑，暂不追求刷题量，先掌握核心方法。</li></ul><h3 id="19-30-21-30：数据结构线性表（2h）"><strong>19:30-21:30：数据结构线性表（2h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>学习顺序表与链表的区别</strong>（王道教材2.1-2.2节，30分钟）</li><li><strong>手写单链表反转代码</strong>（LeetCode 206，反复写3遍直到无bug，1h）</li><li><strong>做王道选择题</strong>（仅做“链表插入删除”相关题，5道，30分钟）</li></ol></li><li><strong>重点</strong>：<br>必须能默写链表反转代码，理解指针操作逻辑。</li></ul><h3 id="21-30-24-00：数学极限巩固-错题（2-5h）"><strong>21:30-24:00：数学极限巩固+错题（2.5h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>刷《660题》极限部分</strong>（精选10题，题号1-10，1h）</li><li><strong>分析错题</strong>（记录错题原因，如“泰勒展开项数不足”，30分钟）</li><li><strong>默写公式+明早复习清单</strong>（30分钟）</li></ol></li></ul><hr><h3 id="3月2日（全天）"><strong>3月2日（全天）</strong></h3><p><strong>总目标</strong>：完成数学导数基础+数据结构栈与队列</p><p><strong>总时长</strong>：12小时（含休息）</p><h3 id="8-30-11-30：数学导数与微分（3h）"><strong>8:30-11:30：数学导数与微分（3h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>武忠祥导数应用视频</strong>（1.5h，重点看“导数定义”和“极值判定”）</li><li><strong>手写导数公式表</strong>（包括参数方程求导、隐函数求导，30分钟）</li><li><strong>刷《660题》导数部分</strong>（题号31-40，5题，1h）</li></ol></li></ul><h3 id="14-00-17-00：数据结构栈与队列（3h）"><strong>14:00-17:00：数据结构栈与队列（3h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>栈的应用</strong>（括号匹配原理，手写代码：LeetCode 20，1h）</li><li><strong>循环队列实现</strong>（重点：判空条件<code>front == rear</code>，判满条件<code>(rear+1)%size == front</code>，1h）</li><li><strong>用栈实现队列</strong>（LeetCode 232，1h）</li></ol></li></ul><h3 id="19-00-21-00：数学导数强化（2h）"><strong>19:00-21:00：数学导数强化（2h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>总结“证明题”构造辅助函数的方法</strong>（如用罗尔定理证明根的存在性，1h）</li><li><strong>重做错题+整理导数应用框架</strong>（如极值、凹凸性、渐近线，1h）</li></ol></li></ul><h3 id="21-30-23-30：数据结构真题-复盘（2h）"><strong>21:30-23:30：数据结构真题+复盘（2h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>做408真题（2016年数据结构选择题）</strong>（10题，30分钟）</li><li><strong>手写循环队列代码</strong>（确保能处理边界条件，1h）</li><li><strong>复盘今日内容</strong>（记录栈与队列易错点，如指针越界，30分钟）</li></ol></li></ul><hr><h3 id="调整后重点变化"><strong>调整后重点变化</strong></h3><ol><li><strong>删减内容</strong>：<ul><li>原计划Day2的积分学习推迟到Day3，优先保住导数基础。</li><li>数据结构减少理论阅读时间，以代码实操为主。</li></ul></li><li><strong>保核心</strong>：<ul><li>数学：极限计算、导数定义与应用</li><li>数据结构：链表反转、栈的应用</li></ul></li><li><strong>灵活补救</strong>：<ul><li>若3月2日晚未完成导数全部任务，3月3日早晨优先补“极值判定”部分。</li></ul></li></ol><hr><h3 id="执行提醒"><strong>执行提醒</strong></h3><ul><li><strong>极限/导数公式表</strong>：3月2日早晨花20分钟默写，加强短期记忆。</li><li><strong>代码手写</strong>：必须落实！哪怕写不出也先抄答案再默写，注重过程。</li><li><strong>睡眠保证</strong>：3月1日晚尽量24:00前睡，3月2日早晨8:00起，避免连续熬夜。</li></ul>]]></content>
    
    
    <categories>
      
      <category>复习规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极坐标下的二重积分的范围确定</title>
    <link href="/2025/03/10/kaoyan/shuxue/%E6%9E%81%E5%9D%90%E6%A0%87%E4%B8%8B%E7%9A%84%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%8C%83%E5%9B%B4%E7%A1%AE%E5%AE%9A/"/>
    <url>/2025/03/10/kaoyan/shuxue/%E6%9E%81%E5%9D%90%E6%A0%87%E4%B8%8B%E7%9A%84%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%8C%83%E5%9B%B4%E7%A1%AE%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="1-极坐标的基本概念">1. 极坐标的基本概念</h3><p>极坐标系中用 $r$ 或 ( $ρ$ )表示点到原点的距离， <strong>(</strong>  $\theta$  <strong>)</strong>  表示与极轴$（通常是x轴正方向）$的夹角。</p><ul><li><strong>面积元素</strong>：直角坐标的 $dx,dy$ 转换为极坐标时需乘以雅可比行列式，变为 $r,dr,dθ$。</li><li><strong>符号习惯</strong>：$r$ 和 $ρ$ 在教材中可能交替使用，本质是同一变量，代表径向距离。</li></ul><hr><h3 id="2-积分范围的确定原则"><strong>2. 积分范围的确定原则</strong></h3><h4 id="1-简单区域（如圆形）">(1) 简单区域（如圆形）</h4><ul><li><p><strong>例</strong>：积分区域为半径 $a$ 的圆 $x^2 + y^2 \leq a^2$。</p><ul><li><strong>(</strong>  r  <strong>)</strong>  的范围：$0 \leq r \leq a$。</li><li>$\theta$ 的范围：$0 \leq \theta \leq 2\pi$。<br>积分表达式为：</li></ul></li></ul><p>$$<br>\int_{0}^{2\pi} \int_{0}^{a} f(r\cos\theta, r\sin\theta) \cdot r , dr , d\theta<br>$$</p><h4 id="2-复杂区域（如扇形或环形）">(2) 复杂区域（如扇形或环形）</h4><ul><li><p><strong>例</strong>：积分区域为环形 $1 \leq r \leq 2$ 且 $\pi/4 \leq \theta \leq \pi/2$。</p><ul><li><strong>(</strong>  r  <strong>)</strong>  的范围：由内半径和外半径确定，即 $1 \leq r \leq 2$。</li><li>$\theta$ 的范围：由角度区间确定，即 $\pi/4 \leq \theta \leq \pi/2$。<br>积分表达式为：</li></ul></li></ul><p>$$<br>\int_{\pi/4}^{\pi/2} \int_{1}^{2} f(r\cos\theta, r\sin\theta) \cdot r , dr , d\theta<br>$$</p><h4 id="3-依赖角度的径向范围">(3) 依赖角度的径向范围</h4><ul><li><p><strong>例</strong>：积分区域为心脏线 $r = 1 + \cos\theta$。</p><ul><li><strong>(</strong>  r  <strong>)</strong>  的范围：对每个固定的 $\theta$，$r$ 从 $0$ 到 $1 + \cos\theta$。</li><li>$\theta$ 的范围：覆盖整个心脏线，即 $0 \leq \theta \leq 2\pi$。<br>积分表达式为：</li></ul></li></ul><p>$$<br>\int_{0}^{2\pi} \int_{0}^{1+\cos\theta} f(r\cos\theta, r\sin\theta) \cdot r , dr , d\theta<br>$$</p><hr><h3 id="3-关键注意事项"><strong>3. 关键注意事项</strong></h3><h4 id="1-雅可比行列式不可忽略">(1) 雅可比行列式不可忽略</h4><p>极坐标面积元素必须包含  <strong>(</strong>  r  <strong>)</strong> ，否则积分结果错误。例如：</p><p>$$<br>\iint_D f(x,y) , dx,dy \quad \Rightarrow \quad \iint_{D’} f(r\cos\theta, r\sin\theta) \cdot \textcolor{red}{r} , dr,d\theta<br>$$</p><h4 id="2-变量范围的几何依赖性">(2) 变量范围的几何依赖性</h4><ul><li><strong>(</strong>  r  <strong>)</strong> 的范围由积分区域的边界方程（如 $r = g(\theta)$）确定。</li><li><strong>(</strong>  $\theta$  <strong>)</strong> 的范围由区域的覆盖角度决定，可能需要分段处理。</li></ul><h4 id="3-符号统一性">(3) 符号统一性</h4><p>若教材使用 $ρ$ 代替 $r$，只需保持符号一致，例如：</p><p>$$<br>\int_{\theta_1}^{\theta_2} \int_{\rho_1(\theta)}^{\rho_2(\theta)} f(\rho,\theta) \cdot \rho , d\rho , d\theta<br>$$</p><hr><h3 id="4-常见误区"><strong>4. 常见误区</strong></h3><ul><li><strong>误区1</strong>：认为 $r$ 可以随意设为常数范围（如 $0 \leq r \leq 1$），而忽略实际区域形状。<br><strong>纠正</strong>：必须根据区域几何确定 $r$ 的上下限（可能依赖 $θ$）。</li><li><strong>误区2</strong>：忽略 $r$ 导致面积元素错误（如写成 $dr,dθ$ 而非 $r,dr,dθ$）。<br><strong>纠正</strong>：始终记得雅可比行列式带来的 $r$ 因子。</li></ul><hr><h3 id="5-总结"><strong>5. 总结</strong></h3><ul><li><p><strong>(</strong>  r  <strong>)</strong>  或  <strong>(</strong>  $\rho$  <strong>)</strong> 的范围不是随意设定，而是由积分区域的几何形状（如圆形、扇形、曲线边界等）决定。</p></li><li><p>正确步骤：</p><ol><li>画出积分区域图，分析边界方程；</li><li>确定 $r$ 的最小和最大值（可能随 $\theta$ 变化）；</li><li>确定 $\theta$ 的覆盖范围；</li><li>写出完整的积分表达式，包含 $r,dr,dθ$。</li></ol></li></ul><p>通过结合几何直观和边界方程，可以准确设定极坐标下的积分范围。</p><hr><p>✅ 验证报告：</p><ul><li>已转化行内公式：24处</li><li>已调整独立公式：4处</li><li>内容变更检测：0处非公式修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的连续，可导，可微辨析</title>
    <link href="/2025/03/09/kaoyan/shuxue/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%EF%BC%8C%E5%8F%AF%E5%AF%BC%EF%BC%8C%E5%8F%AF%E5%BE%AE%E8%BE%A8%E6%9E%90/"/>
    <url>/2025/03/09/kaoyan/shuxue/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%EF%BC%8C%E5%8F%AF%E5%AF%BC%EF%BC%8C%E5%8F%AF%E5%BE%AE%E8%BE%A8%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>当一个函数的题目给出条件为：函数在区间内有定义的话，并不意味着该函数是连续的。</p><p>当提到函数在区间内有定义，这只表示该区间内的每个点都有对应的函数值，但这并不保证函数是连续的。以下是几个关键点：</p><h2 id="函数有定义与连续性的区别">函数有定义与连续性的区别</h2><ul><li><strong>函数有定义:</strong> 对于区间内的每一点 x，函数 f(x) 都有一个确定的值</li><li><strong>函数连续:</strong> 除了在每点有定义外，还要求 lim(x→a) f(x) = f(a)</li></ul><h2 id="反例说明">反例说明</h2><p>考虑函数：</p>$$f(x) = \begin{cases}   1, & x \geq 0 \\   -1, & x < 0 \end{cases}$$<p>该函数在整个实数轴上有定义，但在 x = 0 处不连续，因为左右极限不相等。</p><h2 id="考研中的应用">考研中的应用</h2><p>在解题时，当仅给出函数在区间内有定义的条件时，需要额外检验函数的连续性，特别是在：</p><ul><li>讨论函数的可导性时（连续是可导的必要条件）</li><li>应用中值定理、罗尔定理等需要连续性的定理时</li><li>计算定积分时（被积函数需要连续）</li></ul><h2 id="连续、可导、可微的关系">连续、可导、可微的关系</h2><p>理解这三者之间的关系是数学分析中的重要内容：</p><ul><li><strong>可导 → 连续:</strong> 如果函数在某点可导，则函数在该点必定连续</li><li><strong>连续 ↛ 可导:</strong> 函数连续不一定可导，如 f(x) = |x| 在 x = 0 处连续但不可导</li><li><strong>一元函数中:</strong> 可导与可微等价</li><li><strong>多元函数中:</strong> 偏导数存在不保证函数可微</li></ul><p>函数有定义只是讨论函数性质的起点，进一步分析连续性、可导性和可微性对于理解函数行为至关重要。</p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数连续中的间断点类型总结</title>
    <link href="/2025/03/04/kaoyan/shuxue/%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E4%B8%AD%E7%9A%84%E9%97%B4%E6%96%AD%E7%82%B9%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2025/03/04/kaoyan/shuxue/%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E4%B8%AD%E7%9A%84%E9%97%B4%E6%96%AD%E7%82%B9%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="间断点的类型主要根据函数在该点的极限行为进行分类，以下是详细的分类及说明：">间断点的类型主要根据函数在该点的极限行为进行分类，以下是详细的分类及说明：</h2><h3 id="1-第一类间断点（左右极限均存在）"><strong>1. 第一类间断点（左右极限均存在）</strong></h3><h3 id="a-可去间断点（Removable-Discontinuity）"><strong>(a) 可去间断点（Removable Discontinuity）</strong></h3><ul><li><strong>特点</strong>：<ul><li>函数在该点的左极限和右极限存在且相等，但函数值不等于该极限，或函数在该点无定义。</li><li>通过重新定义或修正函数值可使函数在该点连续。</li></ul></li><li><strong>示例</strong>：<br>$f(x) = \frac{\sin x}{x} \quad (x \neq 0)$<br>在 $\ ( x=0 )$ 处无定义，但 $\ (\lim_{x \to 0} f(x) = 1)$，补充定义 $\ ( f(0) = 1 )$ 后连续。</li></ul><h3 id="b-跳跃间断点（Jump-Discontinuity）"><strong>(b) 跳跃间断点（Jump Discontinuity）</strong></h3><ul><li><strong>特点</strong>：<ul><li>左极限和右极限均存在，但两者不相等。</li><li>函数图像在该点出现“跳跃”。</li></ul></li><li><strong>示例</strong>：<br>$\ [<br>f(x) =<br>\begin{cases}<br>x + 1 &amp; x \geq 0, \<br>x - 1 &amp; x &lt; 0<br>\end{cases}<br>]$<br>在 $\ ( x=0 )$ 处，左极限为 $\ (-1)$，右极限为 $\ (1)$，形成跳跃。</li></ul><hr><h3 id="2-第二类间断点（至少一侧极限不存在）"><strong>2. 第二类间断点（至少一侧极限不存在）</strong></h3><h3 id="以下是第二类间断点的两个主要类型：">以下是第二类间断点的两个主要类型：</h3><h3 id="a-无穷间断点（Infinite-Discontinuity）"><strong>(a) 无穷间断点（Infinite Discontinuity）</strong></h3><p><strong>特点</strong>：</p><p>当 <code>x</code> 趋近于该点时，函数值趋向正无穷或负无穷。</p><p>通常伴随垂直渐近线。</p><p><strong>示例</strong>：当 <code>x → 0</code> 时，函数 <code>$f(x) = \frac&#123;1&#125;&#123;x&#125;$</code> 的值趋向 <code>±∞</code>。</p><h3 id="b-振荡间断点（Oscillatory-Discontinuity）"><strong>(b) 振荡间断点（Oscillatory Discontinuity）</strong></h3><p><strong>特点</strong>：</p><p>函数在该点附近无限振荡，导致极限不存在。</p><p>常见于涉及三角函数或周期函数的复杂表达式中。</p><p><strong>示例</strong>：考虑函数 <code>$f(x) = sin(\frac&#123;1&#125;&#123;x&#125;)$</code> 当 <code>x → 0</code> 时，函数值在 <code>[-1,1]</code> 之间无限振荡，因此极限不存在。</p><hr><h3 id="3-其他特殊类型（补充说明）"><strong>3. 其他特殊类型（补充说明）</strong></h3><h3 id="混合型间断点"><strong>混合型间断点</strong></h3><ul><li><strong>特点</strong>：<ul><li>结合多种不连续行为，例如一侧趋向无穷，另一侧振荡。</li></ul></li><li><strong>示例</strong>：<br>$\ <br>f(x) =<br>\begin{cases}<br>\frac{1}{x} &amp; x &gt; 0, \<br>\sin\left(\frac{1}{x}\right) &amp; x &lt; 0<br>\end{cases}$<br>在 $\ ( x=0 )$ 处，右侧趋向 $\ ( +\infty )，$左侧振荡。</li></ul><h3 id="本质不连续点（Essential-Discontinuity）"><strong>本质不连续点（Essential Discontinuity）</strong></h3><ul><li><strong>别名</strong>：部分文献将第二类间断点统称为本质不连续点。</li></ul><hr><h3 id="总结表格"><strong>总结表格</strong></h3><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>可去间断点</strong></td><td>极限存在但函数值不符未定义</td><td>$\ \frac{\sin x}{x}$</td></tr><tr><td><strong>跳跃间断点</strong></td><td>左右极限存在但不相等</td><td>分段函数跳跃点</td></tr><tr><td><strong>无穷间断点</strong></td><td>函数趋向无穷大或无穷小</td><td>$\ \frac{1}{x}$</td></tr><tr><td><strong>振荡间断点</strong></td><td>函数无限振荡，极限不存在</td><td>$\ \sin\left(\frac{1}{x}\right)$</td></tr></tbody></table><hr><h3 id="关键区别"><strong>关键区别</strong></h3><ul><li><strong>第一类 vs 第二类</strong>：<br>第一类间断点的左右极限均存在（可比较大小），第二类至少一侧不存在或趋向无穷。</li><li><strong>可修复性</strong>：<br>仅可去间断点可通过修正函数值恢复连续性。</li></ul><p>通过以上分类，可系统分析函数在不同点的不连续行为。</p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3月份半个月学习计划</title>
    <link href="/2025/03/01/kaoyan/guihua/3%E6%9C%88%E4%BB%BD%E5%8D%8A%E4%B8%AA%E6%9C%88%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <url>/2025/03/01/kaoyan/guihua/3%E6%9C%88%E4%BB%BD%E5%8D%8A%E4%B8%AA%E6%9C%88%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>以下是重新优化后的<strong>15天考研数学一（高数核心）与数据结构系统学习计划</strong>，<strong>移除概率论</strong>，全面覆盖高数重点章节（包括多元微积分、曲线曲面积分、无穷级数等），并保持数据结构每日3-4小时系统学习。计划按**&quot;基础-强化-综合&quot;三阶段**推进，确保扎实掌握。</p><hr><h3 id="调整后核心策略"><strong>调整后核心策略</strong></h3><ol><li><strong>优先级</strong>：数学一高数（70%）+ 数据结构（30%），每天学习10-12小时</li><li><strong>高数重点</strong>：极限→一元微积分→多元微积分→重积分→曲线曲面积分→级数→微分方程</li><li><strong>数据结构</strong>：线性表→树→图→排序/查找→真题，每日代码实操</li><li><strong>学习逻辑</strong>：视频+教材+题型分类+错题本，拒绝遗漏核心考点</li></ol><hr><h3 id="每日作息强化版"><strong>每日作息强化版</strong></h3><table><thead><tr><th>时间段</th><th>内容</th></tr></thead><tbody><tr><td>7:00-8:00</td><td>起床+背诵公式（如格林公式、DFS代码模板）</td></tr><tr><td>8:30-12:00</td><td>数学攻坚（视频+例题）</td></tr><tr><td>14:00-17:00</td><td>数据结构系统学习（教材+代码）</td></tr><tr><td>19:00-21:00</td><td>数学/数据结构交叉刷题</td></tr><tr><td>21:30-22:30</td><td>错题整理+Anki记忆卡</td></tr></tbody></table><hr><h3 id="第一阶段：基础框架搭建（Day-1-5）"><strong>第一阶段：基础框架搭建（Day 1-5）</strong></h3><h3 id="Day-1-2：高数极限与连续-数据结构线性表"><strong>Day 1-2：高数极限与连续 + 数据结构线性表</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>张宇/武忠祥极限视频（1.5倍速，重点：泰勒展开、夹逼定理）</li><li>《复习全书》例题（极限存在性证明、∞/∞型计算）</li></ul></li><li>下午2h：<ul><li>刷《660题》极限部分（题1-30）+ 错题整理</li></ul></li><li>晚上1h：<ul><li>默写等价无穷小替换表、泰勒公式到x³项</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>顺序表与链表操作（插入/删除时间复杂度）</li><li>手写代码：单链表反转（LeetCode 206）、合并有序链表（LeetCode 21）</li></ul></li><li>晚上1h：<ul><li>王道选择题（链表特性与应用场景）</li></ul></li></ul></li></ul><h3 id="Day-3-4：高数一元微分学-数据结构栈与队列"><strong>Day 3-4：高数一元微分学 + 数据结构栈与队列</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>武忠祥导数应用视频（极值、凹凸性、渐近线）</li><li>《复习全书》例题（中值定理证明题）</li></ul></li><li>下午2h：<ul><li>刷《660题》导数部分（题31-60）+ 总结辅助函数构造法</li></ul></li><li>晚上1h：<ul><li>整理导数公式表（参数方程、隐函数求导）</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>栈实现队列（LeetCode 232）、循环队列判满/判空</li><li>手写代码：括号匹配（LeetCode 20）</li></ul></li><li>晚上1h：<ul><li>王道选择题（栈与队列的典型应用）</li></ul></li></ul></li></ul><h3 id="Day-5：高数一元积分学-数据结构树基础"><strong>Day 5：高数一元积分学 + 数据结构树基础</strong></h3><ul><li><strong>数学任务</strong>（7小时）：<ul><li>上午4h：<ul><li>张宇积分技巧视频（分部积分、三角代换）</li><li>《复习全书》例题（定积分几何应用、反常积分）</li></ul></li><li>下午2h：<ul><li>刷《660题》积分部分（题81-110）</li></ul></li><li>晚上1h：<ul><li>整理积分公式表（如∫√(a²-x²)dx）</li></ul></li></ul></li><li><strong>数据结构</strong>（3小时）：<ul><li>下午穿插2h：<ul><li>二叉树遍历（先序/中序递归与非递归）</li><li>手写代码：中序非递归遍历（栈实现）</li></ul></li><li>晚上1h：<ul><li>王道选择题（二叉树节点数计算）</li></ul></li></ul></li></ul><hr><h3 id="第二阶段：高数核心强化（Day-6-10）"><strong>第二阶段：高数核心强化（Day 6-10）</strong></h3><h3 id="Day-6-7：高数多元微分学-数据结构树应用"><strong>Day 6-7：高数多元微分学 + 数据结构树应用</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>武忠祥多元微分视频（偏导数、全微分、方向导数）</li><li>《复习全书》例题（隐函数求导、条件极值）</li></ul></li><li>下午2h：<ul><li>刷《660题》多元微分部分（题200-230）</li></ul></li><li>晚上1h：<ul><li>总结梯度、方向导数与极值的关系</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>平衡二叉树（AVL树旋转）、二叉搜索树验证（LeetCode 98）</li></ul></li><li>晚上1h：<ul><li>王道选择题（AVL树插入调整步骤）</li></ul></li></ul></li></ul><h3 id="Day-8-9：高数重积分-数据结构图基础"><strong>Day 8-9：高数重积分 + 数据结构图基础</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>张宇重积分视频（二重/三重积分计算、极坐标/柱坐标变换）</li><li>《复习全书》例题（交换积分次序、奇偶性简化）</li></ul></li><li>下午2h：<ul><li>刷《660题》重积分部分（题240-270）</li></ul></li><li>晚上1h：<ul><li>整理对称性简化技巧（如轮换对称性）</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>图的存储（邻接矩阵/邻接表）、DFS/BFS代码实现</li><li>手写代码：课程表拓扑排序（LeetCode 207）</li></ul></li><li>晚上1h：<ul><li>王道选择题（DFS与BFS应用场景）</li></ul></li></ul></li></ul><h3 id="Day-10：高数曲线曲面积分-数据结构排序算法"><strong>Day 10：高数曲线曲面积分 + 数据结构排序算法</strong></h3><ul><li><strong>数学任务</strong>（7小时）：<ul><li>上午4h：<ul><li>武忠祥曲线积分视频（第一/二型曲线积分、格林公式）</li><li>《复习全书》例题（参数化计算、斯托克斯公式）</li></ul></li><li>下午2h：<ul><li>刷《660题》曲线曲面积分部分（题280-310）</li></ul></li><li>晚上1h：<ul><li>总结高斯公式与散度、旋度的联系</li></ul></li></ul></li><li><strong>数据结构</strong>（3小时）：<ul><li>下午穿插2h：<ul><li>快速排序/堆排序非递归实现、稳定性分析</li><li>手写代码：快速排序分区函数（Hoare法）</li></ul></li><li>晚上1h：<ul><li>王道选择题（排序算法时间复杂度对比）</li></ul></li></ul></li></ul><hr><h3 id="第三阶段：综合冲刺（Day-11-15）"><strong>第三阶段：综合冲刺（Day 11-15）</strong></h3><h3 id="Day-11-12：高数无穷级数-数据结构查找算法"><strong>Day 11-12：高数无穷级数 + 数据结构查找算法</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>张宇级数视频（正项级数、幂级数求和、傅里叶级数）</li><li>《复习全书》例题（收敛性判别、展开式求系数）</li></ul></li><li>下午2h：<ul><li>刷《660题》级数部分（题320-350）</li></ul></li><li>晚上1h：<ul><li>整理常见展开式（如1/(1-x)=∑xⁿ, |x|&lt;1）</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>哈希表冲突处理（拉链法、开放定址法）</li><li>手写代码：LRU缓存（LeetCode 146）</li></ul></li><li>晚上1h：<ul><li>王道选择题（B树与B+树差异）</li></ul></li></ul></li></ul><h3 id="Day-13-14：高数真题模拟-数据结构真题"><strong>Day 13-14：高数真题模拟 + 数据结构真题</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>限时3h完成2020年真题</li><li>4h逐题分析错因（重点：曲线积分与级数大题）</li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>408真题（2015-2020数据结构大题）</li><li>重点：二叉树非递归遍历、图最短路径</li></ul></li><li>晚上1h：<ul><li>复盘代码边界条件（如指针判空、循环终止）</li></ul></li></ul></li></ul><h3 id="Day-15：总复习与补漏"><strong>Day 15：总复习与补漏</strong></h3><ul><li><strong>数学</strong>（7小时）：<ul><li>上午4h：默写核心公式（从极限到曲面积分）</li><li>下午3h：重做高数错题（如格林公式应用）</li></ul></li><li><strong>数据结构</strong>（3小时）：<ul><li>系统复盘线性表→图→排序</li><li>手写代码：二叉树层序遍历（LeetCode 102）</li></ul></li></ul><hr><h3 id="每日作息强化版-2"><strong>每日作息强化版</strong></h3><table><thead><tr><th>时间段</th><th>内容</th></tr></thead><tbody><tr><td>7:00-8:00</td><td>起床+背诵公式（如格林公式、DFS代码模板）</td></tr><tr><td>8:30-12:00</td><td>数学攻坚（视频+例题）</td></tr><tr><td>14:00-17:00</td><td>数据结构系统学习（教材+代码）</td></tr><tr><td>19:00-21:00</td><td>数学/数据结构交叉刷题</td></tr><tr><td>21:30-22:30</td><td>错题整理+Anki记忆卡</td></tr></tbody></table><hr><h3 id="关键执行原则"><strong>关键执行原则</strong></h3><ol><li><strong>高数优先级</strong>：若时间紧张，优先完成<strong>曲线曲面积分</strong>和<strong>级数</strong>，这两部分是数一特有且难度较高的考点</li><li><strong>数据结构代码</strong>：每日至少手写1题，重点训练<strong>非递归遍历</strong>和<strong>算法应用</strong>（如拓扑排序）</li><li><strong>错题本</strong>：按章节分类记录错题，每晚睡前回顾10分钟</li><li><strong>健康管理</strong>：每学习1小时休息5分钟，每天保证6小时睡眠</li></ol><p><strong>按此计划，15天内可系统攻克高数全部核心内容，并保持数据结构代码手感！</strong> 如需进一步细化某部分（如曲线积分参数化方法），请随时告知！</p>]]></content>
    
    
    <categories>
      
      <category>复习规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天一题蓝桥杯：报数游戏</title>
    <link href="/2024/10/16/lanqiao/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E6%8A%A5%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/10/16/lanqiao/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E6%8A%A5%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1>今日蓝桥杯题目</h1><p>小蓝和朋友们在玩一个报数游戏。由于今年是2024 年，他们决定要从小到大轮流报出是20 或 24倍数的正整数。前10 个被报出的数是：20,24,40,48,60,72,80,96,100,120。请问第202420242024 个被报出的数是多少?</p><h2 id="问题背景">问题背景</h2><p><strong>目标</strong>：找出第 ( n ) 个是 <strong>20</strong> 或 <strong>24</strong> 的倍数的正整数，按从小到大的顺序排列，且不重复。</p><p><strong>示例</strong>：</p><ul><li>前10个被报出的数是：20, 24, 40, 48, 60, 72, 80, 96, 100, 120。</li></ul><h1>为什么使用二分查找？</h1><p>在处理这样的问题时，直接枚举所有满足条件的数直到找到第 ( n ) 个数是不现实的，尤其当 ( n ) 很大（如 ( n = 202420242024 )）时。因此，我们需要一种更高效的方法来定位目标数的位置。<strong>二分查找</strong> 是一种适合此类问题的高效算法。</p><h2 id="二分查找的基本原理">二分查找的基本原理</h2><p><strong>二分查找</strong> 是一种在有序数组中查找特定元素的算法，其基本思想是通过不断将搜索范围缩小一半来快速定位目标元素。虽然在这个问题中，我们不是在一个固定的数组中查找元素，而是在一个按特定规则生成的数列中查找第 ( n ) 个元素，但二分查找的思想仍然适用。</p><h2 id="应用于本问题的二分查找步骤">应用于本问题的二分查找步骤</h2><ol><li><p><strong>定义搜索范围</strong>：</p><ul><li><strong>左界（Left）</strong>：最小可能的数，通常设为 1。</li><li><strong>右界（Right）</strong>：最大可能的数，可以初步设为 $( n \times \text{max}(a, b) )$。在本例中，( a = 20 )，( b = 24 )，所以右界可以设为 ( n \times 24 )。</li></ul></li><li><p><strong>计算中点</strong>：</p><ul><li>计算当前搜索范围的中点 $( \text{mid} = \left\lfloor \frac{\text{left} + \text{right}}{2} \right\rfloor )$。</li></ul></li><li><p><strong>计算中点位置的满足条件的数的数量</strong>：</p><ul><li>使用容斥原理计算不超过 $( \text{mid} )$ 的 <strong>20</strong> 或 <strong>24</strong> 的倍数的数量 $( C(\text{mid}) )$：<br>$$<br>C(\text{mid}) = \left\lfloor \frac{\text{mid}}{20} \right\rfloor + \left\lfloor \frac{\text{mid}}{24} \right\rfloor - \left\lfloor \frac{\text{mid}}{120} \right\rfloor<br>$$<br>其中，<strong>120</strong> 是 <strong>20</strong> 和 <strong>24</strong> 的最小公倍数（LCM）。</li></ul></li><li><p><strong>调整搜索范围</strong>：</p><ul><li><strong>如果 $( C(\text{mid}) &lt; n )$</strong>：<ul><li>说明第 ( n ) 个数位于 ( \text{mid} ) 右侧，因此将左界设为 ( \text{mid} + 1 )。</li></ul></li><li><strong>否则（$( C(\text{mid}) \geq n )$</strong>：<ul><li>说明第 $( n ) 个数位于 ( \text{mid} )$ 左侧或就是 $( \text{mid} )$，因此将右界设为 $( \text{mid} )$。</li></ul></li></ul></li><li><p><strong>重复步骤 2-4</strong>，直到左界等于右界。</p></li><li><p><strong>最终结果</strong>：</p><ul><li>当左界与右界相等时，该值即为第 ( n ) 个满足条件的数。</li></ul></li></ol><h2 id="为什么-C-x-n-表示-x-太小？">为什么 $( C(x) &lt; n ) 表示 ( x )$ 太小？</h2><h3 id="定义计数函数-C-x">定义计数函数 $( C(x) )$</h3><p>对于任意正整数 ( x )，( C(x) ) 表示不超过 ( x ) 的数中，既是 <strong>20</strong> 或 <strong>24</strong> 的倍数的数的数量：<br>$$<br>C(x) = \left\lfloor \frac{x}{20} \right\rfloor + \left\lfloor \frac{x}{24} \right\rfloor - \left\lfloor \frac{x}{120} \right\rfloor<br>$$</p><h3 id="二分查找的目标">二分查找的目标</h3><p>我们希望找到最小的 ( x )，使得 ( C(x) = n )。换句话说，找到第 ( n ) 个满足条件的数，即第 ( n ) 个 <strong>20</strong> 或 <strong>24</strong> 的倍数。</p><h3 id="搜索过程中的判断">搜索过程中的判断</h3><ul><li><p><strong>如果 $( C(\text{mid}) &lt; n )$</strong>：</p><ul><li>说明在 ( 1 ) 到 $( \text{mid} )$ 之间，只有 $( C(\text{mid}) )$ 个数满足条件，但我们需要第 ( n ) 个数。</li><li>因此，第 ( n ) 个数 <strong>必定大于 $( \text{mid} )$</strong>。</li><li><strong>结论</strong>：当前的 $( \text{mid} )$ 太小，无法包含第 ( n ) 个数，需要在更大的范围内继续搜索。</li></ul></li><li><p><strong>如果 $( C(\text{mid}) \geq n )$</strong>：</p><ul><li>说明第 ( n ) 个数 <strong>可能在 $( \text{mid} )$ 之前</strong>，也可能就是 $( \text{mid} )$ 本身。</li><li><strong>结论</strong>：需要在较小的范围内继续搜索，缩小右界。</li></ul></li></ul><h2 id="直观理解">直观理解</h2><p>想象一下你正在寻找一个特定位置的数，例如第1000个满足条件的数。通过二分查找，你每次选择一个中间值并计算在这个中间值之前有多少个满足条件的数：</p><ul><li><strong>如果计算出的数量 $( C(\text{mid}) )$ 比目标 ( n ) 小</strong>，说明第 ( n ) 个数还没到，需要往更大的方向看。</li><li><strong>如果计算出的数量 $( C(\text{mid}) )$ 大于或等于目标 ( n )</strong>，说明目标数已经在 $( \text{mid} )$ 或更小的范围内，可以缩小搜索范围，继续在较小的范围内寻找精确的位置。</li></ul><h2 id="示例演示">示例演示</h2><p><strong>目标</strong>：找到第10个是 <strong>20</strong> 或 <strong>24</strong> 的倍数的数。</p><ol><li><p><strong>初始化搜索范围</strong>：</p><ul><li>左界 $( \text{left} = 1 )$</li><li>右界 $( \text{right} = 10 \times 24 = 240 )（初步设定为 ( n \times \text{max}(a, b) )）$</li></ul></li><li><p><strong>第一次迭代</strong>：</p><ul><li>中点 $( \text{mid} = \left\lfloor \frac{1 + 240}{2} \right\rfloor = 120 )$</li><li>计算 ( C(120) )：<br>$$<br>C(120) = \left\lfloor \frac{120}{20} \right\rfloor + \left\lfloor \frac{120}{24} \right\rfloor - \left\lfloor \frac{120}{120} \right\rfloor = 6 + 5 - 1 = 10<br>$$</li><li><strong>比较 ( C(120) = 10 ) 与 ( n = 10 )</strong>：<ul><li>因为 $( C(120) \geq n )$，将右界设为 ( 120 )。</li></ul></li></ul></li><li><p><strong>第二次迭代</strong>：</p><ul><li>新的搜索范围：$( \text{left} = 1 )$，$( \text{right} = 120 )$</li><li>中点 $( \text{mid} = \left\lfloor \frac{1 + 120}{2} \right\rfloor = 60 )$</li><li>计算 ( C(60) )：<br>$$<br>C(60) = \left\lfloor \frac{60}{20} \right\rfloor + \left\lfloor \frac{60}{24} \right\rfloor - \left\lfloor \frac{60}{120} \right\rfloor = 3 + 2 - 0 = 5<br>$$</li><li><strong>比较 ( C(60) = 5 ) 与 ( n = 10 )</strong>：<ul><li>因为 ( C(60) &lt; n )，将左界设为 ( 61 )。</li></ul></li></ul></li><li><p><strong>第三次迭代</strong>：</p><ul><li>新的搜索范围：$( \text{left} = 61 )$，$( \text{right} = 120 )$</li><li>中点 $( \text{mid} = \left\lfloor \frac{61 + 120}{2} \right\rfloor = 90 )$</li><li>计算 ( C(90) )：<br>$$<br>C(90) = \left\lfloor \frac{90}{20} \right\rfloor + \left\lfloor \frac{90}{24} \right\rfloor - \left\lfloor \frac{90}{120} \right\rfloor = 4 + 3 - 0 = 7<br>$$</li><li><strong>比较 ( C(90) = 7 ) 与 ( n = 10 )</strong>：<ul><li>因为 ( C(90) &lt; n )，将左界设为 ( 91 )。</li></ul></li></ul></li><li><p><strong>继续迭代</strong>，直到左界等于右界：</p><ul><li>最终会发现，当 $( \text{left} = 120 )$ 时，( C(120) = 10 )，满足条件。</li><li><strong>结果</strong>：( x = 120 )</li></ul></li></ol><p><strong>验证结果</strong>：</p><ul><li>前10个数确实是：20, 24, 40, 48, 60, 72, 80, 96, 100, 120。</li><li>因此，算法正确地找到了第10个数是 <strong>120</strong>。</li></ul><h2 id="为什么二分查找有效？">为什么二分查找有效？</h2><ul><li><strong>有序性</strong>：满足条件的数按升序排列，二分查找依赖于这一特性，通过比较中点位置的数的数量与目标 ( n ) 之间的关系，逐步缩小搜索范围。</li><li><strong>效率</strong>：二分查找的时间复杂度为 $( O(\log N) )$，远比线性搜索（时间复杂度 ( O(N) )）高效，特别是在 ( N ) 很大的情况下。</li></ul><h2 id="二分查找在此问题中的关键点">二分查找在此问题中的关键点</h2><ol><li><p><strong>定义搜索范围</strong>：</p><ul><li>初始左界设为 1，右界设为 $( n \times \text{max}(a, b) )$。</li><li>在本例中，( a = 20 )，( b = 24 )，所以右界可以设为 $( n \times 24 )$。</li></ul></li><li><p><strong>中点计算与比较</strong>：</p><ul><li>通过计算中点 $( \text{mid} )$ 的位置，利用容斥原理计算不超过 $( \text{mid} )$ 的满足条件的数的数量 $( C(\text{mid}) )$。</li><li><strong>如果 $( C(\text{mid}) &lt; n )$</strong>，则更新左界为 $( \text{mid} + 1 )$。</li><li><strong>否则</strong>，将右界设为 $( \text{mid} )$。</li></ul></li><li><p><strong>终止条件</strong>：</p><ul><li>当左界等于右界时，搜索结束，左界（或右界）即为第 ( n ) 个满足条件的数。</li></ul></li></ol><h1>解决代码示例</h1><p>以下是一个完整的 Python 实现，结合了二分查找和容斥原理，用于精确找到第 ( n ) 个是 <strong>a</strong> 或 <strong>b</strong> 的倍数的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcm</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算两个数的最小公倍数&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> gcd<br>    <span class="hljs-keyword">return</span> a * b // gcd(a, b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_multiples</span>(<span class="hljs-params">x, a, b</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算不超过 x 的 a 或 b 的倍数的数量&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> x // a + x // b - x // lcm(a, b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_nth_number</span>(<span class="hljs-params">n, a, b</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;使用二分查找找到第 n 个是 a 或 b 的倍数的数&quot;&quot;&quot;</span><br>    left = <span class="hljs-number">1</span><br>    right = n * <span class="hljs-built_in">max</span>(a, b)  <span class="hljs-comment"># 初始右界设为 n * max(a, b)</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        mid = (left + right) // <span class="hljs-number">2</span><br>        current_count = count_multiples(mid, a, b)<br>        <span class="hljs-keyword">if</span> current_count &lt; n:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid<br>    <span class="hljs-keyword">return</span> left<br><br><span class="hljs-comment"># 示例 1: 寻找第 202420242024 个是 20 或 24 的倍数的数</span><br>n = <span class="hljs-number">202420242024</span><br>a = <span class="hljs-number">20</span><br>b = <span class="hljs-number">24</span><br>result = find_nth_number(n, a, b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第 <span class="hljs-subst">&#123;n&#125;</span> 个被报出的数是: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)  <span class="hljs-comment"># 输出: 2429042904288</span><br><br><span class="hljs-comment"># 示例 2: 寻找第 1000 个是 10 或 15 的倍数的数</span><br>n = <span class="hljs-number">1000</span><br>a = <span class="hljs-number">10</span><br>b = <span class="hljs-number">15</span><br>result = find_nth_number(n, a, b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第 <span class="hljs-subst">&#123;n&#125;</span> 个被报出的数是: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)  <span class="hljs-comment"># 输出: 7500</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯学习</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天一题蓝桥杯：单词博弈</title>
    <link href="/2024/10/15/lanqiao/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88/"/>
    <url>/2024/10/15/lanqiao/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88/</url>
    
    <content type="html"><![CDATA[<h1>今日蓝桥杯题目</h1><p>夏日夜晚，小蓝和小桥在蓝桥公园散步。在蜿蜒的小路上，他们发现了一堆单词。</p><p>小蓝和小桥对这些单词饶有兴致，于是开始收集它们：小蓝收集了n 个单词，小桥收集了m 个单词。收集完单词后，他们决定玩一个游戏。</p><p>游戏规则如下：每一回合，玩家需要从自己收集到的单词中说出一个单词。所说的单词必须满足以下条件：该单词的字典序大小要比上一个单词大，并且该单词要么与上一个单词以相同的字母开头，要么以字母表中紧随其后的字母开头。</p><p>例如，如果上一个单词是 apple，那么接下来的单词可以是：</p><p>以相同字母 a 开头的单词，如：apply。以字母表中紧随 a 之后的字母 b 开头的单词，如 banana。<br>如果某个玩家无法满足上述条件，则该玩家输掉游戏。</p><p>小蓝和小桥轮流进行，由小蓝率先开始。</p><p>已知小蓝第一次会说出自己单词堆中按字典序排列最小的单词。请问，如果小蓝和小桥都按照最优策略进行游戏，谁会获胜？</p><h1>题解</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br>n , m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>a =[<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>b = [<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>a.sort(reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#这是正序，倒序就是reverse：true</span><br>b.sort(reverse= <span class="hljs-literal">True</span>) <br><br>flag = <span class="hljs-literal">True</span><br>pre = a.pop()<br><br><span class="hljs-keyword">while</span>(flag <span class="hljs-keyword">and</span> a) <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> flag <span class="hljs-keyword">and</span> b):<br>    <span class="hljs-keyword">if</span> flag:  <span class="hljs-comment">#flag为true的时候，这时候小蓝已经说过一个了， 所以轮到小桥</span><br>        word = a.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span> ) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">False</span><br>            pre = word<br>    <span class="hljs-keyword">else</span>:<br>        word = b.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span>) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">True</span><br>            pre = word<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;L&#x27;</span>) <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Q&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>接下来是hexo的内置代码块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br>n , m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>a =[<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>b = [<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>a.sort(reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#这是正序，倒序就是reverse：true</span><br>b.sort(reverse= <span class="hljs-literal">True</span>) <br><br>flag = <span class="hljs-literal">True</span><br>pre = a.pop()<br><br><span class="hljs-keyword">while</span>(flag <span class="hljs-keyword">and</span> a) <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> flag <span class="hljs-keyword">and</span> b):<br>    <span class="hljs-keyword">if</span> flag:  <span class="hljs-comment">#flag为true的时候，这时候小蓝已经说过一个了， 所以轮到小桥</span><br>        word = a.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span> ) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">False</span><br>            pre = word<br>    <span class="hljs-keyword">else</span>:<br>        word = b.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span>) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">True</span><br>            pre = word<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;L&#x27;</span>) <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Q&#x27;</span>)<br></code></pre></td></tr></table></figure><h1>学习到了什么？</h1><ul><li><p>字典序<br>什么是字典序，就是按照字典顺序进行比较排序的结果，比如说两个单词app，apple。从第一个字母开始进行比较，如果一样就继续对比下一个字母，直到不一样。比如到了app以后，apple还有le，而app则没有了，app的字典序就比apple要小。排序就是’app&lt;apple’。</p></li><li><p>字典序排序<br>如果有很多个单词进行字典序比较，是不是会比较头疼？但是实际上python和c++中已经内置了字典序排序，可以直接使用<code>sort()</code>或者是<code>reverse()</code>函数直接对多个对象进行字典序排序。<code>sort()</code>是从小到大进行排序，反之从大到小。</p></li><li><p>列表推导式<br>代码里用到列表推导式：<code>a = [input() for _ in range(n)]</code>，或者其他的形式<code>a = list(map(int , input().split()))</code>，这样的式子简洁高效，要记住。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
