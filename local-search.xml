<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>反三角替换规则</title>
    <link href="/2025/03/26/%E5%8F%8D%E4%B8%89%E8%A7%92%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99/"/>
    <url>/2025/03/26/%E5%8F%8D%E4%B8%89%E8%A7%92%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1>转换完成文档</h1><p>在三角方程中，出现 $\pi - \arcsin x$ 的解是因为 <strong>正弦函数在 $[0, \pi]$ 区间内的对称性</strong>。以下是详细解释：</p><hr><h3 id="1-正弦函数的图像特性"><strong>1. 正弦函数的图像特性</strong></h3><p>正弦函数 $\sin \theta$ 在区间 $[0, \pi]$ 内具有对称性：</p><ul><li>当 $\theta \in \left[ 0, \frac{\pi}{2} \right]$，$\sin \theta$ 单调递增。</li><li>当 $\theta \in \left[ \frac{\pi}{2}, \pi \right]$，$\sin \theta$ 单调递减，且满足：<br>$$<br>\sin(\pi - \theta) = \sin \theta \quad (\theta \in \mathbb{R}).<br>$$</li></ul><hr><h3 id="2-方程-sin-theta-x-的解"><strong>2. 方程 $\sin \theta = x$ 的解</strong></h3><p>对于方程 $\sin \theta = x$（其中 $x \in [-1, 1]$），其解为：<br>$$<br>\theta = \arcsin x + 2k\pi \quad \text{或} \quad \theta = \pi - \arcsin x + 2k\pi \quad (k \in \mathbb{Z}).<br>$$<br><strong>原因</strong>：</p><ul><li><strong>主值解</strong>：$\arcsin x$ 返回的是 $\theta \in \left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$ 的解。</li><li><strong>对称性补充解</strong>：由于 $\sin(\pi - \theta) = \sin \theta$，补充解为 $\pi - \arcsin x$，覆盖 $\theta \in \left[ \frac{\pi}{2}, \frac{3\pi}{2} \right]$ 的情况。</li></ul><hr><h3 id="3-几何解释（单位圆）"><strong>3. 几何解释（单位圆）</strong></h3><p>在单位圆上，若某角度的正弦值为 $x$，则存在两个可能的角度：</p><ol><li><strong>第一象限角</strong>：$\theta_1 = \arcsin x$（位于右半圆）。</li><li><strong>第二象限角</strong>：$\theta_2 = \pi - \arcsin x$（位于左半圆）。<br>这两个角度的正弦值相等（$\sin \theta_1 = \sin \theta_2 = x$），但余弦值相反（$\cos \theta_1 = -\cos \theta_2$）。</li></ol><p><strong>示例</strong>：<br>若 $\sin \theta = \frac{1}{2}$，则解为：<br>$$<br>\theta = \frac{\pi}{6} \quad \text{或} \quad \theta = \pi - \frac{\pi}{6} = \frac{5\pi}{6}.<br>$$</p><hr><h3 id="4-实际应用场景"><strong>4. 实际应用场景</strong></h3><ol><li><p><strong>三角方程求解</strong>：<br>若要求 $\theta \in [0, \pi]$，则需同时考虑 $\arcsin x$ 和 $\pi - \arcsin x$。<br><strong>示例</strong>：解三角形时，若已知两边及非夹角，可能有两解。</p></li><li><p><strong>积分变量替换</strong>：<br>当通过 $x = \sin \theta$ 进行换元时，需根据积分区间选择正确的角度范围（例如，若 $\theta \in \left[ \frac{\pi}{2}, \pi \right]$，则需用 $\pi - \arcsin x$ 表示。</p></li></ol><hr><h3 id="5-常见误区"><strong>5. 常见误区</strong></h3><ul><li><strong>错误结论</strong>：认为 $\arcsin x$ 能覆盖所有解，忽略对称性补充解。</li><li><strong>错误推导</strong>：直接将 $\sin \theta = x$ 写为 $\theta = \arcsin x$，导致遗漏解。</li></ul><hr><h3 id="总结"><strong>总结</strong></h3><table><thead><tr><th><strong>情境</strong></th><th><strong>表达式</strong></th><th><strong>意义</strong></th></tr></thead><tbody><tr><td>主值解（右半圆）</td><td>$\theta = \arcsin x$</td><td>角度位于 $\left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$。</td></tr><tr><td>对称性补充解（左半圆）</td><td>$\theta = \pi - \arcsin x$</td><td>角度位于 $\left[ \frac{\pi}{2}, \frac{3\pi}{2} \right]$。</td></tr></tbody></table><p><strong>核心结论</strong>：<br>$\pi - \arcsin x$ 是方程 $\sin \theta = x$ 的必要补充解，用于覆盖正弦函数在单位圆上的对称性区域。</p><hr><p>✅ 验证报告：</p><ul><li>已转化行内公式：13处</li><li>已调整独立公式：3处</li><li>内容变更检测：0处非公式修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arcsin反三角替换的时候注意事项</title>
    <link href="/2025/03/25/arcsin%E5%8F%8D%E4%B8%89%E8%A7%92%E6%9B%BF%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2025/03/25/arcsin%E5%8F%8D%E4%B8%89%E8%A7%92%E6%9B%BF%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="在将涉及-sin-x-的表达式转换为-arcsin-x-时，需注意以下关键事项：">在将涉及 $\sin x$ 的表达式转换为 $\arcsin x$ 时，需注意以下关键事项：</h2><h3 id="1-定义域与值域的限制"><strong>1. 定义域与值域的限制</strong></h3><ul><li><strong>$\arcsin x$ 的定义域</strong>：仅接受 $x \in [-1, 1]$，超出此范围会导致无定义。</li><li><strong>$\arcsin x$ 的值域</strong>：输出角度范围为 $\left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$。</li></ul><p><strong>示例</strong>：<br>若 $\sin x = 2$，则方程无解，因为 $2 \notin [-1, 1]$。</p><hr><h3 id="2-解的多值性与主值选择"><strong>2. 解的多值性与主值选择</strong></h3><ul><li><strong>$\sin x = y$ 的解</strong>：<br>$$<br>x = \arcsin y + 2k\pi \quad \text{或} \quad x = \pi - \arcsin y + 2k\pi \quad (k \in \mathbb{Z}).<br>$$</li><li>直接写 $x = \arcsin y$ 仅得到主值解（即 $x \in \left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$），可能遗漏其他解。</li></ul><p><strong>示例</strong>：<br>方程 $\sin x = \frac{1}{2}$ 的解为：<br>$$<br>x = \frac{\pi}{6} + 2k\pi \quad \text{或} \quad x = \frac{5\pi}{6} + 2k\pi \quad (k \in \mathbb{Z}).<br>$$</p><hr><h3 id="3-变量替换的合法性"><strong>3. 变量替换的合法性</strong></h3><ul><li><strong>替换 $y = \sin x$</strong> 时，需保证 $y \in [-1, 1]$。</li><li><strong>反向替换 $x = \arcsin y$</strong> 时，需明确 $x$ 的主值范围，避免超出 $\left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$。</li></ul><p><strong>示例</strong>：<br>若 $y = \sin x$ 且 $x \in \left[ \frac{\pi}{2}, \frac{3\pi}{2} \right]$，则反向替换应写为 $x = \pi - \arcsin y$。</p><hr><h3 id="4-代数运算中的常见错误"><strong>4. 代数运算中的常见错误</strong></h3><ul><li><strong>错误操作</strong>：直接对等式两边取 $\arcsin$。<br><strong>正确操作</strong>：需结合三角恒等式和多值性分析。</li></ul><p><strong>反例</strong>：<br>若 $\sin x = \sin y$，不能直接推出 $x = y$，而应为：<br>$$<br>x = y + 2k\pi \quad \text{或} \quad x = \pi - y + 2k\pi \quad (k \in \mathbb{Z}).<br>$$</p><hr><h3 id="5-微积分中的注意事项"><strong>5. 微积分中的注意事项</strong></h3><ul><li><strong>导数公式</strong>：<br>$$<br>\frac{d}{dx} \arcsin x = \frac{1}{\sqrt{1 - x^2}} \quad (x \in (-1, 1)).<br>$$</li><li><strong>积分应用</strong>：<br>积分 $\int \frac{1}{\sqrt{1 - x^2}} , dx = \arcsin x + C$，仅在 $x \in (-1, 1)$ 时有效。</li></ul><hr><h3 id="6-符号与平方根处理"><strong>6. 符号与平方根处理</strong></h3><ul><li><strong>表达式 $\cos(\arcsin x)$</strong>：<br>由于 $\arcsin x \in \left[ -\frac{\pi}{2}, \frac{\pi}{2} \right]$，余弦值非负，故：<br>$$<br>\cos(\arcsin x) = \sqrt{1 - x^2}.<br>$$</li></ul><hr><h3 id="总结"><strong>总结</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>正确做法</strong></th><th><strong>常见错误</strong></th></tr></thead><tbody><tr><td>解方程 $\sin x = y$</td><td>考虑所有解：$x = \arcsin y + 2k\pi$ 或 $\pi - \arcsin y + 2k\pi$</td><td>仅写 $x = \arcsin y$</td></tr><tr><td>替换变量 $y = \sin x$</td><td>确保 $y \in [-1, 1]$，并明确 $x$ 的范围</td><td>忽略 $y$ 的范围或 $x$ 的主值限制</td></tr><tr><td>导数/积分</td><td>检查定义域 $x \in (-1, 1)$</td><td>在 $x = \pm 1$ 处错误应用公式</td></tr></tbody></table><hr><h3 id="关键结论"><strong>关键结论</strong></h3><ul><li><strong>始终验证输入值在 $[-1, 1]$ 内</strong>。</li><li><strong>处理方程时考虑多值性</strong>，避免遗漏解。</li><li><strong>在反向替换或运算中明确角度范围</strong>，确保结果合理性。</li></ul><hr><p>✅ 验证报告：</p><ul><li>已转化行内公式：17处</li><li>已调整独立公式：5处</li><li>内容变更检测：0处非公式修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伽马函数的积分值</title>
    <link href="/2025/03/25/%E4%BC%BD%E9%A9%AC%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%AF%E5%88%86%E5%80%BC/"/>
    <url>/2025/03/25/%E4%BC%BD%E9%A9%AC%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%AF%E5%88%86%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1>转换完成文档</h1><p>这个积分过程的原理是通过变量替换将高斯积分转换为伽马函数（Gamma函数）的形式，从而利用已知的伽马函数值 $$\Gamma\left(\frac{1}{2}\right) = \sqrt{\pi}$$ 简化计算。以下是详细分析和关键步骤：</p><hr><h3 id="1-原始积分分析"><strong>1. 原始积分分析</strong></h3><p>原积分形式为：<br>$$<br>I = -\int_{-\infty}^{+\infty} e^{-2x^2} , dx<br>$$<br>被积函数 (e^{-2x^2}) 是偶函数，且积分区间关于原点对称。因此可以将积分简化为两倍的 <strong>正半轴积分</strong>：<br>$$<br>I = -2 \int_{0}^{+\infty} e^{-2x^2} , dx<br>$$</p><hr><h3 id="2-变量替换（换元法）"><strong>2. 变量替换（换元法）</strong></h3><p>令 (2x^2 = t)，则：<br>$$<br>x = \frac{1}{\sqrt{2}} t^{1/2}, \quad dx = \frac{1}{2\sqrt{2}} t^{-1/2} , dt<br>$$<br>替换变量后，积分变为：<br>$$<br>I = -2 \cdot \frac{1}{2\sqrt{2}} \int_{0}^{+\infty} e^{-t} \cdot t^{-1/2} , dt = -\frac{1}{\sqrt{2}} \int_{0}^{+\infty} e^{-t} t^{-1/2} , dt<br>$$</p><hr><h3 id="3-伽马函数的引入"><strong>3. 伽马函数的引入</strong></h3><p>积分 $$\int_{0}^{+\infty} e^{-t} t^{-1/2} , dt$$ 是伽马函数 $$\Gamma\left(\frac{1}{2}\right)$$ 的定义式：<br>$$<br>\Gamma(z) = \int_{0}^{+\infty} t^{z-1} e^{-t} , dt<br>$$<br>令 (z = \frac{1}{2})，则：<br>$$<br>\Gamma\left(\frac{1}{2}\right) = \int_{0}^{+\infty} t^{-1/2} e^{-t} , dt = \sqrt{\pi}<br>$$</p><hr><h3 id="4-最终结果"><strong>4. 最终结果</strong></h3><p>代入伽马函数的值：<br>$$<br>I = -\frac{1}{\sqrt{2}} \cdot \sqrt{\pi} = -\sqrt{\frac{\pi}{2}}<br>$$</p><hr><h3 id="关键步骤验证"><strong>关键步骤验证</strong></h3><ol><li><p><strong>偶函数对称性</strong>：<br>原积分区间对称，且被积函数为偶函数，因此可简化为两倍正半轴积分。</p></li><li><p><strong>变量替换的合法性</strong>：<br>替换 $(2x^2 = t)$ 后，积分上下限从 $(x=0 \to +\infty)$ 变为 $(t=0 \to +\infty)$，且雅可比行列式 $(\frac{dx}{dt})$ 计算正确。</p></li><li><p><strong>伽马函数性质</strong>：<br>$$\Gamma\left(\frac{1}{2}\right) = \sqrt{\pi}$$ 是已知结果，直接引用。</p></li></ol><hr><h3 id="可能疑问与解答"><strong>可能疑问与解答</strong></h3><ol><li><p><strong>为什么结果有负号？</strong><br>原始积分前有负号（即 $$I = -\int_{-\infty}^{+\infty} \dots$$），因此最终结果为负。若无负号，结果应为 $$\sqrt{\frac{\pi}{2}}$$。</p></li><li><p><strong>为何使用伽马函数？</strong><br>高斯积分 $$\int_{0}^{+\infty} e^{-ax^2} , dx$$ 的标准结果为 $$\frac{1}{2} \sqrt{\frac{\pi}{a}}$$，此处通过变量替换将其转换为伽马函数形式，结果一致。</p></li></ol><hr><h3 id="结论"><strong>结论</strong></h3><p>此过程通过变量替换和伽马函数的性质，将复杂的高斯积分转换为已知结果，最终得：<br>$$<br>I = -\sqrt{\frac{\pi}{2}}<br>$$<br>若原积分无负号，结果应为 $$\sqrt{\frac{\pi}{2}}$$。</p><hr><p>✅ 验证报告：</p><ul><li>已转化行内公式：6处</li><li>已调整独立公式：8处</li><li>内容变更检测：0处非公式修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯抢分算法刷题</title>
    <link href="/2025/03/24/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%8A%A2%E5%88%86%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    <url>/2025/03/24/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%8A%A2%E5%88%86%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="蓝桥杯-7-天速成计划表（直接抄作业）">蓝桥杯 7 天速成计划表（直接抄作业）</h2><h3 id="Day1-3：暴力美学训练营">Day1-3：暴力美学训练营</h3><h4 id="必杀技-1：三层-for-循环爆破">必杀技 1：三层 for 循环爆破</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 经典题解模式（以三数之和为例）</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, n):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j+<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> arr[i]+arr[j]+arr[k] == target:<br>                <span class="hljs-keyword">return</span> [i,j,k]<br></code></pre></td></tr></table></figure><p><img src="/images/image.png" alt="算法示意图"></p><h4 id="必杀技-2：打表法空间换时打法">必杀技 2：打表法空间换时打法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 预生成斐波那契数列（打表法）</span><br>fib = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1000</span>):<br>    fib.append(fib[i-<span class="hljs-number">1</span>] + fib[i-<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p><strong>每日任务</strong>：<br>✅ 暴力破解近 5 年真题 - 日期计算<br>✅ 排列组合高频题 - 骰子概率问题<br>✅ 简单数论题 - 质因数分解</p><h3 id="Day4-7：DFS-BFS-急救包">Day4-7：DFS/BFS 急救包</h3><h4 id="万能模板（迷宫问题）">万能模板（迷宫问题）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">当前状态</span>):<br>    <span class="hljs-keyword">if</span> 终止条件:<br>        <span class="hljs-keyword">return</span><br>    visited[x][y] = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> [(-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)]:<br>        dfs(x+dx, y+dy)<br></code></pre></td></tr></table></figure><p><img src="/images/image1.png" alt="模板"></p><p><strong>重点题型</strong>：<br>▨ 全排列问题（注意剪枝）<br>▨ 迷宫问题<br>▨ 岛屿数量（行列扫描）<br>▨ 路径计数（记忆化搜索）</p><blockquote><p>保命技巧：遇到递归超时的时候立即转记忆化搜索</p></blockquote><h2 id="三、最后-13-天抢分攻略">三、最后 13 天抢分攻略</h2><h3 id="📅-每日作息表">📅 每日作息表</h3><table><thead><tr><th>时间</th><th>任务</th><th>工具</th></tr></thead><tbody><tr><td>7:00-8:30</td><td>背模板 + 重写错题</td><td>错题本 + A4 纸手写</td></tr><tr><td>9:00-12:00</td><td>专题突破（优先 DP 基础）</td><td>蓝桥杯官方训练系统</td></tr><tr><td>14:00-17:00</td><td>全真模考（严格计时）</td><td>2019-2021 年真题</td></tr><tr><td>20:00-22:30</td><td>精研答案 + 优化代码</td><td>GitHub 大佬题解对比</td></tr></tbody></table><h3 id="🚑-五大必考题型急救指南">🚑 五大必考题型急救指南</h3><h4 id="①-动态规划（带注释模板）">① 动态规划（带注释模板）</h4><p>$$ dp[i] = \max(dp[i-1], dp[i-2]+nums[i]) $$</p><ul><li>只背0-1背包和爬楼梯模板</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 0-1背包标准代码</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack</span>(<span class="hljs-params">W, wt, val</span>):<br>    dp = [<span class="hljs-number">0</span>]*(W+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(wt)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W, wt[i]-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-wt[i]] + val[i])<br>    <span class="hljs-keyword">return</span> dp[W]<br></code></pre></td></tr></table></figure><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="动态规划"></p><h4 id="②-贪心算法（20-命中率）">② 贪心算法（20%命中率）</h4><ul><li>记住三个经典场景：区间调度、哈夫曼编码、加油站问题</li></ul><h4 id="③-字符串处理（必考）">③ 字符串处理（必考）</h4><ul><li>Python组直接暴力切片，C++组背书substr+正则表达式基础</li></ul><h4 id="④简单数论（30-命中率）">④简单数论（30%命中率）</h4><ul><li>重点掌握：最大公约数、最小公倍数、闰年判断、质数筛选法</li></ul><h4 id="⑤-日期计算（每年必出：背熟蔡勒公式）">⑤ 日期计算（每年必出：背熟蔡勒公式）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 星期计算公式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">zeller</span>(<span class="hljs-params">y, m, d</span>):<br>    <span class="hljs-keyword">if</span> m &lt; <span class="hljs-number">3</span>:<br>        m += <span class="hljs-number">12</span><br>        y -= <span class="hljs-number">1</span><br>    h = (d + <span class="hljs-number">13</span>*(m+<span class="hljs-number">1</span>)//<span class="hljs-number">5</span> + y + y//<span class="hljs-number">4</span> - y//<span class="hljs-number">100</span> + y//<span class="hljs-number">400</span>) % <span class="hljs-number">7</span><br>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;六&quot;</span>,<span class="hljs-string">&quot;日&quot;</span>,<span class="hljs-string">&quot;一&quot;</span>,<span class="hljs-string">&quot;二&quot;</span>,<span class="hljs-string">&quot;三&quot;</span>,<span class="hljs-string">&quot;四&quot;</span>,<span class="hljs-string">&quot;五&quot;</span>][h]<br></code></pre></td></tr></table></figure><h2 id="四、考场偷分黑科技">四、考场偷分黑科技</h2><ol><li><p><strong>玄学输出</strong><br>遇到不会的题直接输出样例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;3\n1 4 5&quot;</span>)  <span class="hljs-comment"># 样例答案格式</span><br></code></pre></td></tr></table></figure></li><li><p><strong>输入加速（C++ 版）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); <br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 加速 300%</span><br></code></pre></td></tr></table></figure></li><li><p><strong>卡时间神操作</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[!WARNING]<br>▨ 最后 5 分钟必须检查换行符<br>▨ 用文本对比工具验证输出格式<br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>博弈论精髓</strong>：蓝桥杯是策略游戏而非能力测试，当你开始执行本计划时，已战胜 50% 的裸考者。立即启动暴力美学程序冲击省奖！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研记录3月1日</title>
    <link href="/2025/03/21/%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%953%E6%9C%881%E6%97%A5/"/>
    <url>/2025/03/21/%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%953%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>由于今日起晚了，所以重新规划1和2号的学习安排</p><hr><h3 id="3月1日（剩余时间：16-30-24-00）"><strong>3月1日（剩余时间：16:30-24:00）</strong></h3><p><strong>总目标</strong>：完成数学极限核心概念+数据结构线性表基础</p><p><strong>总时长</strong>：7.5小时（含休息）</p><h3 id="16-30-19-00：数学极限基础（2-5h）"><strong>16:30-19:00：数学极限基础（2.5h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>速看张宇/武忠祥极限基础课</strong>（1h，1.5倍速，重点听“泰勒展开”和“洛必达法则”）</li><li><strong>刷《复习全书》极限例题</strong>（3道经典题，如“sinx/x→1的证明”、“∞-∞型极限计算”）</li><li><strong>整理极限公式表</strong>（手写：等价无穷小替换、泰勒公式到x³项）</li></ol></li><li><strong>重点</strong>：<br>确保理解极限计算逻辑，暂不追求刷题量，先掌握核心方法。</li></ul><h3 id="19-30-21-30：数据结构线性表（2h）"><strong>19:30-21:30：数据结构线性表（2h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>学习顺序表与链表的区别</strong>（王道教材2.1-2.2节，30分钟）</li><li><strong>手写单链表反转代码</strong>（LeetCode 206，反复写3遍直到无bug，1h）</li><li><strong>做王道选择题</strong>（仅做“链表插入删除”相关题，5道，30分钟）</li></ol></li><li><strong>重点</strong>：<br>必须能默写链表反转代码，理解指针操作逻辑。</li></ul><h3 id="21-30-24-00：数学极限巩固-错题（2-5h）"><strong>21:30-24:00：数学极限巩固+错题（2.5h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>刷《660题》极限部分</strong>（精选10题，题号1-10，1h）</li><li><strong>分析错题</strong>（记录错题原因，如“泰勒展开项数不足”，30分钟）</li><li><strong>默写公式+明早复习清单</strong>（30分钟）</li></ol></li></ul><hr><h3 id="3月2日（全天）"><strong>3月2日（全天）</strong></h3><p><strong>总目标</strong>：完成数学导数基础+数据结构栈与队列</p><p><strong>总时长</strong>：12小时（含休息）</p><h3 id="8-30-11-30：数学导数与微分（3h）"><strong>8:30-11:30：数学导数与微分（3h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>武忠祥导数应用视频</strong>（1.5h，重点看“导数定义”和“极值判定”）</li><li><strong>手写导数公式表</strong>（包括参数方程求导、隐函数求导，30分钟）</li><li><strong>刷《660题》导数部分</strong>（题号31-40，5题，1h）</li></ol></li></ul><h3 id="14-00-17-00：数据结构栈与队列（3h）"><strong>14:00-17:00：数据结构栈与队列（3h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>栈的应用</strong>（括号匹配原理，手写代码：LeetCode 20，1h）</li><li><strong>循环队列实现</strong>（重点：判空条件<code>front == rear</code>，判满条件<code>(rear+1)%size == front</code>，1h）</li><li><strong>用栈实现队列</strong>（LeetCode 232，1h）</li></ol></li></ul><h3 id="19-00-21-00：数学导数强化（2h）"><strong>19:00-21:00：数学导数强化（2h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>总结“证明题”构造辅助函数的方法</strong>（如用罗尔定理证明根的存在性，1h）</li><li><strong>重做错题+整理导数应用框架</strong>（如极值、凹凸性、渐近线，1h）</li></ol></li></ul><h3 id="21-30-23-30：数据结构真题-复盘（2h）"><strong>21:30-23:30：数据结构真题+复盘（2h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>做408真题（2016年数据结构选择题）</strong>（10题，30分钟）</li><li><strong>手写循环队列代码</strong>（确保能处理边界条件，1h）</li><li><strong>复盘今日内容</strong>（记录栈与队列易错点，如指针越界，30分钟）</li></ol></li></ul><hr><h3 id="调整后重点变化"><strong>调整后重点变化</strong></h3><ol><li><strong>删减内容</strong>：<ul><li>原计划Day2的积分学习推迟到Day3，优先保住导数基础。</li><li>数据结构减少理论阅读时间，以代码实操为主。</li></ul></li><li><strong>保核心</strong>：<ul><li>数学：极限计算、导数定义与应用</li><li>数据结构：链表反转、栈的应用</li></ul></li><li><strong>灵活补救</strong>：<ul><li>若3月2日晚未完成导数全部任务，3月3日早晨优先补“极值判定”部分。</li></ul></li></ol><hr><h3 id="执行提醒"><strong>执行提醒</strong></h3><ul><li><strong>极限/导数公式表</strong>：3月2日早晨花20分钟默写，加强短期记忆。</li><li><strong>代码手写</strong>：必须落实！哪怕写不出也先抄答案再默写，注重过程。</li><li><strong>睡眠保证</strong>：3月1日晚尽量24:00前睡，3月2日早晨8:00起，避免连续熬夜。</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极坐标下的二重积分的范围确定</title>
    <link href="/2025/03/10/%E6%9E%81%E5%9D%90%E6%A0%87%E4%B8%8B%E7%9A%84%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%8C%83%E5%9B%B4%E7%A1%AE%E5%AE%9A/"/>
    <url>/2025/03/10/%E6%9E%81%E5%9D%90%E6%A0%87%E4%B8%8B%E7%9A%84%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%8C%83%E5%9B%B4%E7%A1%AE%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="1-极坐标的基本概念">1. 极坐标的基本概念</h3><p>极坐标系中用 $r$ 或 ( $ρ$ )表示点到原点的距离， <strong>(</strong>  $\theta$  <strong>)</strong>  表示与极轴$（通常是x轴正方向）$的夹角。</p><ul><li><strong>面积元素</strong>：直角坐标的 $dx,dy$ 转换为极坐标时需乘以雅可比行列式，变为 $r,dr,dθ$。</li><li><strong>符号习惯</strong>：$r$ 和 $ρ$ 在教材中可能交替使用，本质是同一变量，代表径向距离。</li></ul><hr><h3 id="2-积分范围的确定原则"><strong>2. 积分范围的确定原则</strong></h3><h4 id="1-简单区域（如圆形）">(1) 简单区域（如圆形）</h4><ul><li><p><strong>例</strong>：积分区域为半径 $a$ 的圆 $x^2 + y^2 \leq a^2$。</p><ul><li><strong>(</strong>  r  <strong>)</strong>  的范围：$0 \leq r \leq a$。</li><li>$\theta$ 的范围：$0 \leq \theta \leq 2\pi$。<br>积分表达式为：</li></ul></li></ul><p>$$<br>\int_{0}^{2\pi} \int_{0}^{a} f(r\cos\theta, r\sin\theta) \cdot r , dr , d\theta<br>$$</p><h4 id="2-复杂区域（如扇形或环形）">(2) 复杂区域（如扇形或环形）</h4><ul><li><p><strong>例</strong>：积分区域为环形 $1 \leq r \leq 2$ 且 $\pi/4 \leq \theta \leq \pi/2$。</p><ul><li><strong>(</strong>  r  <strong>)</strong>  的范围：由内半径和外半径确定，即 $1 \leq r \leq 2$。</li><li>$\theta$ 的范围：由角度区间确定，即 $\pi/4 \leq \theta \leq \pi/2$。<br>积分表达式为：</li></ul></li></ul><p>$$<br>\int_{\pi/4}^{\pi/2} \int_{1}^{2} f(r\cos\theta, r\sin\theta) \cdot r , dr , d\theta<br>$$</p><h4 id="3-依赖角度的径向范围">(3) 依赖角度的径向范围</h4><ul><li><p><strong>例</strong>：积分区域为心脏线 $r = 1 + \cos\theta$。</p><ul><li><strong>(</strong>  r  <strong>)</strong>  的范围：对每个固定的 $\theta$，$r$ 从 $0$ 到 $1 + \cos\theta$。</li><li>$\theta$ 的范围：覆盖整个心脏线，即 $0 \leq \theta \leq 2\pi$。<br>积分表达式为：</li></ul></li></ul><p>$$<br>\int_{0}^{2\pi} \int_{0}^{1+\cos\theta} f(r\cos\theta, r\sin\theta) \cdot r , dr , d\theta<br>$$</p><hr><h3 id="3-关键注意事项"><strong>3. 关键注意事项</strong></h3><h4 id="1-雅可比行列式不可忽略">(1) 雅可比行列式不可忽略</h4><p>极坐标面积元素必须包含  <strong>(</strong>  r  <strong>)</strong> ，否则积分结果错误。例如：</p><p>$$<br>\iint_D f(x,y) , dx,dy \quad \Rightarrow \quad \iint_{D’} f(r\cos\theta, r\sin\theta) \cdot \textcolor{red}{r} , dr,d\theta<br>$$</p><h4 id="2-变量范围的几何依赖性">(2) 变量范围的几何依赖性</h4><ul><li><strong>(</strong>  r  <strong>)</strong> 的范围由积分区域的边界方程（如 $r = g(\theta)$）确定。</li><li><strong>(</strong>  $\theta$  <strong>)</strong> 的范围由区域的覆盖角度决定，可能需要分段处理。</li></ul><h4 id="3-符号统一性">(3) 符号统一性</h4><p>若教材使用 $ρ$ 代替 $r$，只需保持符号一致，例如：</p><p>$$<br>\int_{\theta_1}^{\theta_2} \int_{\rho_1(\theta)}^{\rho_2(\theta)} f(\rho,\theta) \cdot \rho , d\rho , d\theta<br>$$</p><hr><h3 id="4-常见误区"><strong>4. 常见误区</strong></h3><ul><li><strong>误区1</strong>：认为 $r$ 可以随意设为常数范围（如 $0 \leq r \leq 1$），而忽略实际区域形状。<br><strong>纠正</strong>：必须根据区域几何确定 $r$ 的上下限（可能依赖 $θ$）。</li><li><strong>误区2</strong>：忽略 $r$ 导致面积元素错误（如写成 $dr,dθ$ 而非 $r,dr,dθ$）。<br><strong>纠正</strong>：始终记得雅可比行列式带来的 $r$ 因子。</li></ul><hr><h3 id="5-总结"><strong>5. 总结</strong></h3><ul><li><p><strong>(</strong>  r  <strong>)</strong>  或  <strong>(</strong>  $\rho$  <strong>)</strong> 的范围不是随意设定，而是由积分区域的几何形状（如圆形、扇形、曲线边界等）决定。</p></li><li><p>正确步骤：</p><ol><li>画出积分区域图，分析边界方程；</li><li>确定 $r$ 的最小和最大值（可能随 $\theta$ 变化）；</li><li>确定 $\theta$ 的覆盖范围；</li><li>写出完整的积分表达式，包含 $r,dr,dθ$。</li></ol></li></ul><p>通过结合几何直观和边界方程，可以准确设定极坐标下的积分范围。</p><hr><p>✅ 验证报告：</p><ul><li>已转化行内公式：24处</li><li>已调整独立公式：4处</li><li>内容变更检测：0处非公式修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的连续，可导，可微辨析</title>
    <link href="/2025/03/09/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%EF%BC%8C%E5%8F%AF%E5%AF%BC%EF%BC%8C%E5%8F%AF%E5%BE%AE%E8%BE%A8%E6%9E%90/"/>
    <url>/2025/03/09/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%EF%BC%8C%E5%8F%AF%E5%AF%BC%EF%BC%8C%E5%8F%AF%E5%BE%AE%E8%BE%A8%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>当一个函数的题目给出条件为：函数在区间内有定义的话，并不意味着该函数是连续的。</p><p>当提到函数在区间内有定义，这只表示该区间内的每个点都有对应的函数值，但这并不保证函数是连续的。以下是几个关键点：</p><h2 id="函数有定义与连续性的区别">函数有定义与连续性的区别</h2><ul><li><strong>函数有定义:</strong> 对于区间内的每一点 x，函数 f(x) 都有一个确定的值</li><li><strong>函数连续:</strong> 除了在每点有定义外，还要求 lim(x→a) f(x) = f(a)</li></ul><h2 id="反例说明">反例说明</h2><p>考虑函数：</p>$$f(x) = \begin{cases}   1, & x \geq 0 \\   -1, & x < 0 \end{cases}$$<p>该函数在整个实数轴上有定义，但在 x = 0 处不连续，因为左右极限不相等。</p><h2 id="考研中的应用">考研中的应用</h2><p>在解题时，当仅给出函数在区间内有定义的条件时，需要额外检验函数的连续性，特别是在：</p><ul><li>讨论函数的可导性时（连续是可导的必要条件）</li><li>应用中值定理、罗尔定理等需要连续性的定理时</li><li>计算定积分时（被积函数需要连续）</li></ul><h2 id="连续、可导、可微的关系">连续、可导、可微的关系</h2><p>理解这三者之间的关系是数学分析中的重要内容：</p><ul><li><strong>可导 → 连续:</strong> 如果函数在某点可导，则函数在该点必定连续</li><li><strong>连续 ↛ 可导:</strong> 函数连续不一定可导，如 f(x) = |x| 在 x = 0 处连续但不可导</li><li><strong>一元函数中:</strong> 可导与可微等价</li><li><strong>多元函数中:</strong> 偏导数存在不保证函数可微</li></ul><p>函数有定义只是讨论函数性质的起点，进一步分析连续性、可导性和可微性对于理解函数行为至关重要。</p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数连续中的间断点类型总结</title>
    <link href="/2025/03/04/%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E4%B8%AD%E7%9A%84%E9%97%B4%E6%96%AD%E7%82%B9%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2025/03/04/%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E4%B8%AD%E7%9A%84%E9%97%B4%E6%96%AD%E7%82%B9%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="间断点的类型主要根据函数在该点的极限行为进行分类，以下是详细的分类及说明：">间断点的类型主要根据函数在该点的极限行为进行分类，以下是详细的分类及说明：</h2><h3 id="1-第一类间断点（左右极限均存在）"><strong>1. 第一类间断点（左右极限均存在）</strong></h3><h3 id="a-可去间断点（Removable-Discontinuity）"><strong>(a) 可去间断点（Removable Discontinuity）</strong></h3><ul><li><strong>特点</strong>：<ul><li>函数在该点的左极限和右极限存在且相等，但函数值不等于该极限，或函数在该点无定义。</li><li>通过重新定义或修正函数值可使函数在该点连续。</li></ul></li><li><strong>示例</strong>：<br>$f(x) = \frac{\sin x}{x} \quad (x \neq 0)$<br>在 $\ ( x=0 )$ 处无定义，但 $\ (\lim_{x \to 0} f(x) = 1)$，补充定义 $\ ( f(0) = 1 )$ 后连续。</li></ul><h3 id="b-跳跃间断点（Jump-Discontinuity）"><strong>(b) 跳跃间断点（Jump Discontinuity）</strong></h3><ul><li><strong>特点</strong>：<ul><li>左极限和右极限均存在，但两者不相等。</li><li>函数图像在该点出现“跳跃”。</li></ul></li><li><strong>示例</strong>：<br>$\ [<br>f(x) =<br>\begin{cases}<br>x + 1 &amp; x \geq 0, \<br>x - 1 &amp; x &lt; 0<br>\end{cases}<br>]$<br>在 $\ ( x=0 )$ 处，左极限为 $\ (-1)$，右极限为 $\ (1)$，形成跳跃。</li></ul><hr><h3 id="2-第二类间断点（至少一侧极限不存在）"><strong>2. 第二类间断点（至少一侧极限不存在）</strong></h3><h3 id="以下是第二类间断点的两个主要类型：">以下是第二类间断点的两个主要类型：</h3><h3 id="a-无穷间断点（Infinite-Discontinuity）"><strong>(a) 无穷间断点（Infinite Discontinuity）</strong></h3><p><strong>特点</strong>：</p><p>当 <code>x</code> 趋近于该点时，函数值趋向正无穷或负无穷。</p><p>通常伴随垂直渐近线。</p><p><strong>示例</strong>：当 <code>x → 0</code> 时，函数 <code>$f(x) = \frac&#123;1&#125;&#123;x&#125;$</code> 的值趋向 <code>±∞</code>。</p><h3 id="b-振荡间断点（Oscillatory-Discontinuity）"><strong>(b) 振荡间断点（Oscillatory Discontinuity）</strong></h3><p><strong>特点</strong>：</p><p>函数在该点附近无限振荡，导致极限不存在。</p><p>常见于涉及三角函数或周期函数的复杂表达式中。</p><p><strong>示例</strong>：考虑函数 <code>$f(x) = sin(\frac&#123;1&#125;&#123;x&#125;)$</code> 当 <code>x → 0</code> 时，函数值在 <code>[-1,1]</code> 之间无限振荡，因此极限不存在。</p><hr><h3 id="3-其他特殊类型（补充说明）"><strong>3. 其他特殊类型（补充说明）</strong></h3><h3 id="混合型间断点"><strong>混合型间断点</strong></h3><ul><li><strong>特点</strong>：<ul><li>结合多种不连续行为，例如一侧趋向无穷，另一侧振荡。</li></ul></li><li><strong>示例</strong>：<br>$\ <br>f(x) =<br>\begin{cases}<br>\frac{1}{x} &amp; x &gt; 0, \<br>\sin\left(\frac{1}{x}\right) &amp; x &lt; 0<br>\end{cases}$<br>在 $\ ( x=0 )$ 处，右侧趋向 $\ ( +\infty )，$左侧振荡。</li></ul><h3 id="本质不连续点（Essential-Discontinuity）"><strong>本质不连续点（Essential Discontinuity）</strong></h3><ul><li><strong>别名</strong>：部分文献将第二类间断点统称为本质不连续点。</li></ul><hr><h3 id="总结表格"><strong>总结表格</strong></h3><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>可去间断点</strong></td><td>极限存在但函数值不符未定义</td><td>$\ \frac{\sin x}{x}$</td></tr><tr><td><strong>跳跃间断点</strong></td><td>左右极限存在但不相等</td><td>分段函数跳跃点</td></tr><tr><td><strong>无穷间断点</strong></td><td>函数趋向无穷大或无穷小</td><td>$\ \frac{1}{x}$</td></tr><tr><td><strong>振荡间断点</strong></td><td>函数无限振荡，极限不存在</td><td>$\ \sin\left(\frac{1}{x}\right)$</td></tr></tbody></table><hr><h3 id="关键区别"><strong>关键区别</strong></h3><ul><li><strong>第一类 vs 第二类</strong>：<br>第一类间断点的左右极限均存在（可比较大小），第二类至少一侧不存在或趋向无穷。</li><li><strong>可修复性</strong>：<br>仅可去间断点可通过修正函数值恢复连续性。</li></ul><p>通过以上分类，可系统分析函数在不同点的不连续行为。</p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3月份半个月学习计划</title>
    <link href="/2025/03/01/3%E6%9C%88%E4%BB%BD%E5%8D%8A%E4%B8%AA%E6%9C%88%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <url>/2025/03/01/3%E6%9C%88%E4%BB%BD%E5%8D%8A%E4%B8%AA%E6%9C%88%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>以下是重新优化后的<strong>15天考研数学一（高数核心）与数据结构系统学习计划</strong>，<strong>移除概率论</strong>，全面覆盖高数重点章节（包括多元微积分、曲线曲面积分、无穷级数等），并保持数据结构每日3-4小时系统学习。计划按<strong>“基础-强化-综合”三阶段</strong>推进，确保扎实掌握。</p><hr><h3 id="调整后核心策略"><a href="#调整后核心策略" class="headerlink" title="调整后核心策略"></a><strong>调整后核心策略</strong></h3><ol><li><strong>优先级</strong>：数学一高数（70%）+ 数据结构（30%），每天学习10-12小时。</li><li><strong>高数重点</strong>：极限→一元微积分→多元微积分→重积分→曲线曲面积分→级数→微分方程。</li><li><strong>数据结构</strong>：线性表→树→图→排序&#x2F;查找→真题，每日代码实操。</li><li><strong>学习逻辑</strong>：视频+教材+题型分类+错题本，拒绝遗漏核心考点。</li></ol><hr><h3 id="每日作息强化版"><a href="#每日作息强化版" class="headerlink" title="每日作息强化版"></a><strong>每日作息强化版</strong></h3><table><thead><tr><th>时间段</th><th>内容</th></tr></thead><tbody><tr><td>7:00-8:00</td><td>起床+背诵公式（如格林公式、DFS代码模板）</td></tr><tr><td>8:30-12:00</td><td>数学攻坚（视频+例题）</td></tr><tr><td>14:00-17:00</td><td>数据结构系统学习（教材+代码）</td></tr><tr><td>19:00-21:00</td><td>数学&#x2F;数据结构交叉刷题</td></tr><tr><td>21:30-22:30</td><td>错题整理+Anki记忆卡</td></tr></tbody></table><hr><h3 id="第一阶段：基础框架搭建（Day-1-5）"><a href="#第一阶段：基础框架搭建（Day-1-5）" class="headerlink" title="第一阶段：基础框架搭建（Day 1-5）"></a><strong>第一阶段：基础框架搭建（Day 1-5）</strong></h3><h3 id="Day-1-2：高数极限与连续-数据结构线性表"><a href="#Day-1-2：高数极限与连续-数据结构线性表" class="headerlink" title="Day 1-2：高数极限与连续 + 数据结构线性表"></a><strong>Day 1-2：高数极限与连续 + 数据结构线性表</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>张宇&#x2F;武忠祥极限视频（1.5倍速，重点：泰勒展开、夹逼定理）</li><li>《复习全书》例题（极限存在性证明、∞&#x2F;∞型计算）</li></ul></li><li>下午2h：<ul><li>刷《660题》极限部分（题1-30）+ 错题整理</li></ul></li><li>晚上1h：<ul><li>默写等价无穷小替换表、泰勒公式到x³项</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>顺序表与链表操作（插入&#x2F;删除时间复杂度）</li><li>手写代码：单链表反转（LeetCode 206）、合并有序链表（LeetCode 21）</li></ul></li><li>晚上1h：<ul><li>王道选择题（链表特性与应用场景）</li></ul></li></ul></li></ul><h3 id="Day-3-4：高数一元微分学-数据结构栈与队列"><a href="#Day-3-4：高数一元微分学-数据结构栈与队列" class="headerlink" title="Day 3-4：高数一元微分学 + 数据结构栈与队列"></a><strong>Day 3-4：高数一元微分学 + 数据结构栈与队列</strong></h3><ul><li><h2 id="数学任务（每天7小时）：-上午4h："><a href="#数学任务（每天7小时）：-上午4h：" class="headerlink" title="数学任务（每天7小时）：  - 上午4h："></a><strong>数学任务</strong>（每天7小时）：<br>  - 上午4h：</h2><pre><code class="hljs">  - 武忠祥导数应用视频（极值、凹凸性、渐近线）  - 《复习全书》例题（中值定理证明题）</code></pre><ul><li>下午2h：<ul><li>刷《660题》导数部分（题31-60）+ 总结辅助函数构造法</li></ul></li><li>晚上1h：<ul><li>整理导数公式表（参数方程、隐函数求导）</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>栈实现队列（LeetCode 232）、循环队列判满&#x2F;判空</li><li>手写代码：括号匹配（LeetCode 20）</li></ul></li><li>晚上1h：<ul><li>王道选择题（栈与队列的典型应用）</li></ul></li></ul></li></ul><h3 id="Day-5：高数一元积分学-数据结构树基础"><a href="#Day-5：高数一元积分学-数据结构树基础" class="headerlink" title="Day 5：高数一元积分学 + 数据结构树基础"></a><strong>Day 5：高数一元积分学 + 数据结构树基础</strong></h3><ul><li><strong>数学任务</strong>（7小时）：<ul><li>上午4h：<ul><li>张宇积分技巧视频（分部积分、三角代换）</li><li>《复习全书》例题（定积分几何应用、反常积分）</li></ul></li><li>下午2h：<ul><li>刷《660题》积分部分（题81-110）</li></ul></li><li>晚上1h：<ul><li>整理积分公式表（如∫√(a²-x²)dx）</li></ul></li></ul></li><li><strong>数据结构</strong>（3小时）：<ul><li>下午穿插2h：<ul><li>二叉树遍历（先序&#x2F;中序递归与非递归）</li><li>手写代码：中序非递归遍历（栈实现）</li></ul></li><li>晚上1h：<ul><li>王道选择题（二叉树节点数计算）</li></ul></li></ul></li></ul><hr><h3 id="第二阶段：高数核心强化（Day-6-10）"><a href="#第二阶段：高数核心强化（Day-6-10）" class="headerlink" title="第二阶段：高数核心强化（Day 6-10）"></a><strong>第二阶段：高数核心强化（Day 6-10）</strong></h3><h3 id="Day-6-7：高数多元微分学-数据结构树应用"><a href="#Day-6-7：高数多元微分学-数据结构树应用" class="headerlink" title="Day 6-7：高数多元微分学 + 数据结构树应用"></a><strong>Day 6-7：高数多元微分学 + 数据结构树应用</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>武忠祥多元微分视频（偏导数、全微分、方向导数）</li><li>《复习全书》例题（隐函数求导、条件极值）</li></ul></li><li>下午2h：<ul><li>刷《660题》多元微分部分（题200-230）</li></ul></li><li>晚上1h：<ul><li>总结梯度、方向导数与极值的关系</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>平衡二叉树（AVL树旋转）、二叉搜索树验证（LeetCode 98）</li></ul></li><li>晚上1h：<ul><li>王道选择题（AVL树插入调整步骤）</li></ul></li></ul></li></ul><h3 id="Day-8-9：高数重积分-数据结构图基础"><a href="#Day-8-9：高数重积分-数据结构图基础" class="headerlink" title="Day 8-9：高数重积分 + 数据结构图基础"></a><strong>Day 8-9：高数重积分 + 数据结构图基础</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>张宇重积分视频（二重&#x2F;三重积分计算、极坐标&#x2F;柱坐标变换）</li><li>《复习全书》例题（交换积分次序、奇偶性简化）</li></ul></li><li>下午2h：<ul><li>刷《660题》重积分部分（题240-270）</li></ul></li><li>晚上1h：<ul><li>整理对称性简化技巧（如轮换对称性）</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>图的存储（邻接矩阵&#x2F;邻接表）、DFS&#x2F;BFS代码实现</li><li>手写代码：课程表拓扑排序（LeetCode 207）</li></ul></li><li>晚上1h：<ul><li>王道选择题（DFS与BFS应用场景）</li></ul></li></ul></li></ul><h3 id="Day-10：高数曲线曲面积分-数据结构排序算法"><a href="#Day-10：高数曲线曲面积分-数据结构排序算法" class="headerlink" title="Day 10：高数曲线曲面积分 + 数据结构排序算法"></a><strong>Day 10：高数曲线曲面积分 + 数据结构排序算法</strong></h3><ul><li><strong>数学任务</strong>（7小时）：<ul><li>上午4h：<ul><li>武忠祥曲线积分视频（第一&#x2F;二型曲线积分、格林公式）</li><li>《复习全书》例题（参数化计算、斯托克斯公式）</li></ul></li><li>下午2h：<ul><li>刷《660题》曲线曲面积分部分（题280-310）</li></ul></li><li>晚上1h：<ul><li>总结高斯公式与散度、旋度的联系</li></ul></li></ul></li><li><strong>数据结构</strong>（3小时）：<ul><li>下午穿插2h：<ul><li>快速排序&#x2F;堆排序非递归实现、稳定性分析</li><li>手写代码：快速排序分区函数（Hoare法）</li></ul></li><li>晚上1h：<ul><li>王道选择题（排序算法时间复杂度对比）</li></ul></li></ul></li></ul><hr><h3 id="第三阶段：综合冲刺（Day-11-15）"><a href="#第三阶段：综合冲刺（Day-11-15）" class="headerlink" title="第三阶段：综合冲刺（Day 11-15）"></a><strong>第三阶段：综合冲刺（Day 11-15）</strong></h3><h3 id="Day-11-12：高数无穷级数-数据结构查找算法"><a href="#Day-11-12：高数无穷级数-数据结构查找算法" class="headerlink" title="Day 11-12：高数无穷级数 + 数据结构查找算法"></a><strong>Day 11-12：高数无穷级数 + 数据结构查找算法</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>张宇级数视频（正项级数、幂级数求和、傅里叶级数）</li><li>《复习全书》例题（收敛性判别、展开式求系数）</li></ul></li><li>下午2h：<ul><li>刷《660题》级数部分（题320-350）</li></ul></li><li>晚上1h：<ul><li>整理常见展开式（如1&#x2F;(1-x)&#x3D;∑xⁿ, |x|&lt;1）</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>哈希表冲突处理（拉链法、开放定址法）</li><li>手写代码：LRU缓存（LeetCode 146）</li></ul></li><li>晚上1h：<ul><li>王道选择题（B树与B+树差异）</li></ul></li></ul></li></ul><h3 id="Day-13-14：高数真题模拟-数据结构真题"><a href="#Day-13-14：高数真题模拟-数据结构真题" class="headerlink" title="Day 13-14：高数真题模拟 + 数据结构真题"></a><strong>Day 13-14：高数真题模拟 + 数据结构真题</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>限时3h完成2020年真题</li><li>4h逐题分析错因（重点：曲线积分与级数大题）</li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>408真题（2015-2020数据结构大题）</li><li>重点：二叉树非递归遍历、图最短路径</li></ul></li><li>晚上1h：<ul><li>复盘代码边界条件（如指针判空、循环终止）</li></ul></li></ul></li></ul><h3 id="Day-15：总复习与补漏"><a href="#Day-15：总复习与补漏" class="headerlink" title="Day 15：总复习与补漏"></a><strong>Day 15：总复习与补漏</strong></h3><ul><li><strong>数学</strong>（7小时）：<ul><li>上午4h：默写核心公式（从极限到曲面积分）</li><li>下午3h：重做高数错题（如格林公式应用）</li></ul></li><li><strong>数据结构</strong>（3小时）：<ul><li>系统复盘线性表→图→排序</li><li>手写代码：二叉树层序遍历（LeetCode 102）</li></ul></li></ul><hr><h3 id="每日作息强化版-1"><a href="#每日作息强化版-1" class="headerlink" title="每日作息强化版"></a><strong>每日作息强化版</strong></h3><table><thead><tr><th>时间段</th><th>内容</th></tr></thead><tbody><tr><td>7:00-8:00</td><td>起床+背诵公式（如格林公式、DFS代码模板）</td></tr><tr><td>8:30-12:00</td><td>数学攻坚（视频+例题）</td></tr><tr><td>14:00-17:00</td><td>数据结构系统学习（教材+代码）</td></tr><tr><td>19:00-21:00</td><td>数学&#x2F;数据结构交叉刷题</td></tr><tr><td>21:30-22:30</td><td>错题整理+Anki记忆卡</td></tr></tbody></table><hr><h3 id="关键执行原则"><a href="#关键执行原则" class="headerlink" title="关键执行原则"></a><strong>关键执行原则</strong></h3><ol><li><strong>高数优先级</strong>：若时间紧张，优先完成<strong>曲线曲面积分</strong>和<strong>级数</strong>，这两部分是数一特有且难度较高的考点。</li><li><strong>数据结构代码</strong>：每日至少手写1题，重点训练<strong>非递归遍历</strong>和<strong>算法应用</strong>（如拓扑排序）。</li><li><strong>错题本</strong>：按章节分类记录错题，每晚睡前回顾10分钟。</li><li><strong>健康管理</strong>：每学习1小时休息5分钟，每天保证6小时睡眠。</li></ol><p><strong>按此计划，15天内可系统攻克高数全部核心内容，并保持数据结构代码手感！</strong> 如需进一步细化某部分（如曲线积分参数化方法），请随时告知！</p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天一题蓝桥杯：报数游戏</title>
    <link href="/2024/10/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E6%8A%A5%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/10/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E6%8A%A5%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="今日蓝桥杯题目"><a href="#今日蓝桥杯题目" class="headerlink" title="今日蓝桥杯题目"></a>今日蓝桥杯题目</h1><p>小蓝和朋友们在玩一个报数游戏。由于今年是2024 年，他们决定要从小到大轮流报出是20 或 24倍数的正整数。前10 个被报出的数是：20,24,40,48,60,72,80,96,100,120。请问第202420242024 个被报出的数是多少?</p><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p><strong>目标</strong>：找出第 ( n ) 个是 <strong>20</strong> 或 <strong>24</strong> 的倍数的正整数，按从小到大的顺序排列，且不重复。</p><p><strong>示例</strong>：</p><ul><li>前10个被报出的数是：20, 24, 40, 48, 60, 72, 80, 96, 100, 120。</li></ul><h1 id="为什么使用二分查找？"><a href="#为什么使用二分查找？" class="headerlink" title="为什么使用二分查找？"></a>为什么使用二分查找？</h1><p>在处理这样的问题时，直接枚举所有满足条件的数直到找到第 ( n ) 个数是不现实的，尤其当 ( n ) 很大（如 ( n &#x3D; 202420242024 )）时。因此，我们需要一种更高效的方法来定位目标数的位置。<strong>二分查找</strong> 是一种适合此类问题的高效算法。</p><h2 id="二分查找的基本原理"><a href="#二分查找的基本原理" class="headerlink" title="二分查找的基本原理"></a>二分查找的基本原理</h2><p><strong>二分查找</strong> 是一种在有序数组中查找特定元素的算法，其基本思想是通过不断将搜索范围缩小一半来快速定位目标元素。虽然在这个问题中，我们不是在一个固定的数组中查找元素，而是在一个按特定规则生成的数列中查找第 ( n ) 个元素，但二分查找的思想仍然适用。</p><h2 id="应用于本问题的二分查找步骤"><a href="#应用于本问题的二分查找步骤" class="headerlink" title="应用于本问题的二分查找步骤"></a>应用于本问题的二分查找步骤</h2><ol><li><p><strong>定义搜索范围</strong>：</p><ul><li><strong>左界（Left）</strong>：最小可能的数，通常设为 1。</li><li><strong>右界（Right）</strong>：最大可能的数，可以初步设为 $( n \times \text{max}(a, b) )$。在本例中，( a &#x3D; 20 )，( b &#x3D; 24 )，所以右界可以设为 ( n \times 24 )。</li></ul></li><li><p><strong>计算中点</strong>：</p><ul><li>计算当前搜索范围的中点 $( \text{mid} &#x3D; \left\lfloor \frac{\text{left} + \text{right}}{2} \right\rfloor )$。</li></ul></li><li><p><strong>计算中点位置的满足条件的数的数量</strong>：</p><ul><li>使用容斥原理计算不超过 $( \text{mid} )$ 的 <strong>20</strong> 或 <strong>24</strong> 的倍数的数量 $( C(\text{mid}) )$：<br>$$<br>C(\text{mid}) &#x3D; \left\lfloor \frac{\text{mid}}{20} \right\rfloor + \left\lfloor \frac{\text{mid}}{24} \right\rfloor - \left\lfloor \frac{\text{mid}}{120} \right\rfloor<br>$$<br>其中，<strong>120</strong> 是 <strong>20</strong> 和 <strong>24</strong> 的最小公倍数（LCM）。</li></ul></li><li><p><strong>调整搜索范围</strong>：</p><ul><li>**如果 $( C(\text{mid}) &lt; n )$**：<ul><li>说明第 ( n ) 个数位于 ( \text{mid} ) 右侧，因此将左界设为 ( \text{mid} + 1 )。</li></ul></li><li>**否则（$( C(\text{mid}) \geq n )$**：<ul><li>说明第 $( n ) 个数位于 ( \text{mid} )$ 左侧或就是 $( \text{mid} )$，因此将右界设为 $( \text{mid} )$。</li></ul></li></ul></li><li><p><strong>重复步骤 2-4</strong>，直到左界等于右界。</p></li><li><p><strong>最终结果</strong>：</p><ul><li>当左界与右界相等时，该值即为第 ( n ) 个满足条件的数。</li></ul></li></ol><h2 id="为什么-C-x-n-表示-x-太小？"><a href="#为什么-C-x-n-表示-x-太小？" class="headerlink" title="为什么 $( C(x) &lt; n ) 表示 ( x )$ 太小？"></a>为什么 $( C(x) &lt; n ) 表示 ( x )$ 太小？</h2><h3 id="定义计数函数-C-x"><a href="#定义计数函数-C-x" class="headerlink" title="定义计数函数 $( C(x) )$"></a>定义计数函数 $( C(x) )$</h3><p>对于任意正整数 ( x )，( C(x) ) 表示不超过 ( x ) 的数中，既是 <strong>20</strong> 或 <strong>24</strong> 的倍数的数的数量：<br>$$<br>C(x) &#x3D; \left\lfloor \frac{x}{20} \right\rfloor + \left\lfloor \frac{x}{24} \right\rfloor - \left\lfloor \frac{x}{120} \right\rfloor<br>$$</p><h3 id="二分查找的目标"><a href="#二分查找的目标" class="headerlink" title="二分查找的目标"></a>二分查找的目标</h3><p>我们希望找到最小的 ( x )，使得 ( C(x) &#x3D; n )。换句话说，找到第 ( n ) 个满足条件的数，即第 ( n ) 个 <strong>20</strong> 或 <strong>24</strong> 的倍数。</p><h3 id="搜索过程中的判断"><a href="#搜索过程中的判断" class="headerlink" title="搜索过程中的判断"></a>搜索过程中的判断</h3><ul><li><p>**如果 $( C(\text{mid}) &lt; n )$**：</p><ul><li>说明在 ( 1 ) 到 $( \text{mid} )$ 之间，只有 $( C(\text{mid}) )$ 个数满足条件，但我们需要第 ( n ) 个数。</li><li>因此，第 ( n ) 个数 **必定大于 $( \text{mid} )$**。</li><li><strong>结论</strong>：当前的 $( \text{mid} )$ 太小，无法包含第 ( n ) 个数，需要在更大的范围内继续搜索。</li></ul></li><li><p>**如果 $( C(\text{mid}) \geq n )$**：</p><ul><li>说明第 ( n ) 个数 <strong>可能在 $( \text{mid} )$ 之前</strong>，也可能就是 $( \text{mid} )$ 本身。</li><li><strong>结论</strong>：需要在较小的范围内继续搜索，缩小右界。</li></ul></li></ul><h2 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h2><p>想象一下你正在寻找一个特定位置的数，例如第1000个满足条件的数。通过二分查找，你每次选择一个中间值并计算在这个中间值之前有多少个满足条件的数：</p><ul><li><strong>如果计算出的数量 $( C(\text{mid}) )$ 比目标 ( n ) 小</strong>，说明第 ( n ) 个数还没到，需要往更大的方向看。</li><li><strong>如果计算出的数量 $( C(\text{mid}) )$ 大于或等于目标 ( n )</strong>，说明目标数已经在 $( \text{mid} )$ 或更小的范围内，可以缩小搜索范围，继续在较小的范围内寻找精确的位置。</li></ul><h2 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h2><p><strong>目标</strong>：找到第10个是 <strong>20</strong> 或 <strong>24</strong> 的倍数的数。</p><ol><li><p><strong>初始化搜索范围</strong>：</p><ul><li>左界 $( \text{left} &#x3D; 1 )$</li><li>右界 $( \text{right} &#x3D; 10 \times 24 &#x3D; 240 )（初步设定为 ( n \times \text{max}(a, b) )）$</li></ul></li><li><p><strong>第一次迭代</strong>：</p><ul><li>中点 $( \text{mid} &#x3D; \left\lfloor \frac{1 + 240}{2} \right\rfloor &#x3D; 120 )$</li><li>计算 ( C(120) )：<br>$$<br>C(120) &#x3D; \left\lfloor \frac{120}{20} \right\rfloor + \left\lfloor \frac{120}{24} \right\rfloor - \left\lfloor \frac{120}{120} \right\rfloor &#x3D; 6 + 5 - 1 &#x3D; 10<br>$$</li><li><strong>比较 ( C(120) &#x3D; 10 ) 与 ( n &#x3D; 10 )</strong>：<ul><li>因为 $( C(120) \geq n )$，将右界设为 ( 120 )。</li></ul></li></ul></li><li><p><strong>第二次迭代</strong>：</p><ul><li>新的搜索范围：$( \text{left} &#x3D; 1 )$，$( \text{right} &#x3D; 120 )$</li><li>中点 $( \text{mid} &#x3D; \left\lfloor \frac{1 + 120}{2} \right\rfloor &#x3D; 60 )$</li><li>计算 ( C(60) )：<br>$$<br>C(60) &#x3D; \left\lfloor \frac{60}{20} \right\rfloor + \left\lfloor \frac{60}{24} \right\rfloor - \left\lfloor \frac{60}{120} \right\rfloor &#x3D; 3 + 2 - 0 &#x3D; 5<br>$$</li><li><strong>比较 ( C(60) &#x3D; 5 ) 与 ( n &#x3D; 10 )</strong>：<ul><li>因为 ( C(60) &lt; n )，将左界设为 ( 61 )。</li></ul></li></ul></li><li><p><strong>第三次迭代</strong>：</p><ul><li>新的搜索范围：$( \text{left} &#x3D; 61 )$，$( \text{right} &#x3D; 120 )$</li><li>中点 $( \text{mid} &#x3D; \left\lfloor \frac{61 + 120}{2} \right\rfloor &#x3D; 90 )$</li><li>计算 ( C(90) )：<br>$$<br>C(90) &#x3D; \left\lfloor \frac{90}{20} \right\rfloor + \left\lfloor \frac{90}{24} \right\rfloor - \left\lfloor \frac{90}{120} \right\rfloor &#x3D; 4 + 3 - 0 &#x3D; 7<br>$$</li><li><strong>比较 ( C(90) &#x3D; 7 ) 与 ( n &#x3D; 10 )</strong>：<ul><li>因为 ( C(90) &lt; n )，将左界设为 ( 91 )。</li></ul></li></ul></li><li><p><strong>继续迭代</strong>，直到左界等于右界：</p><ul><li>最终会发现，当 $( \text{left} &#x3D; 120 )$ 时，( C(120) &#x3D; 10 )，满足条件。</li><li><strong>结果</strong>：( x &#x3D; 120 )</li></ul></li></ol><p><strong>验证结果</strong>：</p><ul><li>前10个数确实是：20, 24, 40, 48, 60, 72, 80, 96, 100, 120。</li><li>因此，算法正确地找到了第10个数是 <strong>120</strong>。</li></ul><h2 id="为什么二分查找有效？"><a href="#为什么二分查找有效？" class="headerlink" title="为什么二分查找有效？"></a>为什么二分查找有效？</h2><ul><li><strong>有序性</strong>：满足条件的数按升序排列，二分查找依赖于这一特性，通过比较中点位置的数的数量与目标 ( n ) 之间的关系，逐步缩小搜索范围。</li><li><strong>效率</strong>：二分查找的时间复杂度为 $( O(\log N) )$，远比线性搜索（时间复杂度 ( O(N) )）高效，特别是在 ( N ) 很大的情况下。</li></ul><h2 id="二分查找在此问题中的关键点"><a href="#二分查找在此问题中的关键点" class="headerlink" title="二分查找在此问题中的关键点"></a>二分查找在此问题中的关键点</h2><ol><li><p><strong>定义搜索范围</strong>：</p><ul><li>初始左界设为 1，右界设为 $( n \times \text{max}(a, b) )$。</li><li>在本例中，( a &#x3D; 20 )，( b &#x3D; 24 )，所以右界可以设为 $( n \times 24 )$。</li></ul></li><li><p><strong>中点计算与比较</strong>：</p><ul><li>通过计算中点 $( \text{mid} )$ 的位置，利用容斥原理计算不超过 $( \text{mid} )$ 的满足条件的数的数量 $( C(\text{mid}) )$。</li><li>**如果 $( C(\text{mid}) &lt; n )$**，则更新左界为 $( \text{mid} + 1 )$。</li><li><strong>否则</strong>，将右界设为 $( \text{mid} )$。</li></ul></li><li><p><strong>终止条件</strong>：</p><ul><li>当左界等于右界时，搜索结束，左界（或右界）即为第 ( n ) 个满足条件的数。</li></ul></li></ol><h1 id="解决代码示例"><a href="#解决代码示例" class="headerlink" title="解决代码示例"></a>解决代码示例</h1><p>以下是一个完整的 Python 实现，结合了二分查找和容斥原理，用于精确找到第 ( n ) 个是 <strong>a</strong> 或 <strong>b</strong> 的倍数的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcm</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算两个数的最小公倍数&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> gcd<br>    <span class="hljs-keyword">return</span> a * b // gcd(a, b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_multiples</span>(<span class="hljs-params">x, a, b</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算不超过 x 的 a 或 b 的倍数的数量&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> x // a + x // b - x // lcm(a, b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_nth_number</span>(<span class="hljs-params">n, a, b</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;使用二分查找找到第 n 个是 a 或 b 的倍数的数&quot;&quot;&quot;</span><br>    left = <span class="hljs-number">1</span><br>    right = n * <span class="hljs-built_in">max</span>(a, b)  <span class="hljs-comment"># 初始右界设为 n * max(a, b)</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        mid = (left + right) // <span class="hljs-number">2</span><br>        current_count = count_multiples(mid, a, b)<br>        <span class="hljs-keyword">if</span> current_count &lt; n:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid<br>    <span class="hljs-keyword">return</span> left<br><br><span class="hljs-comment"># 示例 1: 寻找第 202420242024 个是 20 或 24 的倍数的数</span><br>n = <span class="hljs-number">202420242024</span><br>a = <span class="hljs-number">20</span><br>b = <span class="hljs-number">24</span><br>result = find_nth_number(n, a, b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第 <span class="hljs-subst">&#123;n&#125;</span> 个被报出的数是: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)  <span class="hljs-comment"># 输出: 2429042904288</span><br><br><span class="hljs-comment"># 示例 2: 寻找第 1000 个是 10 或 15 的倍数的数</span><br>n = <span class="hljs-number">1000</span><br>a = <span class="hljs-number">10</span><br>b = <span class="hljs-number">15</span><br>result = find_nth_number(n, a, b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第 <span class="hljs-subst">&#123;n&#125;</span> 个被报出的数是: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)  <span class="hljs-comment"># 输出: 7500</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯学习</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天一题蓝桥杯：单词博弈</title>
    <link href="/2024/10/15/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88/"/>
    <url>/2024/10/15/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88/</url>
    
    <content type="html"><![CDATA[<h1 id="今日蓝桥杯题目"><a href="#今日蓝桥杯题目" class="headerlink" title="今日蓝桥杯题目"></a>今日蓝桥杯题目</h1><p>夏日夜晚，小蓝和小桥在蓝桥公园散步。在蜿蜒的小路上，他们发现了一堆单词。</p><p>小蓝和小桥对这些单词饶有兴致，于是开始收集它们：小蓝收集了n 个单词，小桥收集了m 个单词。收集完单词后，他们决定玩一个游戏。</p><p>游戏规则如下：每一回合，玩家需要从自己收集到的单词中说出一个单词。所说的单词必须满足以下条件：该单词的字典序大小要比上一个单词大，并且该单词要么与上一个单词以相同的字母开头，要么以字母表中紧随其后的字母开头。</p><p>例如，如果上一个单词是 apple，那么接下来的单词可以是：</p><p>以相同字母 a 开头的单词，如：apply。以字母表中紧随 a 之后的字母 b 开头的单词，如 banana。<br>如果某个玩家无法满足上述条件，则该玩家输掉游戏。</p><p>小蓝和小桥轮流进行，由小蓝率先开始。</p><p>已知小蓝第一次会说出自己单词堆中按字典序排列最小的单词。请问，如果小蓝和小桥都按照最优策略进行游戏，谁会获胜？</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br>n , m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>a =[<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>b = [<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>a.sort(reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#这是正序，倒序就是reverse：true</span><br>b.sort(reverse= <span class="hljs-literal">True</span>) <br><br>flag = <span class="hljs-literal">True</span><br>pre = a.pop()<br><br><span class="hljs-keyword">while</span>(flag <span class="hljs-keyword">and</span> a) <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> flag <span class="hljs-keyword">and</span> b):<br>    <span class="hljs-keyword">if</span> flag:  <span class="hljs-comment">#flag为true的时候，这时候小蓝已经说过一个了， 所以轮到小桥</span><br>        word = a.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span> ) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">False</span><br>            pre = word<br>    <span class="hljs-keyword">else</span>:<br>        word = b.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span>) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">True</span><br>            pre = word<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;L&#x27;</span>) <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Q&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>接下来是hexo的内置代码块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br>n , m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>a =[<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>b = [<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>a.sort(reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#这是正序，倒序就是reverse：true</span><br>b.sort(reverse= <span class="hljs-literal">True</span>) <br><br>flag = <span class="hljs-literal">True</span><br>pre = a.pop()<br><br><span class="hljs-keyword">while</span>(flag <span class="hljs-keyword">and</span> a) <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> flag <span class="hljs-keyword">and</span> b):<br>    <span class="hljs-keyword">if</span> flag:  <span class="hljs-comment">#flag为true的时候，这时候小蓝已经说过一个了， 所以轮到小桥</span><br>        word = a.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span> ) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">False</span><br>            pre = word<br>    <span class="hljs-keyword">else</span>:<br>        word = b.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span>) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">True</span><br>            pre = word<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;L&#x27;</span>) <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Q&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="学习到了什么？"><a href="#学习到了什么？" class="headerlink" title="学习到了什么？"></a>学习到了什么？</h1><ul><li><p>字典序<br>什么是字典序，就是按照字典顺序进行比较排序的结果，比如说两个单词app，apple。从第一个字母开始进行比较，如果一样就继续对比下一个字母，直到不一样。比如到了app以后，apple还有le，而app则没有了，app的字典序就比apple要小。排序就是’app&lt;apple’。</p></li><li><p>字典序排序<br>如果有很多个单词进行字典序比较，是不是会比较头疼？但是实际上python和c++中已经内置了字典序排序，可以直接使用<code>sort()</code>或者是<code>reverse()</code>函数直接对多个对象进行字典序排序。<code>sort()</code>是从小到大进行排序，反之从大到小。</p></li><li><p>列表推导式<br>代码里用到列表推导式：<code>a = [input() for _ in range(n)]</code>，或者其他的形式<code>a = list(map(int , input().split()))</code>，这样的式子简洁高效，要记住。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
