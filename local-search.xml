<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>考研记录3月1日</title>
    <link href="/2025/03/21/%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%953%E6%9C%881%E6%97%A5/"/>
    <url>/2025/03/21/%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%953%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p>由于今日起晚了，所以重新规划1和2号的学习安排</p><hr><h3 id="3月1日（剩余时间：16-30-24-00）"><a href="#3月1日（剩余时间：16-30-24-00）" class="headerlink" title="3月1日（剩余时间：16:30-24:00）"></a><strong>3月1日（剩余时间：16:30-24:00）</strong></h3><p><strong>总目标</strong>：完成数学极限核心概念+数据结构线性表基础</p><p><strong>总时长</strong>：7.5小时（含休息）</p><h3 id="16-30-19-00：数学极限基础（2-5h）"><a href="#16-30-19-00：数学极限基础（2-5h）" class="headerlink" title="16:30-19:00：数学极限基础（2.5h）"></a><strong>16:30-19:00：数学极限基础（2.5h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>速看张宇&#x2F;武忠祥极限基础课</strong>（1h，1.5倍速，重点听“泰勒展开”和“洛必达法则”）</li><li><strong>刷《复习全书》极限例题</strong>（3道经典题，如“sinx&#x2F;x→1的证明”、“∞-∞型极限计算”）</li><li><strong>整理极限公式表</strong>（手写：等价无穷小替换、泰勒公式到x³项）</li></ol></li><li><strong>重点</strong>：<br>确保理解极限计算逻辑，暂不追求刷题量，先掌握核心方法。</li></ul><h3 id="19-30-21-30：数据结构线性表（2h）"><a href="#19-30-21-30：数据结构线性表（2h）" class="headerlink" title="19:30-21:30：数据结构线性表（2h）"></a><strong>19:30-21:30：数据结构线性表（2h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>学习顺序表与链表的区别</strong>（王道教材2.1-2.2节，30分钟）</li><li><strong>手写单链表反转代码</strong>（LeetCode 206，反复写3遍直到无bug，1h）</li><li><strong>做王道选择题</strong>（仅做“链表插入删除”相关题，5道，30分钟）</li></ol></li><li><strong>重点</strong>：<br>必须能默写链表反转代码，理解指针操作逻辑。</li></ul><h3 id="21-30-24-00：数学极限巩固-错题（2-5h）"><a href="#21-30-24-00：数学极限巩固-错题（2-5h）" class="headerlink" title="21:30-24:00：数学极限巩固+错题（2.5h）"></a><strong>21:30-24:00：数学极限巩固+错题（2.5h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>刷《660题》极限部分</strong>（精选10题，题号1-10，1h）</li><li><strong>分析错题</strong>（记录错题原因，如“泰勒展开项数不足”，30分钟）</li><li><strong>默写公式+明早复习清单</strong>（30分钟）</li></ol></li></ul><hr><h3 id="3月2日（全天）"><a href="#3月2日（全天）" class="headerlink" title="3月2日（全天）"></a><strong>3月2日（全天）</strong></h3><p><strong>总目标</strong>：完成数学导数基础+数据结构栈与队列</p><p><strong>总时长</strong>：12小时（含休息）</p><h3 id="8-30-11-30：数学导数与微分（3h）"><a href="#8-30-11-30：数学导数与微分（3h）" class="headerlink" title="8:30-11:30：数学导数与微分（3h）"></a><strong>8:30-11:30：数学导数与微分（3h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>武忠祥导数应用视频</strong>（1.5h，重点看“导数定义”和“极值判定”）</li><li><strong>手写导数公式表</strong>（包括参数方程求导、隐函数求导，30分钟）</li><li><strong>刷《660题》导数部分</strong>（题号31-40，5题，1h）</li></ol></li></ul><h3 id="14-00-17-00：数据结构栈与队列（3h）"><a href="#14-00-17-00：数据结构栈与队列（3h）" class="headerlink" title="14:00-17:00：数据结构栈与队列（3h）"></a><strong>14:00-17:00：数据结构栈与队列（3h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>栈的应用</strong>（括号匹配原理，手写代码：LeetCode 20，1h）</li><li><strong>循环队列实现</strong>（重点：判空条件<code>front == rear</code>，判满条件<code>(rear+1)%size == front</code>，1h）</li><li><strong>用栈实现队列</strong>（LeetCode 232，1h）</li></ol></li></ul><h3 id="19-00-21-00：数学导数强化（2h）"><a href="#19-00-21-00：数学导数强化（2h）" class="headerlink" title="19:00-21:00：数学导数强化（2h）"></a><strong>19:00-21:00：数学导数强化（2h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>总结“证明题”构造辅助函数的方法</strong>（如用罗尔定理证明根的存在性，1h）</li><li><strong>重做错题+整理导数应用框架</strong>（如极值、凹凸性、渐近线，1h）</li></ol></li></ul><h3 id="21-30-23-30：数据结构真题-复盘（2h）"><a href="#21-30-23-30：数据结构真题-复盘（2h）" class="headerlink" title="21:30-23:30：数据结构真题+复盘（2h）"></a><strong>21:30-23:30：数据结构真题+复盘（2h）</strong></h3><ul><li><strong>任务</strong>：<ol><li><strong>做408真题（2016年数据结构选择题）</strong>（10题，30分钟）</li><li><strong>手写循环队列代码</strong>（确保能处理边界条件，1h）</li><li><strong>复盘今日内容</strong>（记录栈与队列易错点，如指针越界，30分钟）</li></ol></li></ul><hr><h3 id="调整后重点变化"><a href="#调整后重点变化" class="headerlink" title="调整后重点变化"></a><strong>调整后重点变化</strong></h3><ol><li><strong>删减内容</strong>：<ul><li>原计划Day2的积分学习推迟到Day3，优先保住导数基础。</li><li>数据结构减少理论阅读时间，以代码实操为主。</li></ul></li><li><strong>保核心</strong>：<ul><li>数学：极限计算、导数定义与应用</li><li>数据结构：链表反转、栈的应用</li></ul></li><li><strong>灵活补救</strong>：<ul><li>若3月2日晚未完成导数全部任务，3月3日早晨优先补“极值判定”部分。</li></ul></li></ol><hr><h3 id="执行提醒"><a href="#执行提醒" class="headerlink" title="执行提醒"></a><strong>执行提醒</strong></h3><ul><li><strong>极限&#x2F;导数公式表</strong>：3月2日早晨花20分钟默写，加强短期记忆。</li><li><strong>代码手写</strong>：必须落实！哪怕写不出也先抄答案再默写，注重过程。</li><li><strong>睡眠保证</strong>：3月1日晚尽量24:00前睡，3月2日早晨8:00起，避免连续熬夜。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>默认标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的连续，可导，可微辨析</title>
    <link href="/2025/03/20/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%EF%BC%8C%E5%8F%AF%E5%AF%BC%EF%BC%8C%E5%8F%AF%E5%BE%AE%E8%BE%A8%E6%9E%90/"/>
    <url>/2025/03/20/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%EF%BC%8C%E5%8F%AF%E5%AF%BC%EF%BC%8C%E5%8F%AF%E5%BE%AE%E8%BE%A8%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>当一个函数的题目给出条件为：函数在区间内有定义的话，并不意味着该函数是连续的。</p><p>当提到函数在区间内有定义，这只表示该区间内的每个点都有对应的函数值，但这并不保证函数是连续的。以下是几个关键点：</p><h2 id="函数有定义与连续性的区别"><a href="#函数有定义与连续性的区别" class="headerlink" title="函数有定义与连续性的区别"></a>函数有定义与连续性的区别</h2><ul><li><strong>函数有定义:</strong> 对于区间内的每一点 x，函数 f(x) 都有一个确定的值</li><li><strong>函数连续:</strong> 除了在每点有定义外，还要求 lim(x→a) f(x) &#x3D; f(a)</li></ul><h2 id="反例说明"><a href="#反例说明" class="headerlink" title="反例说明"></a>反例说明</h2><p>考虑函数：</p>$$f(x) = \begin{cases}   1, & x \geq 0 \\   -1, & x < 0 \end{cases}$$<p>该函数在整个实数轴上有定义，但在 x &#x3D; 0 处不连续，因为左右极限不相等。</p><h2 id="考研中的应用"><a href="#考研中的应用" class="headerlink" title="考研中的应用"></a>考研中的应用</h2><p>在解题时，当仅给出函数在区间内有定义的条件时，需要额外检验函数的连续性，特别是在：</p><ul><li>讨论函数的可导性时（连续是可导的必要条件）</li><li>应用中值定理、罗尔定理等需要连续性的定理时</li><li>计算定积分时（被积函数需要连续）</li></ul><h2 id="连续、可导、可微的关系"><a href="#连续、可导、可微的关系" class="headerlink" title="连续、可导、可微的关系"></a>连续、可导、可微的关系</h2><p>理解这三者之间的关系是数学分析中的重要内容：</p><ul><li><strong>可导 → 连续:</strong> 如果函数在某点可导，则函数在该点必定连续</li><li><strong>连续 ↛ 可导:</strong> 函数连续不一定可导，如 f(x) &#x3D; |x| 在 x &#x3D; 0 处连续但不可导</li><li><strong>一元函数中:</strong> 可导与可微等价</li><li><strong>多元函数中:</strong> 偏导数存在不保证函数可微</li></ul><p>函数有定义只是讨论函数性质的起点，进一步分析连续性、可导性和可微性对于理解函数行为至关重要。</p>]]></content>
    
    
    
    <tags>
      
      <tag>默认标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数连续中的间断点类型总结</title>
    <link href="/2025/03/04/%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E4%B8%AD%E7%9A%84%E9%97%B4%E6%96%AD%E7%82%B9%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2025/03/04/%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E4%B8%AD%E7%9A%84%E9%97%B4%E6%96%AD%E7%82%B9%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>间断点的类型主要根据函数在该点的极限行为进行分类，以下是详细的分类及说明：</p><hr><h3 id="1-第一类间断点（左右极限均存在）"><a href="#1-第一类间断点（左右极限均存在）" class="headerlink" title="1. 第一类间断点（左右极限均存在）"></a><strong>1. 第一类间断点（左右极限均存在）</strong></h3><h3 id="a-可去间断点（Removable-Discontinuity）"><a href="#a-可去间断点（Removable-Discontinuity）" class="headerlink" title="(a) 可去间断点（Removable Discontinuity）"></a><strong>(a) 可去间断点（Removable Discontinuity）</strong></h3><ul><li><strong>特点</strong>：<ul><li>函数在该点的左极限和右极限存在且相等，但函数值不等于该极限，或函数在该点无定义。</li><li>通过重新定义或修正函数值可使函数在该点连续。</li></ul></li><li><strong>示例</strong>：<br>$f(x) &#x3D; \frac{\sin x}{x} \quad (x \neq 0)$<br>在 $\ ( x&#x3D;0 )$ 处无定义，但 $\ (\lim_{x \to 0} f(x) &#x3D; 1)$，补充定义 $\ ( f(0) &#x3D; 1 )$ 后连续。</li></ul><h3 id="b-跳跃间断点（Jump-Discontinuity）"><a href="#b-跳跃间断点（Jump-Discontinuity）" class="headerlink" title="(b) 跳跃间断点（Jump Discontinuity）"></a><strong>(b) 跳跃间断点（Jump Discontinuity）</strong></h3><ul><li><strong>特点</strong>：<ul><li>左极限和右极限均存在，但两者不相等。</li><li>函数图像在该点出现“跳跃”。</li></ul></li><li><strong>示例</strong>：<br>$\ [<br>f(x) &#x3D;<br>\begin{cases}<br>x + 1 &amp; x \geq 0, \<br>x - 1 &amp; x &lt; 0<br>\end{cases}<br>]$<br>在 $\ ( x&#x3D;0 )$ 处，左极限为 $\ (-1)$，右极限为 $\ (1)$，形成跳跃。</li></ul><hr><h3 id="2-第二类间断点（至少一侧极限不存在）"><a href="#2-第二类间断点（至少一侧极限不存在）" class="headerlink" title="2. 第二类间断点（至少一侧极限不存在）"></a><strong>2. 第二类间断点（至少一侧极限不存在）</strong></h3><h3 id="以下是第二类间断点的两个主要类型："><a href="#以下是第二类间断点的两个主要类型：" class="headerlink" title="以下是第二类间断点的两个主要类型："></a>以下是第二类间断点的两个主要类型：</h3><h3 id="a-无穷间断点（Infinite-Discontinuity）"><a href="#a-无穷间断点（Infinite-Discontinuity）" class="headerlink" title="(a) 无穷间断点（Infinite Discontinuity）"></a><strong>(a) 无穷间断点（Infinite Discontinuity）</strong></h3><p><strong>特点</strong>：</p><p>当 <code>x</code> 趋近于该点时，函数值趋向正无穷或负无穷。</p><p>通常伴随垂直渐近线。</p><p><strong>示例</strong>：当 <code>x → 0</code> 时，函数 <code>$f(x) = \frac&#123;1&#125;&#123;x&#125;$</code> 的值趋向 <code>±∞</code>。</p><h3 id="b-振荡间断点（Oscillatory-Discontinuity）"><a href="#b-振荡间断点（Oscillatory-Discontinuity）" class="headerlink" title="(b) 振荡间断点（Oscillatory Discontinuity）"></a><strong>(b) 振荡间断点（Oscillatory Discontinuity）</strong></h3><p><strong>特点</strong>：</p><p>函数在该点附近无限振荡，导致极限不存在。</p><p>常见于涉及三角函数或周期函数的复杂表达式中。</p><p><strong>示例</strong>：考虑函数 <code>$f(x) = sin(\frac&#123;1&#125;&#123;x&#125;)$</code> 当 <code>x → 0</code> 时，函数值在 <code>[-1,1]</code> 之间无限振荡，因此极限不存在。</p><hr><h3 id="3-其他特殊类型（补充说明）"><a href="#3-其他特殊类型（补充说明）" class="headerlink" title="3. 其他特殊类型（补充说明）"></a><strong>3. 其他特殊类型（补充说明）</strong></h3><h3 id="混合型间断点"><a href="#混合型间断点" class="headerlink" title="混合型间断点"></a><strong>混合型间断点</strong></h3><ul><li><strong>特点</strong>：<ul><li>结合多种不连续行为，例如一侧趋向无穷，另一侧振荡。</li></ul></li><li><strong>示例</strong>：<br>$\<br>f(x) &#x3D;<br>\begin{cases}<br>\frac{1}{x} &amp; x &gt; 0, \<br>\sin\left(\frac{1}{x}\right) &amp; x &lt; 0<br>\end{cases}$<br>在 $\ ( x&#x3D;0 )$ 处，右侧趋向 $\ ( +\infty )，$左侧振荡。</li></ul><h3 id="本质不连续点（Essential-Discontinuity）"><a href="#本质不连续点（Essential-Discontinuity）" class="headerlink" title="本质不连续点（Essential Discontinuity）"></a><strong>本质不连续点（Essential Discontinuity）</strong></h3><ul><li><strong>别名</strong>：部分文献将第二类间断点统称为本质不连续点。</li></ul><hr><h3 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a><strong>总结表格</strong></h3><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>可去间断点</strong></td><td>极限存在但函数值不符未定义</td><td>$\ \frac{\sin x}{x}$</td></tr><tr><td><strong>跳跃间断点</strong></td><td>左右极限存在但不相等</td><td>分段函数跳跃点</td></tr><tr><td><strong>无穷间断点</strong></td><td>函数趋向无穷大或无穷小</td><td>$\ \frac{1}{x}$</td></tr><tr><td><strong>振荡间断点</strong></td><td>函数无限振荡，极限不存在</td><td>$\ \sin\left(\frac{1}{x}\right)$</td></tr></tbody></table><hr><h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a><strong>关键区别</strong></h3><ul><li><strong>第一类 vs 第二类</strong>：<br>第一类间断点的左右极限均存在（可比较大小），第二类至少一侧不存在或趋向无穷。</li><li><strong>可修复性</strong>：<br>仅可去间断点可通过修正函数值恢复连续性。</li></ul><p>通过以上分类，可系统分析函数在不同点的不连续行为。</p>]]></content>
    
    
    
    <tags>
      
      <tag>默认标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3月份半个月学习计划</title>
    <link href="/2025/03/01/3%E6%9C%88%E4%BB%BD%E5%8D%8A%E4%B8%AA%E6%9C%88%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <url>/2025/03/01/3%E6%9C%88%E4%BB%BD%E5%8D%8A%E4%B8%AA%E6%9C%88%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>以下是重新优化后的<strong>15天考研数学一（高数核心）与数据结构系统学习计划</strong>，<strong>移除概率论</strong>，全面覆盖高数重点章节（包括多元微积分、曲线曲面积分、无穷级数等），并保持数据结构每日3-4小时系统学习。计划按<strong>“基础-强化-综合”三阶段</strong>推进，确保扎实掌握。</p><hr><h3 id="调整后核心策略"><a href="#调整后核心策略" class="headerlink" title="调整后核心策略"></a><strong>调整后核心策略</strong></h3><ol><li><strong>优先级</strong>：数学一高数（70%）+ 数据结构（30%），每天学习10-12小时。</li><li><strong>高数重点</strong>：极限→一元微积分→多元微积分→重积分→曲线曲面积分→级数→微分方程。</li><li><strong>数据结构</strong>：线性表→树→图→排序&#x2F;查找→真题，每日代码实操。</li><li><strong>学习逻辑</strong>：视频+教材+题型分类+错题本，拒绝遗漏核心考点。</li></ol><hr><h3 id="每日作息强化版"><a href="#每日作息强化版" class="headerlink" title="每日作息强化版"></a><strong>每日作息强化版</strong></h3><table><thead><tr><th>时间段</th><th>内容</th></tr></thead><tbody><tr><td>7:00-8:00</td><td>起床+背诵公式（如格林公式、DFS代码模板）</td></tr><tr><td>8:30-12:00</td><td>数学攻坚（视频+例题）</td></tr><tr><td>14:00-17:00</td><td>数据结构系统学习（教材+代码）</td></tr><tr><td>19:00-21:00</td><td>数学&#x2F;数据结构交叉刷题</td></tr><tr><td>21:30-22:30</td><td>错题整理+Anki记忆卡</td></tr></tbody></table><hr><h3 id="第一阶段：基础框架搭建（Day-1-5）"><a href="#第一阶段：基础框架搭建（Day-1-5）" class="headerlink" title="第一阶段：基础框架搭建（Day 1-5）"></a><strong>第一阶段：基础框架搭建（Day 1-5）</strong></h3><h3 id="Day-1-2：高数极限与连续-数据结构线性表"><a href="#Day-1-2：高数极限与连续-数据结构线性表" class="headerlink" title="Day 1-2：高数极限与连续 + 数据结构线性表"></a><strong>Day 1-2：高数极限与连续 + 数据结构线性表</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>张宇&#x2F;武忠祥极限视频（1.5倍速，重点：泰勒展开、夹逼定理）</li><li>《复习全书》例题（极限存在性证明、∞&#x2F;∞型计算）</li></ul></li><li>下午2h：<ul><li>刷《660题》极限部分（题1-30）+ 错题整理</li></ul></li><li>晚上1h：<ul><li>默写等价无穷小替换表、泰勒公式到x³项</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>顺序表与链表操作（插入&#x2F;删除时间复杂度）</li><li>手写代码：单链表反转（LeetCode 206）、合并有序链表（LeetCode 21）</li></ul></li><li>晚上1h：<ul><li>王道选择题（链表特性与应用场景）</li></ul></li></ul></li></ul><h3 id="Day-3-4：高数一元微分学-数据结构栈与队列"><a href="#Day-3-4：高数一元微分学-数据结构栈与队列" class="headerlink" title="Day 3-4：高数一元微分学 + 数据结构栈与队列"></a><strong>Day 3-4：高数一元微分学 + 数据结构栈与队列</strong></h3><ul><li><h2 id="数学任务（每天7小时）：-上午4h："><a href="#数学任务（每天7小时）：-上午4h：" class="headerlink" title="数学任务（每天7小时）：  - 上午4h："></a><strong>数学任务</strong>（每天7小时）：<br>  - 上午4h：</h2><pre><code class="hljs">  - 武忠祥导数应用视频（极值、凹凸性、渐近线）  - 《复习全书》例题（中值定理证明题）</code></pre><ul><li>下午2h：<ul><li>刷《660题》导数部分（题31-60）+ 总结辅助函数构造法</li></ul></li><li>晚上1h：<ul><li>整理导数公式表（参数方程、隐函数求导）</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>栈实现队列（LeetCode 232）、循环队列判满&#x2F;判空</li><li>手写代码：括号匹配（LeetCode 20）</li></ul></li><li>晚上1h：<ul><li>王道选择题（栈与队列的典型应用）</li></ul></li></ul></li></ul><h3 id="Day-5：高数一元积分学-数据结构树基础"><a href="#Day-5：高数一元积分学-数据结构树基础" class="headerlink" title="Day 5：高数一元积分学 + 数据结构树基础"></a><strong>Day 5：高数一元积分学 + 数据结构树基础</strong></h3><ul><li><strong>数学任务</strong>（7小时）：<ul><li>上午4h：<ul><li>张宇积分技巧视频（分部积分、三角代换）</li><li>《复习全书》例题（定积分几何应用、反常积分）</li></ul></li><li>下午2h：<ul><li>刷《660题》积分部分（题81-110）</li></ul></li><li>晚上1h：<ul><li>整理积分公式表（如∫√(a²-x²)dx）</li></ul></li></ul></li><li><strong>数据结构</strong>（3小时）：<ul><li>下午穿插2h：<ul><li>二叉树遍历（先序&#x2F;中序递归与非递归）</li><li>手写代码：中序非递归遍历（栈实现）</li></ul></li><li>晚上1h：<ul><li>王道选择题（二叉树节点数计算）</li></ul></li></ul></li></ul><hr><h3 id="第二阶段：高数核心强化（Day-6-10）"><a href="#第二阶段：高数核心强化（Day-6-10）" class="headerlink" title="第二阶段：高数核心强化（Day 6-10）"></a><strong>第二阶段：高数核心强化（Day 6-10）</strong></h3><h3 id="Day-6-7：高数多元微分学-数据结构树应用"><a href="#Day-6-7：高数多元微分学-数据结构树应用" class="headerlink" title="Day 6-7：高数多元微分学 + 数据结构树应用"></a><strong>Day 6-7：高数多元微分学 + 数据结构树应用</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>武忠祥多元微分视频（偏导数、全微分、方向导数）</li><li>《复习全书》例题（隐函数求导、条件极值）</li></ul></li><li>下午2h：<ul><li>刷《660题》多元微分部分（题200-230）</li></ul></li><li>晚上1h：<ul><li>总结梯度、方向导数与极值的关系</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>平衡二叉树（AVL树旋转）、二叉搜索树验证（LeetCode 98）</li></ul></li><li>晚上1h：<ul><li>王道选择题（AVL树插入调整步骤）</li></ul></li></ul></li></ul><h3 id="Day-8-9：高数重积分-数据结构图基础"><a href="#Day-8-9：高数重积分-数据结构图基础" class="headerlink" title="Day 8-9：高数重积分 + 数据结构图基础"></a><strong>Day 8-9：高数重积分 + 数据结构图基础</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>张宇重积分视频（二重&#x2F;三重积分计算、极坐标&#x2F;柱坐标变换）</li><li>《复习全书》例题（交换积分次序、奇偶性简化）</li></ul></li><li>下午2h：<ul><li>刷《660题》重积分部分（题240-270）</li></ul></li><li>晚上1h：<ul><li>整理对称性简化技巧（如轮换对称性）</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>图的存储（邻接矩阵&#x2F;邻接表）、DFS&#x2F;BFS代码实现</li><li>手写代码：课程表拓扑排序（LeetCode 207）</li></ul></li><li>晚上1h：<ul><li>王道选择题（DFS与BFS应用场景）</li></ul></li></ul></li></ul><h3 id="Day-10：高数曲线曲面积分-数据结构排序算法"><a href="#Day-10：高数曲线曲面积分-数据结构排序算法" class="headerlink" title="Day 10：高数曲线曲面积分 + 数据结构排序算法"></a><strong>Day 10：高数曲线曲面积分 + 数据结构排序算法</strong></h3><ul><li><strong>数学任务</strong>（7小时）：<ul><li>上午4h：<ul><li>武忠祥曲线积分视频（第一&#x2F;二型曲线积分、格林公式）</li><li>《复习全书》例题（参数化计算、斯托克斯公式）</li></ul></li><li>下午2h：<ul><li>刷《660题》曲线曲面积分部分（题280-310）</li></ul></li><li>晚上1h：<ul><li>总结高斯公式与散度、旋度的联系</li></ul></li></ul></li><li><strong>数据结构</strong>（3小时）：<ul><li>下午穿插2h：<ul><li>快速排序&#x2F;堆排序非递归实现、稳定性分析</li><li>手写代码：快速排序分区函数（Hoare法）</li></ul></li><li>晚上1h：<ul><li>王道选择题（排序算法时间复杂度对比）</li></ul></li></ul></li></ul><hr><h3 id="第三阶段：综合冲刺（Day-11-15）"><a href="#第三阶段：综合冲刺（Day-11-15）" class="headerlink" title="第三阶段：综合冲刺（Day 11-15）"></a><strong>第三阶段：综合冲刺（Day 11-15）</strong></h3><h3 id="Day-11-12：高数无穷级数-数据结构查找算法"><a href="#Day-11-12：高数无穷级数-数据结构查找算法" class="headerlink" title="Day 11-12：高数无穷级数 + 数据结构查找算法"></a><strong>Day 11-12：高数无穷级数 + 数据结构查找算法</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>上午4h：<ul><li>张宇级数视频（正项级数、幂级数求和、傅里叶级数）</li><li>《复习全书》例题（收敛性判别、展开式求系数）</li></ul></li><li>下午2h：<ul><li>刷《660题》级数部分（题320-350）</li></ul></li><li>晚上1h：<ul><li>整理常见展开式（如1&#x2F;(1-x)&#x3D;∑xⁿ, |x|&lt;1）</li></ul></li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>哈希表冲突处理（拉链法、开放定址法）</li><li>手写代码：LRU缓存（LeetCode 146）</li></ul></li><li>晚上1h：<ul><li>王道选择题（B树与B+树差异）</li></ul></li></ul></li></ul><h3 id="Day-13-14：高数真题模拟-数据结构真题"><a href="#Day-13-14：高数真题模拟-数据结构真题" class="headerlink" title="Day 13-14：高数真题模拟 + 数据结构真题"></a><strong>Day 13-14：高数真题模拟 + 数据结构真题</strong></h3><ul><li><strong>数学任务</strong>（每天7小时）：<ul><li>限时3h完成2020年真题</li><li>4h逐题分析错因（重点：曲线积分与级数大题）</li></ul></li><li><strong>数据结构</strong>（每天3小时）：<ul><li>下午穿插2h：<ul><li>408真题（2015-2020数据结构大题）</li><li>重点：二叉树非递归遍历、图最短路径</li></ul></li><li>晚上1h：<ul><li>复盘代码边界条件（如指针判空、循环终止）</li></ul></li></ul></li></ul><h3 id="Day-15：总复习与补漏"><a href="#Day-15：总复习与补漏" class="headerlink" title="Day 15：总复习与补漏"></a><strong>Day 15：总复习与补漏</strong></h3><ul><li><strong>数学</strong>（7小时）：<ul><li>上午4h：默写核心公式（从极限到曲面积分）</li><li>下午3h：重做高数错题（如格林公式应用）</li></ul></li><li><strong>数据结构</strong>（3小时）：<ul><li>系统复盘线性表→图→排序</li><li>手写代码：二叉树层序遍历（LeetCode 102）</li></ul></li></ul><hr><h3 id="每日作息强化版-1"><a href="#每日作息强化版-1" class="headerlink" title="每日作息强化版"></a><strong>每日作息强化版</strong></h3><table><thead><tr><th>时间段</th><th>内容</th></tr></thead><tbody><tr><td>7:00-8:00</td><td>起床+背诵公式（如格林公式、DFS代码模板）</td></tr><tr><td>8:30-12:00</td><td>数学攻坚（视频+例题）</td></tr><tr><td>14:00-17:00</td><td>数据结构系统学习（教材+代码）</td></tr><tr><td>19:00-21:00</td><td>数学&#x2F;数据结构交叉刷题</td></tr><tr><td>21:30-22:30</td><td>错题整理+Anki记忆卡</td></tr></tbody></table><hr><h3 id="关键执行原则"><a href="#关键执行原则" class="headerlink" title="关键执行原则"></a><strong>关键执行原则</strong></h3><ol><li><strong>高数优先级</strong>：若时间紧张，优先完成<strong>曲线曲面积分</strong>和<strong>级数</strong>，这两部分是数一特有且难度较高的考点。</li><li><strong>数据结构代码</strong>：每日至少手写1题，重点训练<strong>非递归遍历</strong>和<strong>算法应用</strong>（如拓扑排序）。</li><li><strong>错题本</strong>：按章节分类记录错题，每晚睡前回顾10分钟。</li><li><strong>健康管理</strong>：每学习1小时休息5分钟，每天保证6小时睡眠。</li></ol><p><strong>按此计划，15天内可系统攻克高数全部核心内容，并保持数据结构代码手感！</strong> 如需进一步细化某部分（如曲线积分参数化方法），请随时告知！</p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天一题蓝桥杯：报数游戏</title>
    <link href="/2024/10/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E6%8A%A5%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/10/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E6%8A%A5%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="今日蓝桥杯题目"><a href="#今日蓝桥杯题目" class="headerlink" title="今日蓝桥杯题目"></a>今日蓝桥杯题目</h1><p>小蓝和朋友们在玩一个报数游戏。由于今年是2024 年，他们决定要从小到大轮流报出是20 或 24倍数的正整数。前10 个被报出的数是：20,24,40,48,60,72,80,96,100,120。请问第202420242024 个被报出的数是多少?</p><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p><strong>目标</strong>：找出第 ( n ) 个是 <strong>20</strong> 或 <strong>24</strong> 的倍数的正整数，按从小到大的顺序排列，且不重复。</p><p><strong>示例</strong>：</p><ul><li>前10个被报出的数是：20, 24, 40, 48, 60, 72, 80, 96, 100, 120。</li></ul><h1 id="为什么使用二分查找？"><a href="#为什么使用二分查找？" class="headerlink" title="为什么使用二分查找？"></a>为什么使用二分查找？</h1><p>在处理这样的问题时，直接枚举所有满足条件的数直到找到第 ( n ) 个数是不现实的，尤其当 ( n ) 很大（如 ( n &#x3D; 202420242024 )）时。因此，我们需要一种更高效的方法来定位目标数的位置。<strong>二分查找</strong> 是一种适合此类问题的高效算法。</p><h2 id="二分查找的基本原理"><a href="#二分查找的基本原理" class="headerlink" title="二分查找的基本原理"></a>二分查找的基本原理</h2><p><strong>二分查找</strong> 是一种在有序数组中查找特定元素的算法，其基本思想是通过不断将搜索范围缩小一半来快速定位目标元素。虽然在这个问题中，我们不是在一个固定的数组中查找元素，而是在一个按特定规则生成的数列中查找第 ( n ) 个元素，但二分查找的思想仍然适用。</p><h2 id="应用于本问题的二分查找步骤"><a href="#应用于本问题的二分查找步骤" class="headerlink" title="应用于本问题的二分查找步骤"></a>应用于本问题的二分查找步骤</h2><ol><li><p><strong>定义搜索范围</strong>：</p><ul><li><strong>左界（Left）</strong>：最小可能的数，通常设为 1。</li><li><strong>右界（Right）</strong>：最大可能的数，可以初步设为 $( n \times \text{max}(a, b) )$。在本例中，( a &#x3D; 20 )，( b &#x3D; 24 )，所以右界可以设为 ( n \times 24 )。</li></ul></li><li><p><strong>计算中点</strong>：</p><ul><li>计算当前搜索范围的中点 $( \text{mid} &#x3D; \left\lfloor \frac{\text{left} + \text{right}}{2} \right\rfloor )$。</li></ul></li><li><p><strong>计算中点位置的满足条件的数的数量</strong>：</p><ul><li>使用容斥原理计算不超过 $( \text{mid} )$ 的 <strong>20</strong> 或 <strong>24</strong> 的倍数的数量 $( C(\text{mid}) )$：<br>$$<br>C(\text{mid}) &#x3D; \left\lfloor \frac{\text{mid}}{20} \right\rfloor + \left\lfloor \frac{\text{mid}}{24} \right\rfloor - \left\lfloor \frac{\text{mid}}{120} \right\rfloor<br>$$<br>其中，<strong>120</strong> 是 <strong>20</strong> 和 <strong>24</strong> 的最小公倍数（LCM）。</li></ul></li><li><p><strong>调整搜索范围</strong>：</p><ul><li>**如果 $( C(\text{mid}) &lt; n )$**：<ul><li>说明第 ( n ) 个数位于 ( \text{mid} ) 右侧，因此将左界设为 ( \text{mid} + 1 )。</li></ul></li><li>**否则（$( C(\text{mid}) \geq n )$**：<ul><li>说明第 $( n ) 个数位于 ( \text{mid} )$ 左侧或就是 $( \text{mid} )$，因此将右界设为 $( \text{mid} )$。</li></ul></li></ul></li><li><p><strong>重复步骤 2-4</strong>，直到左界等于右界。</p></li><li><p><strong>最终结果</strong>：</p><ul><li>当左界与右界相等时，该值即为第 ( n ) 个满足条件的数。</li></ul></li></ol><h2 id="为什么-C-x-n-表示-x-太小？"><a href="#为什么-C-x-n-表示-x-太小？" class="headerlink" title="为什么 $( C(x) &lt; n ) 表示 ( x )$ 太小？"></a>为什么 $( C(x) &lt; n ) 表示 ( x )$ 太小？</h2><h3 id="定义计数函数-C-x"><a href="#定义计数函数-C-x" class="headerlink" title="定义计数函数 $( C(x) )$"></a>定义计数函数 $( C(x) )$</h3><p>对于任意正整数 ( x )，( C(x) ) 表示不超过 ( x ) 的数中，既是 <strong>20</strong> 或 <strong>24</strong> 的倍数的数的数量：<br>$$<br>C(x) &#x3D; \left\lfloor \frac{x}{20} \right\rfloor + \left\lfloor \frac{x}{24} \right\rfloor - \left\lfloor \frac{x}{120} \right\rfloor<br>$$</p><h3 id="二分查找的目标"><a href="#二分查找的目标" class="headerlink" title="二分查找的目标"></a>二分查找的目标</h3><p>我们希望找到最小的 ( x )，使得 ( C(x) &#x3D; n )。换句话说，找到第 ( n ) 个满足条件的数，即第 ( n ) 个 <strong>20</strong> 或 <strong>24</strong> 的倍数。</p><h3 id="搜索过程中的判断"><a href="#搜索过程中的判断" class="headerlink" title="搜索过程中的判断"></a>搜索过程中的判断</h3><ul><li><p>**如果 $( C(\text{mid}) &lt; n )$**：</p><ul><li>说明在 ( 1 ) 到 $( \text{mid} )$ 之间，只有 $( C(\text{mid}) )$ 个数满足条件，但我们需要第 ( n ) 个数。</li><li>因此，第 ( n ) 个数 **必定大于 $( \text{mid} )$**。</li><li><strong>结论</strong>：当前的 $( \text{mid} )$ 太小，无法包含第 ( n ) 个数，需要在更大的范围内继续搜索。</li></ul></li><li><p>**如果 $( C(\text{mid}) \geq n )$**：</p><ul><li>说明第 ( n ) 个数 <strong>可能在 $( \text{mid} )$ 之前</strong>，也可能就是 $( \text{mid} )$ 本身。</li><li><strong>结论</strong>：需要在较小的范围内继续搜索，缩小右界。</li></ul></li></ul><h2 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h2><p>想象一下你正在寻找一个特定位置的数，例如第1000个满足条件的数。通过二分查找，你每次选择一个中间值并计算在这个中间值之前有多少个满足条件的数：</p><ul><li><strong>如果计算出的数量 $( C(\text{mid}) )$ 比目标 ( n ) 小</strong>，说明第 ( n ) 个数还没到，需要往更大的方向看。</li><li><strong>如果计算出的数量 $( C(\text{mid}) )$ 大于或等于目标 ( n )</strong>，说明目标数已经在 $( \text{mid} )$ 或更小的范围内，可以缩小搜索范围，继续在较小的范围内寻找精确的位置。</li></ul><h2 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h2><p><strong>目标</strong>：找到第10个是 <strong>20</strong> 或 <strong>24</strong> 的倍数的数。</p><ol><li><p><strong>初始化搜索范围</strong>：</p><ul><li>左界 $( \text{left} &#x3D; 1 )$</li><li>右界 $( \text{right} &#x3D; 10 \times 24 &#x3D; 240 )（初步设定为 ( n \times \text{max}(a, b) )）$</li></ul></li><li><p><strong>第一次迭代</strong>：</p><ul><li>中点 $( \text{mid} &#x3D; \left\lfloor \frac{1 + 240}{2} \right\rfloor &#x3D; 120 )$</li><li>计算 ( C(120) )：<br>$$<br>C(120) &#x3D; \left\lfloor \frac{120}{20} \right\rfloor + \left\lfloor \frac{120}{24} \right\rfloor - \left\lfloor \frac{120}{120} \right\rfloor &#x3D; 6 + 5 - 1 &#x3D; 10<br>$$</li><li><strong>比较 ( C(120) &#x3D; 10 ) 与 ( n &#x3D; 10 )</strong>：<ul><li>因为 $( C(120) \geq n )$，将右界设为 ( 120 )。</li></ul></li></ul></li><li><p><strong>第二次迭代</strong>：</p><ul><li>新的搜索范围：$( \text{left} &#x3D; 1 )$，$( \text{right} &#x3D; 120 )$</li><li>中点 $( \text{mid} &#x3D; \left\lfloor \frac{1 + 120}{2} \right\rfloor &#x3D; 60 )$</li><li>计算 ( C(60) )：<br>$$<br>C(60) &#x3D; \left\lfloor \frac{60}{20} \right\rfloor + \left\lfloor \frac{60}{24} \right\rfloor - \left\lfloor \frac{60}{120} \right\rfloor &#x3D; 3 + 2 - 0 &#x3D; 5<br>$$</li><li><strong>比较 ( C(60) &#x3D; 5 ) 与 ( n &#x3D; 10 )</strong>：<ul><li>因为 ( C(60) &lt; n )，将左界设为 ( 61 )。</li></ul></li></ul></li><li><p><strong>第三次迭代</strong>：</p><ul><li>新的搜索范围：$( \text{left} &#x3D; 61 )$，$( \text{right} &#x3D; 120 )$</li><li>中点 $( \text{mid} &#x3D; \left\lfloor \frac{61 + 120}{2} \right\rfloor &#x3D; 90 )$</li><li>计算 ( C(90) )：<br>$$<br>C(90) &#x3D; \left\lfloor \frac{90}{20} \right\rfloor + \left\lfloor \frac{90}{24} \right\rfloor - \left\lfloor \frac{90}{120} \right\rfloor &#x3D; 4 + 3 - 0 &#x3D; 7<br>$$</li><li><strong>比较 ( C(90) &#x3D; 7 ) 与 ( n &#x3D; 10 )</strong>：<ul><li>因为 ( C(90) &lt; n )，将左界设为 ( 91 )。</li></ul></li></ul></li><li><p><strong>继续迭代</strong>，直到左界等于右界：</p><ul><li>最终会发现，当 $( \text{left} &#x3D; 120 )$ 时，( C(120) &#x3D; 10 )，满足条件。</li><li><strong>结果</strong>：( x &#x3D; 120 )</li></ul></li></ol><p><strong>验证结果</strong>：</p><ul><li>前10个数确实是：20, 24, 40, 48, 60, 72, 80, 96, 100, 120。</li><li>因此，算法正确地找到了第10个数是 <strong>120</strong>。</li></ul><h2 id="为什么二分查找有效？"><a href="#为什么二分查找有效？" class="headerlink" title="为什么二分查找有效？"></a>为什么二分查找有效？</h2><ul><li><strong>有序性</strong>：满足条件的数按升序排列，二分查找依赖于这一特性，通过比较中点位置的数的数量与目标 ( n ) 之间的关系，逐步缩小搜索范围。</li><li><strong>效率</strong>：二分查找的时间复杂度为 $( O(\log N) )$，远比线性搜索（时间复杂度 ( O(N) )）高效，特别是在 ( N ) 很大的情况下。</li></ul><h2 id="二分查找在此问题中的关键点"><a href="#二分查找在此问题中的关键点" class="headerlink" title="二分查找在此问题中的关键点"></a>二分查找在此问题中的关键点</h2><ol><li><p><strong>定义搜索范围</strong>：</p><ul><li>初始左界设为 1，右界设为 $( n \times \text{max}(a, b) )$。</li><li>在本例中，( a &#x3D; 20 )，( b &#x3D; 24 )，所以右界可以设为 $( n \times 24 )$。</li></ul></li><li><p><strong>中点计算与比较</strong>：</p><ul><li>通过计算中点 $( \text{mid} )$ 的位置，利用容斥原理计算不超过 $( \text{mid} )$ 的满足条件的数的数量 $( C(\text{mid}) )$。</li><li>**如果 $( C(\text{mid}) &lt; n )$**，则更新左界为 $( \text{mid} + 1 )$。</li><li><strong>否则</strong>，将右界设为 $( \text{mid} )$。</li></ul></li><li><p><strong>终止条件</strong>：</p><ul><li>当左界等于右界时，搜索结束，左界（或右界）即为第 ( n ) 个满足条件的数。</li></ul></li></ol><h1 id="解决代码示例"><a href="#解决代码示例" class="headerlink" title="解决代码示例"></a>解决代码示例</h1><p>以下是一个完整的 Python 实现，结合了二分查找和容斥原理，用于精确找到第 ( n ) 个是 <strong>a</strong> 或 <strong>b</strong> 的倍数的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcm</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算两个数的最小公倍数&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> gcd<br>    <span class="hljs-keyword">return</span> a * b // gcd(a, b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_multiples</span>(<span class="hljs-params">x, a, b</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算不超过 x 的 a 或 b 的倍数的数量&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> x // a + x // b - x // lcm(a, b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_nth_number</span>(<span class="hljs-params">n, a, b</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;使用二分查找找到第 n 个是 a 或 b 的倍数的数&quot;&quot;&quot;</span><br>    left = <span class="hljs-number">1</span><br>    right = n * <span class="hljs-built_in">max</span>(a, b)  <span class="hljs-comment"># 初始右界设为 n * max(a, b)</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        mid = (left + right) // <span class="hljs-number">2</span><br>        current_count = count_multiples(mid, a, b)<br>        <span class="hljs-keyword">if</span> current_count &lt; n:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid<br>    <span class="hljs-keyword">return</span> left<br><br><span class="hljs-comment"># 示例 1: 寻找第 202420242024 个是 20 或 24 的倍数的数</span><br>n = <span class="hljs-number">202420242024</span><br>a = <span class="hljs-number">20</span><br>b = <span class="hljs-number">24</span><br>result = find_nth_number(n, a, b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第 <span class="hljs-subst">&#123;n&#125;</span> 个被报出的数是: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)  <span class="hljs-comment"># 输出: 2429042904288</span><br><br><span class="hljs-comment"># 示例 2: 寻找第 1000 个是 10 或 15 的倍数的数</span><br>n = <span class="hljs-number">1000</span><br>a = <span class="hljs-number">10</span><br>b = <span class="hljs-number">15</span><br>result = find_nth_number(n, a, b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第 <span class="hljs-subst">&#123;n&#125;</span> 个被报出的数是: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)  <span class="hljs-comment"># 输出: 7500</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯学习</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天一题蓝桥杯：单词博弈</title>
    <link href="/2024/10/15/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88/"/>
    <url>/2024/10/15/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%A2%98%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88/</url>
    
    <content type="html"><![CDATA[<h1 id="今日蓝桥杯题目"><a href="#今日蓝桥杯题目" class="headerlink" title="今日蓝桥杯题目"></a>今日蓝桥杯题目</h1><p>夏日夜晚，小蓝和小桥在蓝桥公园散步。在蜿蜒的小路上，他们发现了一堆单词。</p><p>小蓝和小桥对这些单词饶有兴致，于是开始收集它们：小蓝收集了n 个单词，小桥收集了m 个单词。收集完单词后，他们决定玩一个游戏。</p><p>游戏规则如下：每一回合，玩家需要从自己收集到的单词中说出一个单词。所说的单词必须满足以下条件：该单词的字典序大小要比上一个单词大，并且该单词要么与上一个单词以相同的字母开头，要么以字母表中紧随其后的字母开头。</p><p>例如，如果上一个单词是 apple，那么接下来的单词可以是：</p><p>以相同字母 a 开头的单词，如：apply。以字母表中紧随 a 之后的字母 b 开头的单词，如 banana。<br>如果某个玩家无法满足上述条件，则该玩家输掉游戏。</p><p>小蓝和小桥轮流进行，由小蓝率先开始。</p><p>已知小蓝第一次会说出自己单词堆中按字典序排列最小的单词。请问，如果小蓝和小桥都按照最优策略进行游戏，谁会获胜？</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br>n , m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>a =[<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>b = [<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>a.sort(reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#这是正序，倒序就是reverse：true</span><br>b.sort(reverse= <span class="hljs-literal">True</span>) <br><br>flag = <span class="hljs-literal">True</span><br>pre = a.pop()<br><br><span class="hljs-keyword">while</span>(flag <span class="hljs-keyword">and</span> a) <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> flag <span class="hljs-keyword">and</span> b):<br>    <span class="hljs-keyword">if</span> flag:  <span class="hljs-comment">#flag为true的时候，这时候小蓝已经说过一个了， 所以轮到小桥</span><br>        word = a.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span> ) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">False</span><br>            pre = word<br>    <span class="hljs-keyword">else</span>:<br>        word = b.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span>) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">True</span><br>            pre = word<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;L&#x27;</span>) <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Q&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>接下来是hexo的内置代码块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br>n , m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>a =[<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>b = [<span class="hljs-built_in">input</span>() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>a.sort(reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#这是正序，倒序就是reverse：true</span><br>b.sort(reverse= <span class="hljs-literal">True</span>) <br><br>flag = <span class="hljs-literal">True</span><br>pre = a.pop()<br><br><span class="hljs-keyword">while</span>(flag <span class="hljs-keyword">and</span> a) <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> flag <span class="hljs-keyword">and</span> b):<br>    <span class="hljs-keyword">if</span> flag:  <span class="hljs-comment">#flag为true的时候，这时候小蓝已经说过一个了， 所以轮到小桥</span><br>        word = a.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span> ) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">False</span><br>            pre = word<br>    <span class="hljs-keyword">else</span>:<br>        word = b.pop()<br>        <span class="hljs-keyword">if</span> (word[<span class="hljs-number">0</span>] == pre[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> word[<span class="hljs-number">0</span>] == <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(pre[<span class="hljs-number">0</span>])+<span class="hljs-number">1</span>) ) <span class="hljs-keyword">and</span> word &gt; pre :<br>            flag = <span class="hljs-literal">True</span><br>            pre = word<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;L&#x27;</span>) <span class="hljs-keyword">if</span> flag <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Q&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="学习到了什么？"><a href="#学习到了什么？" class="headerlink" title="学习到了什么？"></a>学习到了什么？</h1><ul><li><p>字典序<br>什么是字典序，就是按照字典顺序进行比较排序的结果，比如说两个单词app，apple。从第一个字母开始进行比较，如果一样就继续对比下一个字母，直到不一样。比如到了app以后，apple还有le，而app则没有了，app的字典序就比apple要小。排序就是’app&lt;apple’。</p></li><li><p>字典序排序<br>如果有很多个单词进行字典序比较，是不是会比较头疼？但是实际上python和c++中已经内置了字典序排序，可以直接使用<code>sort()</code>或者是<code>reverse()</code>函数直接对多个对象进行字典序排序。<code>sort()</code>是从小到大进行排序，反之从大到小。</p></li><li><p>列表推导式<br>代码里用到列表推导式：<code>a = [input() for _ in range(n)]</code>，或者其他的形式<code>a = list(map(int , input().split()))</code>，这样的式子简洁高效，要记住。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
